---
title: "Corrections_to_ASV_library"
author: "MCarew"
date: "2024-09-06"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
requiredPackages <- c("osfr","dplyr")
lapply(requiredPackages, require, character.only = TRUE)

knitr::opts_chunk$set(echo = TRUE)
# Function equivalent to excel's =RIGHT() and =LEFT() functions
right <- function(x, n) {substr(x, nchar(x) - n + 1, nchar(x))}
left <- function(x, n) {substr(x, 1, n)}

# Check requisite source data files and the 
# taxonomy, exclusion, and BOLD files are in data directory, 
# And if not download them from OSF into that directory
# Note that these files are deleted again at the end of the script
# to guard against corruption of the files.  If there is a data subdirectory
# of the working directory, make sure it is has none of the 8 data_files listed 
# below in it before running the script.

## Check if there is a 'data' directory. If not make one
if(!"data" %in% dir()){dir.create("data")}
## Check for large data files. If absent download them 
# ## from the OSF repository to the data directory
data_files <- c("taxonomy.xlsx","non_aqu_macro_invert.csv",
                "asv_library_97_match_list_with_bin_uris_2024-12-15.rda",
                "asv_library_97_match_list_to_BOLD_2024-12-15.rda",
                "additions_asv_library_oct24.xlsx",
                "asv_library_97_add_miseq15-20_records.csv",
                "asv_library_97_aug24.xlsx",
                "filtered_97_data.csv")
missing <- data_files[!data_files %in% dir("data")]
if(length(missing) > 0){
 dl_files <- osfr::osf_retrieve_node("hvx69") %>% osfr::osf_ls_files()
 osfr::osf_download(dl_files, path = "data", conflicts = "skip")
}

# TO DO with OSF repository.
# replace "asv_library_97_match_list_to_BOLD_2024-12-15.rda" with compiled BOLD results table (this will require a separate data compilation script.)
# replace "asv_library_97_match_list_to_BOLD_2024-12-15.rda" with list compiled in this scrip

```

## Introduction

This document amends the file 'asv_library_97_aug24.xlsx', generated in excel from earlier miSeq runs. Vsearch output files containing taxonomic assignments for asv's from each miseq run were inspected for incomplete taxonomic classifications (truncated_fills), i.e., where a match of >97 max-p-identity was observed and no species name was assigned. This can occur when there are conflicting taxonomic classification for similar sequences in the reference database used by vsearch or specimens in the reference database have not been identified to species. These asv records meeting this criteria, were manually compiled into a excel spreadsheet. Each asv sequence was then checked against BOLD and in instances where BOLD did not return a match they were checked against GenBank. If additional taxonomic information was available this was added to the asv's taxonomic classification. For sequences with species matches on BOLD, but no species name was available, species names were constructed using their BOLD identifiers (bin_uri) combined with the lowest level classification on BOLD (see below). We also found errors where sequences classified >97 max-p-identity were not invertebrates but showed matches to fungi or endosymbionts for example, and some additional species not in vsearch the reference database. These were added to the asv records in a separate spreadsheet as the max-p-identity required updating (max-p-update).

The code in this document amends the file by:

- correcting spelling errors in taxonomic names;

- looking up identifiers matching the sequences from boldsystems.org, naming un-named aquatic macroinvertebrate species using their BOLD identifiers (bin_uri), and grouping species with multiple bin_uris that overlap with >97% similarity

- recompiling the worksheets of 'asv_library_97_aug24.xlsx' and saving it as ''asv_library_97_jan25.xlsx'.

# Matching records from the BOLD database

At the time of writing, the BOLD database version 5 did not have an api permitting scripted searches. We thus searched for matches for all ASV codes in the miseq data (loaded later in this script) using the web interface.

Taxonomic information, match results, ASV codes (asv_code), and sequences (asv_seq) were exported from R as '....sequence_search.csv'. The asv_code and asv_seq values were manually converted to FASTA format. These FASTA files were uploaded and searched in batches of 1,000 using the BarcodeID tool at https://id.boldsystems.org/ (via the "Rapid Species Search" option, using the public + private database). This search returns two result tables: 'Classification' and 'Combined Hits'. The 'Combined Hits' table includes all records with a match between 94% and 100%. This table was saved and renamed as shown below. In some cases, the 'Combined Hits' table failed to download, so fewer sequence records were searched.

Records were divided into three groups for sequence searches: 'unmatched' (any record not found in either max-p-update or tfill), maxp (max-p-update dataframe), and tfill (the tfill dataframe). This was done to simplify processing, as each dataset required different attention. The tfill dataset includes matches at 97% or higher and primarily requires species name updates. The max-p-update dataset may require taxonomic name updates and possibly max_p_identity adjustments. The unmatched dataset includes sequences that are not present in either of the other two tables and need to be added appropriately: to max-p-update if the max_p_identity needs updating (typically any unmatched record from MiSeq runs 13â€“20), or to tfill if the record is from MiSeq run 13, had a species match from VSEARCH, and is not already in the tfill library.

```{r}

### Results of search of the all_records asv sequences against BOLD version 5 
### using the 'rapid species search' against the 'public+private' library manually
dir_0 <- "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/"
dir_asv_lib <- paste0(dir_0,"asv_library/tfill_boldv5_search_results/")
bold_results_tfill <- rbind(
  read.csv(paste0(dir_asv_lib, "tfill_1_600BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_600_1201BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_1201-1800BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_1801_2200BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_2201_3000BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_2701_endBOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_3001_3600BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_3601_4000BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_4001_4800BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_4801_5400BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_5401_6000BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_6001_6800BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_6801_7600BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_7601_8200BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_8801_9400BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_9400_10200BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_10201_11000BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_11001_11600BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_11600_12200BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_12201_12700BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_12701_13100BOLD_results.csv")),
  read.csv(paste0(dir_asv_lib, "tfill_13100_endBOLD_results.csv")))

dir_46 <- "~/uomShare/wergStaff/MelCarew/git-data/Spring_2018_DNA_metabarcoding_data/"
wd2 <- paste0(dir_46,"/synonym_updates/BOLDv5_search_results/")
bold_results_mw46 <- rbind(
  read.csv(paste0(wd2, "MW46_unmatched_1_999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_1000_1999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_2000_2999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_3000_3999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_4000_4999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_5000_5999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_6000_6999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_7000_7999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_8000_8999_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_9000_end_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_1_700_extras_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_701_1400_extras_BOLDsearch_results.csv")),
  read.csv(paste0(wd2, "MW46_unmatched_1401_end_extras_BOLDsearch_results.csv")))

wd3 <- paste0(dir_0, "asv_library/unmatched_boldv5_search_results")
bold_results_1 <- rbind(
  read.csv(paste0(wd3, "/all_arc_unmatched_1_1000_BOLD_results.csv")),
  read.csv(paste0(wd3, "/all_arc_unmatched_1001_2000_BOLD_results.csv")),
  read.csv(paste0(wd3, "/all_arc_unmatched_2001_3000_BOLD_results.csv")),
  read.csv(paste0(wd3, "/all_arc_unmatched_3001_4000_BOLD_results.csv")),
  read.csv(paste0(wd3, "/all_arc_unmatched_4001_4821_BOLD_results.csv")),
  read.csv(paste0(wd3, "/all_arc_unmatched_4821_end_BOLD_results.csv")),
  # and some results missing from the first searches
  read.csv(paste0(wd3, "/arc_missing_1_1000.csv")),
  read.csv(paste0(wd3, "/arc_missing_1001_1600.csv")),
  read.csv(paste0(wd3, "/arc_missing_1601_end.csv")),
  read.csv(paste0(wd3, "/BOLDrechecks_700_1283.csv")),
  read.csv(paste0(wd3, "/BOLDrechecks_1_700.csv")),
  read.csv(paste0(wd3, "/BOLD_rechecks_1_12.csv")))

wd4 <- paste0(dir_0, "asv_library/maxp_boldv5_search_results")
# read in .csv files with bold barcodeID engine results.
bold_results_maxp <- rbind(
  read.csv(paste0(wd4, "/maxp_1_1000BOLD_results.csv")),
  read.csv(paste0(wd4, "/maxp_1000_endBOLD_results.csv")))

# rename bold output fields
bold_results <- rbind(bold_results_tfill, bold_results_mw46,
                      bold_results_1, bold_results_maxp)

names(bold_results)[names(bold_results) == "Query.ID"] <- "asv_code" 
names(bold_results)[names(bold_results) == "PID..BIN."] <- "pid_bin" 
names(bold_results)[names(bold_results) == "ID."] <- "similarity"
names(bold_results) <- tolower(names(bold_results))
pid_bin_split <- strsplit(bold_results$pid_bin, "\\[BOLD:")
bold_results$id <- sapply(pid_bin_split,"[[",1)
bold_results$bin_uri <- NA
bold_results$bin_uri[lengths(pid_bin_split) > 1] <- 
  gsub("]", "", sapply(pid_bin_split[lengths(pid_bin_split) > 1],"[[",2))
bold_results$bin_uri[lengths(pid_bin_split) == 1] <- 
  gsub("]", "", sapply(pid_bin_split[lengths(pid_bin_split) == 1],"[[",1))
asv_bold <- unique(bold_results$asv_code)

# keep a list of subfamilies (that don't consistently get used in mwbugs database)
subfams <- unique(bold_results[c("family","subfamily")])
subfams <- subfams[subfams$subfamily != "" & !grepl("unclassified", subfams$subfamily) &
                     !grepl("unassigned", subfams$subfamily),]

### For reference before non-aquatic/non-macroinvertebrate records are set aside in this script,
### create a table of bin_uris for all records
all_bin_uri_asv_codes <- unique(bold_results[bold_results$similarity >= 97,c("asv_code","bin_uri")])


```


# Read in source data 

First, primary data from 'asv_library_97_aug24.xlsx' spreadsheets

```{r}
# read in files

source_path <- "data/"
source_file <- "asv_library_97_aug24.xlsx"

# Read the sheets into as dataframes
tf0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
      sheet = "truncated_fills"))  

  # contains full taxonomic information for classifications with truncated taxonomy
otu_groups_df <- 
  as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                          sheet = "otu_groups", col_types = "text")) 
  # groups unclassified sequences into 'OTUs'
mp0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                                    sheet = "max_p_update"))
 # remove a duplicate record
mp0 <- mp0[!duplicated(mp0),]
  #updates/corrects any missing identifications or errors in classification
```

Then, additional data from:

- additions_asv_library_oct24.xlsx, containing additional asv records that were found with incomplete taxonomic classifications after updating the vsearch reference libraries and re-running vsearch based taxonomic assignments.

- filtered_<97_data.csv;

- records from miseq13-20 and MW46 that match records from the BOLD v5 database.

```{r}
# Additional truncated_fills records
tf1 <- as.data.frame(readxl::read_excel(paste0(source_path, 
                                               "additions_asv_library_oct24.xlsx"), 
                                        sheet = "trunc_fills")) 
tf2 <- read.csv(paste0(source_path, "asv_library_97_add_miseq15-20_records.csv"))[,-1]
# The additional records in tf2 were checked manually by Mel Carew. 7 entries in this set correct in script below

# Combine the two truncated_fill source tables into a new table 
# (keeping all original tables to permit back-checking)
truncated_fills_df <- rbind(tf0, tf1, tf2)

# Additional max_p_update records
mp1 <- read.csv(paste0(source_path, "filtered_97_data.csv"))

# update max_p_identity for those records with a corrected value
mp1$max_p_identity[!is.na(mp1$max_p_identity_corrected)] <- 
  mp1$max_p_identity_corrected[!is.na(mp1$max_p_identity_corrected)]

# Combine the source tables into a new table, but replace records in mp0 with those in mp1 where there are duplicates
max_p_update_df <- rbind(mp0[!mp0$asv_code %in% mp1$asv_code,], 
                         mp1[match(names(mp0),names(mp1))])

# Keep max_p_update_df records and remove matching records from truncated_fills
truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in%
                                           max_p_update_df$asv_code,]

truncated_fills_df[truncated_fills_df == ""] <- NA
max_p_update_df[max_p_update_df == ""] <- NA

# Major classification errors in original library (corrrected by checking on BOLD)
truncated_fills_df[truncated_fills_df$asv_code == "9ca9760013a77462d9c5e2c942e4d27e",
                   c("phylum","class","order","family","genus")] <- 
                c("Heterokontophyta","Oomycota","Peronosporales", "Peronosporaceae", "Phytophthora")
truncated_fills_df[truncated_fills_df$asv_code == "b167c9e6e63d586c8f79138f640da0cb",
                   c("family","genus","species")] <- 
                c("Eustheniidae", "Eusthenia", "Eusthenia sp. B-ABX4126")

# Remove 3 records with incorrect original assignments made by vsearch. This was discovered after double checking assignments against BOLD and GenBank and finding no matches
truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in%
                                           c("9725daabf323ef5cf9b512ee0b06f682",
                                             "160985800d21d905b2e3dff1edc1bf18",
                                             "238f54c32343060e69613167f345dd15"),]
```

The truncated_fills_df and max_p_update tables of the asv_library are combined for name correcting below.  Additional records to be added to the library from the miseq13-20 and mw46 datasets matching BOLD v5 records are extracted below, 

```{r}
# Import all miseq records for checking against the library
### MEL/CHRIS: New large files to be added to repository or another repository
miseq13 <- read.csv(paste0(dir_0, 
                      "miseq13/metabarcoding_workflow/ten_site_data_summaries/",
                      "data_for_analysis/ten_sites_long_format_25_02_2025.csv"))
dir_miseqXX <- paste0(dir_0,
                         "miseqXX/metabarcoding_workflow/final_modeling_data/")
miseq15 <- read.csv(paste0(gsub("XX","15",dir_miseqXX), 
                           "miseq15_final_data_long_format_17_02_2025.csv"))
miseq16 <- read.csv(paste0(gsub("XX","16",dir_miseqXX), 
                           "miseq16_final_data_long_format_17_02_2025.csv"))
miseq17 <- read.csv(paste0(gsub("XX","17",dir_miseqXX), 
                           "miseq17_final_data_long_format_17_02_2025.csv"))
miseq18 <- read.csv(paste0(gsub("XX","18",dir_miseqXX), 
                           "miseq18_final_data_long_format_26_02_2025.csv"))
miseq19 <- read.csv(paste0(gsub("XX","19",dir_miseqXX), 
                           "miseq19_final_data_long_format_18_02_2025.csv"))
miseq20 <- read.csv(paste0(gsub("XX","20",dir_miseqXX), 
                           "/miseq20_final_data_long_format_18_02_2025.csv"))
all_records <- rbind(miseq13[,match(names(miseq15),names(miseq13))], 
                 miseq15, miseq16, miseq17, miseq18, miseq19, miseq20)

# Remove records with phylum = "Unassigned" and with no matching record in BOLD
all_records <- all_records[!(all_records$kingdom == "Unassigned" & !all_records$asv_code %in% unique(bold_results$asv_code)),]
# Update taxonomy for the 53 unassigned records that do have a bold match
unassigned_asvs <- unique(all_records$asv_code[all_records$kingdom == "Unassigned"])  #12 asv_codes
unassigned_asvs_bold_ambig <- vector()
for(i in 1:length(unassigned_asvs)){
  boldi <- bold_results[bold_results$asv_code == unassigned_asvs[i],]
  if(max(boldi$similarity, na.rm = TRUE) >= 97){
     new_taxoni <- unique(boldi[boldi$similarity >= 97,
                               c("phylum","class","order","family","genus","species")])
    if(nrow(new_taxoni) > 1){ 
      unassigned_asvs_bold_ambig <-  c(unassigned_asvs_bold_ambig,unassigned_asvs[i])
      }else{
    all_records[all_records$asv_code == unassigned_asvs[i],
                c("phylum","class","order","family","genus","species")] <- new_taxoni
      }
     }
  if(max(boldi$similarity, na.rm = TRUE) >= 95){
    new_taxoni <- unique(boldi[boldi$similarity >= 95,
                               c("phylum","class","order","family","genus")])
    if(nrow(new_taxoni) > 1){ 
      unassigned_asvs_bold_ambig <-  c(unassigned_asvs_bold_ambig,unassigned_asvs[i])
      }else{
    all_records[all_records$asv_code == unassigned_asvs[i],
                c("phylum","class","order","family","genus")] <- new_taxoni
      }
  }
  if(max(boldi$similarity, na.rm = TRUE) < 95){
    new_taxoni <- unique(boldi[c("phylum","class","order","family")])
    if(nrow(new_taxoni) > 1){ 
      unassigned_asvs_bold_ambig <-  c(unassigned_asvs_bold_ambig,unassigned_asvs[i])
      }else{
 all_records[all_records$asv_code == unassigned_asvs[i],
                c("phylum","class","order","family")] <- new_taxoni
      }
    }
}

# Remove Unassigned records without a clear identification in BOLD
all_records <- all_records[!all_records$asv_code %in% unassigned_asvs_bold_ambig,]
# Set aside all environmental sample records
env_records <- all_records[grep("environmental",all_records$species),]
all_records <- all_records[-grep("environmental",all_records$species),]
# Change all empty strings "" to NAs
all_records[!is.na(all_records) & all_records == ""] <- NA  # nrow(all_records) - 135440

```

The above leaves 135,137 records from miseq runs 13-20 for consideration of inclusion in the asv_library below.  In the next code chunk, we also include records from an earlier study (the 46-site spring 2018 metabarcoding study), initially compiled with a different workflow to being used here.  The dataset thus required some initial cleaning and correction before adding to all_records.

```{r}

### Results of earlier 46-site spring 2018 metabarcoding study.
mw46 <- as.data.frame(
  readxl::read_excel(paste0(dir_46, "/spring2018_metabarcoding_Nov2023.xlsx"), 
                     sheet = 2))
# change column names otu_id to asv_code and asv_seq to asv_seq to align with ARC data
names(mw46)[names(mw46) == "otu_id"] <- "asv_code"
names(mw46)[names(mw46) == "otu_sequence"] <- "asv_seq"
names(mw46)[names(mw46) == "match"] <- "max_p_identity"
### reduce to unique asv_codes 
# Ad hoc corrections for consistency
mw46$family[mw46$genus == "Molophilus"] <- "Limoniidae"
### 1. Inconsistencies between asv_codes and asv_sequences (earlier excel errors)
asv_test <- unique(mw46[c("asv_code","asv_seq")])
# sum(duplicated(asv_test$asv_seq))
# asv_test[duplicated(asv_test$asv_seq) | duplicated(asv_test$asv_seq, fromLast = TRUE),]
# asv_test[duplicated(asv_test$asv_code) | duplicated(asv_test$asv_code, fromLast = TRUE),]
### This sequence is the most troubling: it is associated with 4 asv_codes
dup_seq <- "TTTATCTTCAAATATTGCTCATGGAGGTGCTTCTGTAGACCTGGCAATTTTCAGATTGCACTTAGTTGGTATTTCATCTATTTTAGGTGCTGTAAATTTTATTACTACCGTGATTAATATACGATCAAACAAAATAACCTATGACCGACTTCCACTATTTGTTTGATCAGTAGCAATTACTGCTCTTCTACTTCTTCTATCTTTACCTGTTTTAGCTGGTGCTATCACCATACTTTTAACAGACCGAAATTTAAATACTACATTTTTTGATCCTGTAGGAGGAGGAGATCCAATTTTATATCAACATCTATTT"
dup_asv_seq_codes <- unique(mw46$asv_code[mw46$asv_seq == dup_seq])
### [1] "9fbe986c778c5556f99611d0075a122a" "7ca9195991a6cad87374d1e98c6ab624" "14295e7a8819dbdc4c2c972433d09d84" "ed3ae084977ef615af77a2eee71a2c5b"
### and one of those asv_codes matches a different sequence!
other_seq <- "TTTATCTTCAAATATTGCTCATGGAGGTGCTTCTGTAGACCTGGCAATTTTCAGATTGCACTTAGCTGGTATTTCATCTATTTTAGGTGCTGTAAATTTTATTACTACCGTGATTAATATACGATCAAACAAAATAACCTATGACCGACTTCCACTATTTGTTTGATCAGTAGCAATTACTGCTCTTCTACTTCTTCTATCTTTACCTGTTTTAGCTGGTGCTATCACCATACTTTTAACAGACCGAAATTTAAATACTACATTTTTTGATCCTGTAGGAGGAGGAGATCCAATTTTATATCAACATCTATTT"
# unique(mw46$asv_code[mw46$asv_seq == other_seq])
### [1] "7ca9195991a6cad87374d1e98c6ab624"

### 2 of these asv_codes are in all_records already
### MEL: NOTE I have kept my code for correcting the asv_seq problems, as it gives the same answer as your code, but provides a more transparent logic to the changes. CHRIS2: noted.
###       (So I have not used your correction code). The one difference between your result and mine is 
unique(mw46$max_p_identity[mw46$asv_code == "ed3ae084977ef615af77a2eee71a2c5b"]) 
###   My result says 99, but the notes in your code say "For asv_code 'ed3ae084977ef615af77a2eee71a2c5b' in 'mw46, the max_p_identity, species assignment (i.e., 92 match to  Hydrochus sp. MC-1) and asv_seq are all incorrect."   Did you mean to change it to 92?  I have left it as 99, but this can easily be changed. CHRIS: Yes. I did mean to change it. I re-checked the sequence against my private library, GenBank and bold, it did not match better than 92  # CW: CHECK THIS AT THE END

# dup_asv_seq_codes[dup_asv_seq_codes %in% all_records$asv_code]
# Those two are consistently called Hydrochus sp. MC-1 in both datasets
mw46$species[!is.na(mw46$species) & mw46$asv_code == "14295e7a8819dbdc4c2c972433d09d84"]
# [1] "Hydrochus sp. MC-1" "Hydrochus sp. MC-1" "Hydrochus sp. MC-1" "Hydrochus sp. MC-1"
# mw46$species[!is.na(mw46$species) & mw46$asv_code == "ed3ae084977ef615af77a2eee71a2c5b"]
# # [1] "Hydrochus sp. MC-1" "Hydrochus sp. MC-1"
# all_records$species[!is.na(all_records$species) & all_records$asv_code == "ed3ae084977ef615af77a2eee71a2c5b"]
# # [1] "Hydrochus sp. MC-1" "Hydrochus sp. MC-1"
all_records_ed3_seq <- unique(all_records$asv_seq[!is.na(all_records$species) & all_records$asv_code == "ed3ae084977ef615af77a2eee71a2c5b"])
# all_records$species[!is.na(all_records$species) & all_records$asv_code == "14295e7a8819dbdc4c2c972433d09d84"]
# all_records_ed3_seq == dup_seq | all_records_ed3_seq == other_seq  # FALSE
# [1] "Hydrochus sp. MC-1" "Hydrochus sp. MC-1" "Hydrochus sp. MC-1" "Hydrochus sp. MC-1" "Hydrochus sp. MC-1" "Hydrochus sp. MC-1"
all_records_142_seq <- unique(all_records$asv_seq[!is.na(all_records$species) & all_records$asv_code == "14295e7a8819dbdc4c2c972433d09d84"])
# all_records_142_seq == dup_seq | all_records_142_seq == other_seq  # FALSE
### So neither of these sequences match the duplicated sequence in MW46, so they can be used to correct the asv_seq for those two asv_codes
mw46$asv_seq[mw46$asv_code == "ed3ae084977ef615af77a2eee71a2c5b"] <- all_records_ed3_seq
mw46$asv_seq[mw46$asv_code == "14295e7a8819dbdc4c2c972433d09d84"] <- all_records_142_seq
# # But the other two are called 
# mw46$species[!is.na(mw46$species) & mw46$asv_code == "9fbe986c778c5556f99611d0075a122a"]
# # [1] "Hydrochus sp. B-AEH7112"
# mw46$species[!is.na(mw46$species) & mw46$asv_code == "7ca9195991a6cad87374d1e98c6ab624"]
# # [1] "Hydrochus sp. B-AEH7112" "Hydrochus sp. B-AEH7112" "Hydrochus sp. B-AEH7112" "Hydrochus sp. B-AEH7112"
### The names don't matter too much at this stage - they will be revised below
### The above corrections just leave two inconsistencies. 
### It seems most sensible to leave the remaining asv_code that is only associated with dup_seq as is,
### And associate all records of the asv_code associated with both dup_seq and other_seq with other_seq
mw46$asv_seq[mw46$asv_code == "7ca9195991a6cad87374d1e98c6ab624"] <- other_seq
asv_test <- unique(mw46[c("asv_code","asv_seq")])
sum(duplicated(asv_test$asv_seq))  # 0 - all good.

### Problem 2. asv_code b9ffeddb98f138f3aa3550b73a610dbb  has one record  incorrectly identified as Plecoptera sp. MC-O1 and one as kingdom Unassigned
mw46 <- mw46[!(mw46$kingdom == "Unassigned" & mw46$asv_code == "b9ffeddb98f138f3aa3550b73a610dbb"),]

# Remove records with phylum = "Unassigned" and with no matching record in BOLD
mw46 <- mw46[!(mw46$kingdom == "Unassigned" & !mw46$asv_code %in% unique(bold_results$asv_code)),]
# Update taxonomy for the 53 unassigned records that do have a bold match
unassigned_asvs <- unique(mw46$asv_code[mw46$kingdom == "Unassigned"])  #29 asv_codes
unassigned_asvs_bold_ambig_mw46 <- vector()
for(i in 1:length(unassigned_asvs)){
  boldi <- bold_results[bold_results$asv_code == unassigned_asvs[i],]
  if(max(boldi$similarity, na.rm = TRUE) >= 97){ 
     new_taxoni <- unique(boldi[boldi$similarity >= 97,
                               c("phylum","class","order","family","genus","species")])
    if(nrow(new_taxoni) > 1){ 
      unassigned_asvs_bold_ambig_mw46 <-  c(unassigned_asvs_bold_ambig_mw46,unassigned_asvs[i])
      }else{
    mw46[mw46$asv_code == unassigned_asvs[i],
                c("phylum","class","order","family","genus","species")] <- new_taxoni
      }
     }
  if(max(boldi$similarity, na.rm = TRUE) >= 95){ 
    new_taxoni <- unique(boldi[boldi$similarity >= 95,
                               c("phylum","class","order","family","genus")])
    if(nrow(new_taxoni) > 1){ 
      unassigned_asvs_bold_ambig_mw46 <-  c(unassigned_asvs_bold_ambig_mw46,unassigned_asvs[i])
      }else{
    mw46[mw46$asv_code == unassigned_asvs[i],
                c("phylum","class","order","family","genus")] <- new_taxoni
      }
  }
  if(max(boldi$similarity, na.rm = TRUE) < 95){
    new_taxoni <- unique(boldi[c("phylum","class","order","family")])
    if(nrow(new_taxoni) > 1){ 
      unassigned_asvs_bold_ambig_mw46 <-  c(unassigned_asvs_bold_ambig_mw46,unassigned_asvs[i])
      }else{
 mw46[mw46$asv_code == unassigned_asvs[i],
                c("phylum","class","order","family")] <- new_taxoni
      }
    }
}
# One ambiguous record remaining - one only identified to Porifera, the other to order Verongida
mw46 <- mw46[!(mw46$asv_code == "4a221f7f32a6c77153a67068011a848f" & is.na(mw46$class)),]

# Remove remaining unassigned records
mw46 <- mw46[!mw46$kingdom %in% c("Unassigned"),]
# Remove records with kingdom Prokaryota
mw46 <- mw46[!mw46$kingdom %in% c("Prokaryota"),]
mw46_sampledata <- mw46 # keep all sample data for checking purposes
mw46 <- unique(mw46[!mw46$asv_code %in% unique(all_records$asv_code),
                          c("asv_code","kingdom","phylum","class","order",
                            "family","genus","species","max_p_identity",
                            "asv_seq","amplicon")])

sum(duplicated(mw46$asv_code))  # 36. 
### Investigate remaining duplicates 
mw46_dups <- mw46[duplicated(mw46$asv_code) | duplicated(mw46$asv_code, fromLast = TRUE),]
### Differences in species names don't matter, as these will be checked below. Just choose
### the first one.  Entry with more taxonomic information is preferable
### Or cases of differing max_p_identity: set max_p_identity to maximum value and re-check
dup_asvs <- unique(mw46_dups$asv_code)
for(i in 1:length(dup_asvs)){
  dupi <- mw46_dups[mw46_dups$asv_code == dup_asvs[i],]
  ## get rid of any unassigned records and any duplicated non-macro/non-aquatics
  if(sum(!is.na(dupi$kingdom)) > 0 & sum(dupi$kingdom == "Unassigned") > 0){
  mw46 <- mw46[!(mw46$asv_code == dup_asvs[i] & mw46$kingdom == "Unassigned"),]
  next()
  }
  if(sum(!is.na(dupi$phylum)) > 0 & sum(dupi$phylum == "Magnoliophyta") > 0){
  mw46 <- mw46[!(mw46$asv_code == dup_asvs[i] & mw46$phylum == "Magnoliophyta"),]
  next()
  }
  # If is.na() taxonomic levels are different
  if(length(unique(apply(is.na(dupi[2:7]),1,sum))) > 1){
    mw46[mw46$asv_code == dup_asvs[i],2:7] <- dupi[which.min(apply(is.na(dupi[2:7]),1,sum)),2:7]
  }
  if(sum(is.na(dupi$max_p_identity)) > 0) stop("1")
  if(length(unique(dupi$max_p_identity)) > 1){
    mw46$max_p_identity[mw46$asv_code == dup_asvs[i]] <- max(dupi$max_p_identity)
  }
  if(sum(is.na(dupi$species)) > 0) stop("2")
  if(sum(grepl("Unident.", dupi$species)) == 1 & sum(dupi$species == "") == 1){
    mw46$species[mw46$asv_code == dup_asvs[i]] <- ""
  }
  if(length(unique(dupi$species)) > 1){
    mw46$species[mw46$asv_code == dup_asvs[i]] <- dupi$species[1]
  }
}
mw46 <- unique(mw46)
sum(duplicated(mw46$asv_code))  # 0.

### For assembly of library, just asv_code -specific information is required
all_records_sample_data <- all_records # keep all sample data for checking purposes
all_records <- unique(all_records[c("asv_code","kingdom","phylum","class","order",
                            "family","genus","species","max_p_identity",
                            "asv_seq","amplicon")])
### And add non-matching asv_codes from mw46 data 
all_records <- rbind(all_records, mw46)
all_records <- unique(all_records)  # 22,360

sum(duplicated(all_records$asv_code)) # 45
### Investigate remaining duplicates 
all_records_dups <- all_records[duplicated(all_records$asv_code) | duplicated(all_records$asv_code, fromLast = TRUE),]

### All either cases of differing max_p_identity or one identified to higher level
### set max_p_identity to maximum value and re-check and pick the higher level record
dup_asvs <- unique(all_records_dups$asv_code)
for(i in 1:length(dup_asvs)){
  dupi <- all_records_dups[all_records_dups$asv_code == dup_asvs[i],]
  if(sum(is.na(dupi$max_p_identity) > 0)) stop("1")
  if(length(unique(dupi$max_p_identity)) > 1){
    all_records$max_p_identity[all_records$asv_code == dup_asvs[i]] <- max(dupi$max_p_identity)
  }
    missing_taxa <- is.na(dupi[c("order","family","genus","species")])
    id_level <- apply(missing_taxa,1,sum)
    higher_id <- which(id_level == min(id_level))
    all_records[all_records$asv_code %in% dupi$asv_code,c("order","family","genus","species")] <- 
      dupi[higher_id,c("order","family","genus","species")]
}
### Remove duplicates and check again
all_records <- unique(all_records)
sum(duplicated(all_records$asv_code))  # 0.  Good

sum(asv_bold %in% all_records$asv_code)  #16127 asv_codes with a match to BOLD (similarity >=94) 

```

The truncated_fills_df and max_p_update_df are now complete with unique records from all source files (13,610 and 1,983 records respectively). To make corrections to taxonomic naming more efficient, the following combines the two tables for recompilation at the end of this document (using asv_codes to re-assemble the two tables).

Taxonomic corrections have been made only to aquatic macroinvertebrates, excluding non-aquatic, non-macroinvertebrate species using the function only_aqu_inverts() in bug_database_functions.R from the [mwbugs database website](https:://tools.thewerg.unimelb.edu.au/mwbugs/data_dl.html). In this document, the function reads from the table of exclusions (), which is a copy of the table of the same name in the mwbugs database.

Similarly to correct genus and family names in the library, we use the taxonomic tables from the mwbugs database.

```{r}

# # Build a private library table
## MEL note this inclusion of your checked spreadsheets is just a temporary measure while we finalise what the small 'private library' file should look like. This relies on unambiguous answers from you to my questions in the cross-check script. CHRIS: Got it
## The checked files are also used temporarily to add the non-aquatic tables at the end of the script.
tfill_ck <- read.csv("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library/arc_tfill_checked_all.csv")
maxp_ck <- read.csv("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library/arc_maxp_checked_all.csv")
mw46unmat_ck <- read.csv("~/uomShare/wergStaff/MelCarew/git-data/Spring_2018_DNA_metabarcoding_data/synonym_updates/MW46_metabar_unmatched_checked_all.csv")
arc_unmat_ck  <- read.csv("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library/arc_unmatched_checked.csv")
# 
# CW Leave this uncommented out for the moment while still checking
all_MC_checks <- rbind(tfill_ck, maxp_ck, mw46unmat_ck, arc_unmat_ck)
# Remove duplicates and unnecessary fields
all_MC_checks <- unique(all_MC_checks[c("asv_code","checked_species_name", "bold_match","bold_bin_uri","action","comments")])
dups <- all_MC_checks[duplicated(all_MC_checks$asv_code) | duplicated(all_MC_checks$asv_code, fromLast = TRUE),]
#  174 duplicated asv_codes with different actions/comments: get rid of some as follows
# Need to work around this somehow....for now just delete all duplicates (at the risk of losing some important actions/comments)
# important actions seem to come second, so
all_MC_checks <- all_MC_checks[!duplicated(all_MC_checks$asv_code, fromLast = TRUE),]
# private_lib <- all_MC_checks[grep("private|genbank", tolower(all_MC_checks$comments)),]
# private_lib <- private_lib[!private_lib$asv_code %in% unique(bold_results$asv_code),]
# write.csv(private_lib, "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files//private_library.csv", row.names = FALSE)
private_lib <- read.csv("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files//private_library.csv")

tfill_all <- rbind(truncated_fills_df, max_p_update_df)    # 15595 records

# Put aside all Proteobacteria records (erroneous attributions of arthropods in public databases),
# To be added to tfill at the end of the script
bact_records <- all_MC_checks$asv_code[all_MC_checks$checked_species_name == "Proteobacteria" | 
                                all_MC_checks$comments == "Proteobacteria"]
names(all_records)[names(all_records) == "asv_seq"] <- "asv_sequence"
bact_records <- rbind(tfill_all[tfill_all$asv_code %in% bact_records,],
                      all_records[all_records$asv_code %in% bact_records,])
bact_records$kingdom <- "Prokaryota"
bact_records$phylum <- "Proteobacteria"
bact_records$class <- bact_records$order <- bact_records$family <- 
   bact_records$genus <- bact_records$species <- NA
other_bact_records <- unique(rbind(tfill_all[tfill_all$kingdom == "Prokaryota",],
                             all_records[all_records$kingdom == "Prokaryota",]))
bact_records <- unique(rbind(other_bact_records, bact_records[!bact_records$asv_code %in% 
                                                         other_bact_records$asv_code,]))
# 1 duplicate with differeing max_p_identity
bact_records <- bact_records[!duplicated(bact_records$asv_code, fromLast = TRUE),]
tfill_all <- tfill_all[!tfill_all$asv_code %in% bact_records$asv_code,]  #15,532
all_records <- all_records[!all_records$asv_code %in% bact_records$asv_code,] #22,280

# A classification error to correct
tfill_all[tfill_all$asv_code == "5148a3678b70de5db884a99af7734de4",c("order","family","genus")] <- c("Sarcoptiformes",NA,NA)

# Remove all species names with "Unident." (A remnant of earlier inappropriate application of a mwbugs databse convention to these data)
tfill_all$species[grepl("Unident.", tfill_all$species)] <- NA

source("https://tools.thewerg.unimelb.edu.au/data/mwbugs/bug_database_functions.R")

# Record of how non_aqu_macroinvert.csv was created
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# non_aqu_macro_invert <- DBI::dbReadTable(db, "non_aqu_macro_invert")
# write.csv(non_aqu_macro_invert,
#           "~/git/metabarcoding_workflow/data/non_aqu_macro_invert.csv",
#           row.names = FALSE)

# Record of how taxonomy.xlsx was created, noting that when complete this can be read 
# directly from the mwbugs downloads page (not yet updated)
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# taxon_gen <- DBI::dbReadTable(db, "taxon_gen")
# taxon_fam <- DBI::dbReadTable(db, "taxon_fam")
# WriteXLS::WriteXLS(list(taxon_gen = taxon_gen, taxon_fam = taxon_fam),
#           "~/git/metabarcoding_workflow/data/taxonomy.xlsx")
non_aqu_macro_invert <- read.csv("data/non_aqu_macro_invert.csv")
taxon_gen <- as.data.frame(readxl::read_excel("data/taxonomy.xlsx", 
                                              sheet = "taxon_gen"))
# Correction now made in database
taxon_gen$genus[taxon_gen$genus == "Megogota"] <- "Megogata"
taxon_fam <- as.data.frame(readxl::read_excel("data/taxonomy.xlsx", 
                                              sheet = "taxon_fam"))
# Corrections to be made in database (and synonym added)
taxon_fam$family[taxon_fam$family == "Pisidiidae"] <- "Sphaeriidae"

tfill <- only_aqu_inverts(tfill_all, 
                          non_aqu_macro_invert_already_loaded = TRUE)$include #11,858 records
# Keep excluded records aside for recompilation below
tfill_nonaq <- only_aqu_inverts(tfill_all, 
                          non_aqu_macro_invert_already_loaded = TRUE)$exclude #3,670 records
# And exclude records identified to phylum (1 Nemertea has a bold match, but not necessarily aquatic)
tfill_nonaq <- rbind(tfill_nonaq, tfill[is.na(tfill$class) & is.na(tfill$species),]) #3,683
tfill <- tfill[!(is.na(tfill$class) & is.na(tfill$species)),] #11,845

asvs_bin_uri <- unique(bold_results$asv_code[bold_results$similarity >= 97])  #20,070
asvs_bin_uri_lt97 <- unique(bold_results$asv_code[!bold_results$asv_code %in% asvs_bin_uri])  #1,415 
all_records_aq <- only_aqu_inverts(all_records, 
                          non_aqu_macro_invert_already_loaded = TRUE)$include #18,813 records
names(all_records_aq)[names(all_records_aq) == "asv_seq"] <- "asv_sequence"
all_records_non_aq <- only_aqu_inverts(all_records, 
                          non_aqu_macro_invert_already_loaded = TRUE)$exclude #3,467 records
all_records_aq_not_in_tfill <- all_records_aq[!all_records_aq$asv_code %in% tfill$asv_code,] #11,623
all_records_aq_not_in_tfill_bin <- all_records_aq_not_in_tfill[all_records_aq_not_in_tfill$asv_code %in% asvs_bin_uri,] #7,272
all_records_aq_not_in_tfill_binlt97 <- all_records_aq_not_in_tfill[all_records_aq_not_in_tfill$asv_code %in% asvs_bin_uri_lt97,] #768
all_records_aq_only_in_private_lib <- all_records_aq_not_in_tfill[all_records_aq_not_in_tfill$asv_code %in% private_lib$asv_code,] #522
### Records with matches <97 are added to the ASV library and dealt with below 

# Add records with BOLD matches to tfill
tfill <- rbind(tfill, all_records_aq_not_in_tfill_bin,
               all_records_aq_not_in_tfill_binlt97, 
               all_records_aq_only_in_private_lib)  #20,407
#   Check species that had been excluded at this stage.  Only one
excl_spp <- unique(tf2$species[!tf2$asv_code %in% tfill$asv_code])
#         "Cernosvitoviella minor" a likely terrestrrial Enchytraeid.
```

Below, we change the term 'complex' in the asv_library to 'group' to remove any implication of true taxonomic complexes in the grouping of species. We also correct spelling errors in the source data.

```{r}
# Keep a record of the original species name for checking later on.
tfill$species_old <- tfill$species

# Now, Unident. records can be removed later on, but they are helpful to avoid NA problems in the following,
# So for now, replace all NA species with an Unident. name
tfill$species[is.na(tfill$species) & !is.na(tfill$genus)] <- 
  paste0(tfill$genus[is.na(tfill$species) & !is.na(tfill$genus)], " sp. (Unident.)")
tfill$species[is.na(tfill$species) & !is.na(tfill$family)] <- 
  paste0(tfill$family[is.na(tfill$species) & !is.na(tfill$family)], " sp. (Unident.)")
tfill$species[is.na(tfill$species) & !is.na(tfill$order)] <- 
  paste0(tfill$order[is.na(tfill$species) & !is.na(tfill$order)], " sp. (Unident.)")
tfill$species[is.na(tfill$species) & !is.na(tfill$class)] <- 
  paste0(tfill$class[is.na(tfill$species) & !is.na(tfill$class)], " sp. (Unident.)")
# # The remaining 15 only identified to Arthropoda or Nemertea
tfill_phylum_only_excl <- tfill[(is.na(tfill$species) & is.na(tfill$class)),]
# sum(tfill$asv_code[is.na(tfill$species)] %in% bold_results$asv_code) 
# # and none of them have bold matches, so remove them.
tfill_nonaq <- rbind(tfill_nonaq, 
                     tfill[tfill$asv_code %in% tfill_phylum_only_excl$asv_code,
                           match(names(tfill_nonaq),names(tfill))]) #3,695
tfill <- tfill[!tfill$asv_code %in% tfill_phylum_only_excl$asv_code,] #20,399

# Correct spelling errors
tfill$species <- gsub("  ", " ", tfill$species)
tfill$species <- gsub("Cricptopus", "Cricotopus", tfill$species)
tfill$species <- gsub("sp.B", "sp. B", tfill$species)
tfill$species <- gsub("GB-", "G-", tfill$species)
tfill$species <- gsub("ZB-", "", tfill$species)
tfill$species <- gsub("complex", "group", tfill$species)
tfill$species <- gsub("Iilliesoperla","Illiesoperla",tfill$species)
tfill$species <- gsub("ParaLimnophila","Paralimnophila",tfill$species)
tfill$species <- gsub("Physa ", "Physella ", tfill$species)

tfill$genus[grep("Physa", tfill$genus)] <- "Physella"
tfill$species[!is.na(tfill$species) & tfill$species == "Pristina osborni sp. (Unident.)"] <- "Pristina osborni"
tfill$species[!is.na(tfill$species) & tfill$species == "Illiesoperla mayi sp. (Unident.)"] <- "Illiesoperla mayi"
tfill$species[!is.na(tfill$species) & tfill$species == "Hydra vulgaris (sp. Unident.)"] <- "Hydra vulgaris"
tfill$species[!is.na(tfill$species) & tfill$species == "Coloburiscoides giganteus sp. (Unident.)"] <- "Coloburiscoides giganteus"
tfill$species[grep("Asmicridea edwardsi", tfill$species)] <- "Asmicridea edwardsii"
tfill$species[!is.na(tfill$species) & tfill$species == "Craspedacusta sowerbyi"] <- "Craspedacusta sowerbii"
tfill$species[!is.na(tfill$species) & tfill$species == "Chironomidae sp. B-ABX4803"] <- "Chironominae sp. B-ABX4803"
tfill$species[!is.na(tfill$species) & tfill$species == "Chironomidae sp. B-AEE9278"] <- "Orthocladiinae sp. B-AEE9278"
tfill$species[!is.na(tfill$species) & tfill$species == "Dero obtusa"] <- "Dero obtusa/nivea"
tfill$species[!is.na(tfill$species) & tfill$species == "Limnodrilus claparedeanus"] <- "Limnodrilus claparedianus"
tfill$species[!is.na(tfill$species) & tfill$species == "Antiporus gilbertii"] <- "Antiporus gilberti"
tfill$species[!is.na(tfill$species) & tfill$species == "Austrolimnius waterhouseii"] <- "Austrolimnius waterhousei"
tfill$species[!is.na(tfill$species) & tfill$species == "Culicoides bundyensi"] <- "Culicoides bundyensis"
tfill$species[!is.na(tfill$species) & tfill$species == "Hyderodes shuckardi"] <- "Hyderodes schuckardi"
tfill$species[!is.na(tfill$species) & tfill$species == "SImsonia longipes"] <- "Simsonia longipes"
tfill$species[!is.na(tfill$species) & tfill$species == "Musculium sp. B-ADJ8477"] <- "Sphaerium sp. B-ADJ8477"
tfill$species[!is.na(tfill$species) & tfill$species == "Dinotoperla aff. thwaitesi"] <- "Dinotoperla thwaitesi group"
tfill$species[!is.na(tfill$species) & tfill$species == "Austropyrgus centralia group"] <- "Austropyrgus centralia/turbatus"
tfill$species[!is.na(tfill$species) & tfill$species == "Centroptilum sp. B-ACM3150"] <- "Centroptilum elongatum"
tfill$species[!is.na(tfill$species) & tfill$species == "Hydraenidae sp. B-ADK5039"] <- "Gymnochthebius australis"
tfill$species[!is.na(tfill$species) & tfill$species == "Helicophida queenslandensis"] <- "Helicopha queenslandensis"
tfill$species[!is.na(tfill$species) & tfill$species == "Riethia zeylandica"] <- "Riethia sp. B-ADU5431" 
tfill$species[!is.na(tfill$species) & tfill$species == "Notalina bifara group B-ABV8023"] <- "Notalina bifara group"
tfill$species[!is.na(tfill$species) & tfill$species == "Notalina sp. B-AAX5636"] <- "Notalina bifara group"
```

The following chunk creates a new table of asv_codes, species names, and their bin_uris. Many asv_codes have multiple bin_uris, so this table is longer than tfill. (22,872 rows rather than 20,399). Many species names are incorrect at this stage, but are corrected below using the bold_results

```{r}
# NOTE: the user needs to un this commented out code to save your own copy of
# match_list_bin_uri_v5.rda (it take a minute or two to compile)
## Convert bold_results to a list: one element per asv_code
# create a list of asv_codes with matching bold data  (and save as it takes a few minutes to compile)
# asv_codes_with_bins <- unique(bold_results$asv_code)
# asv_codes_with_bins <- asv_codes_with_bins[asv_codes_with_bins %in% tfill$asv_code]
# match_list_bin_uri <- list()
# for(i in 1:length(asv_codes_with_bins)){
#         matchi <- bold_results[bold_results$asv_code == asv_codes_with_bins[i],
#                                !names(bold_results) %in% c("asv_code","pid_bin")]
#         matchi <- matchi[!is.na(matchi$bin_uri),]
#         # if there is at least one registered bin_uri remove temp id records
#         if(nrow(matchi) == 0) stop("1")
#         if(nrow(matchi) > 0){
#           if(sum(nchar(matchi$bin_uri) == 7) > 0){
#             matchi <- matchi[nchar(matchi$bin_uri) == 7,]
#           }
#         }
#   match_list_bin_uri <- c(match_list_bin_uri, list(matchi))
#   names(match_list_bin_uri)[length(match_list_bin_uri)] <- asv_codes_with_bins[i]
# }
# save(match_list_bin_uri, file = "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files/match_list_bin_uri_v5.rda")
# Move this to osf.
load("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files/match_list_bin_uri_v5.rda")

# Create a tfill_spp_bins, which lists all bin_uris associated with each asv_code
# First calculate how many bin_uris each asv_code matches with similarity>=97
tfill$n_bold_matches <- 0
for(i in 1:nrow(tfill)){
  if(tfill$asv_code[i] %in% names(match_list_bin_uri)){
    matchi <- match_list_bin_uri[[tfill$asv_code[i]]]
    matchi_97 <- matchi[matchi$similarity >= 97,]
    if(nrow(matchi_97) > 0)
    tfill$n_bold_matches[i] <- length(unique(matchi_97$bin_uri))
  }}

tfill_spp_bins <- data.frame(tfill[tfill$n_bold_matches > 0, c("asv_code","species")],
                             bin_uri = NA)
add_bins <- tfill_spp_bins[0,]
for(i in 1:nrow(tfill_spp_bins)){
    matchi <- match_list_bin_uri[[tfill_spp_bins$asv_code[i]]]
    bins <- matchi$bin_uri[matchi$similarity >= 97]
    bins <- unique(bins[!is.na(bins) & !bins == ""])
  if(length(unique(bins)) == 0){
     stop("1")
    }else{
    tfill_spp_bins$bin_uri[i] <- unique(bins)[1]
    if(length(unique(bins)) > 1){
      add_bins <- rbind(add_bins, 
                              data.frame(asv_code = tfill_spp_bins$asv_code[i],
                              species = tfill$species[tfill$asv_code == tfill_spp_bins$asv_code[i]],      
                              bin_uri =bins[-1]))
    }
    }
}
tfill_spp_bins <- rbind(tfill_spp_bins, add_bins)
tfill_spp_bins <- tfill_spp_bins[order(tfill_spp_bins$species),]

tfill_spp_bins_bu <- tfill_spp_bins
```

Species without a formal name are given a name based on their BOLD identifiers (bin_uri).  Species that have 2 or more bin_uris are given the name of one of the (arbitrary) first bin_uri followed by "group".  The following chunks renders those names. 

The first chunk ensures that the first word of the name (usually genus, but potentially a higher taxonomic level) are correct, first by making manual corrections using the BOLD database and taxonomic identifications of specimens.

```{r}
tfill_bu <- tfill
tfill_spp_bins_bu <- tfill_spp_bins
# tfill <- tfill_bu
# tfill_spp_bins <- tfill_spp_bins_bu

tfill$species_old <- tfill$species

### The following corrections were made iteratively (creating and inspecting 
### tfill_spp_bins below), with the ultimate aim of each asv_code having a 
### single species name (or taxonomic identity if not ided to species) and each 
### bin_uri having a single species (although some species names can be associated 
### with multiple bin_uris)

# Some records named Sphaerium not correct (Set species to "" for those without a bold match)
for(i in grep("Sphaerium", tfill$species)){
  if(sum(match_list_bin_uri[[tfill$asv_code[i]]]$similarity >= 97) == 0){
    tfill$genus[i] <- NA
    tfill$species[i] <- "Sphaeriidae sp. (Unident.)"
  }else{
    bini <- match_list_bin_uri[[tfill$asv_code[i]]]
    if("ADJ8477" %in% bini$bin_uri[bini$similarity >=97])
      tfill$species[i] <- "Sphaerium sp. B-ADJ8477"
  }}

# And many other Sphaeriinae bin_uris overlap with bold variously calling them Pisidium.
# They all overlap with records called "Pisidium sp. cf. hallae" also
# Change all to Sphaeriinae (same B- name for now)
tfill$species[tfill$species == "Pisidium sp. cf. hallae"] <- "Sphaeriinae sp. MC_temp"  #To permit allocation of bin_uris below
tfill$species <- gsub("Pisidium","Sphaeriinae", tfill$species)

# An unidentified naididae previously classed as Limnodrilus hoffmeisteri should be Naididae sp. B-ADJ9699
naid_asvs <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "ADJ9699"]
tfill$genus[tfill$asv_code %in% naid_asvs] <- NA

# An Enchytraeid that had been incorrectly listed in the table as a Dytiscid (100% match to BOLD-AAG4407 using both BOLD methods)
tfill[tfill$asv_code == "9cb0fd3c74a7d78345ce9dab0d7f1a87", c("class","order","family","species")] <- 
                       c("Clitellata", "Enchytraeida", "Enchytraeidae","Enchytraeidae sp. B-AAG4407")

# CW: check this!
# # Sphaeromatid given too-conservative names
# tfill$species[grepl("Isopoda", tfill$species) & !is.na(tfill$family ) & tfill$family == "Sphaeromatidae"] <- 
#     gsub("Isopoda","Sphaeromatidae",
#         tfill$species[grepl("Isopoda", tfill$species) & !is.na(tfill$family ) & tfill$family == "Sphaeromatidae"])

# ambiguous ids that are unlikely to be freshwater macroinvertebrates
ambig_ids <- c("Talitridae sp. (Unident.)","Hemiptera sp. (Unident.)","Cephalopoda sp. (Unident.)",
  "Insecta sp. (Unident.)","Malacostraca sp. (Unident.)", "Coleoptera sp. (Unident.)")
tfill_non_aq <- rbind(tfill_nonaq, tfill[tfill$species %in% ambig_ids,
                          match(names(tfill_nonaq), names(tfill))])
tfill <- tfill[!tfill$species %in% ambig_ids,] #20,399

n_bins <- aggregate(tfill_spp_bins[tfill_spp_bins$asv_code %in% tfill$asv_code,]$bin_uri, 
      by = list(asv_code = tfill_spp_bins[tfill_spp_bins$asv_code %in% tfill$asv_code,]$asv_code), 
                    FUN = length)
tfill$no_bin_match <- 0
tfill$no_bin_match[match(n_bins$asv_code, tfill$asv_code)] <- n_bins$x

#The following are changes in part from Mel's original Appendix 2 asv_code chunk changing species names, and in part from iterative checks of tfill_spp_bins. NOTE: grouping of similar bin_uris is done later in the script. This step gives a single name per bin_uri, ensuring that similar bin_uris are given the same genus name
bold_name_corrections <- 
c("AAE9243" = "Cheumatopsyche alampeta",
"ACG2503" = "Coloburiscoides munionga",
"ABX3893" = "Illiesoperla mayi",	
"ACG1875" = "Rhadinosticta simplex",
"ADJ8523" = "Limnodrilus hoffmeisteri",
"AEI0789" = "Procorticacarus victorianus",
"ABV8829" = "Ulmerochorema onychion",
"AAU4648" = "Psychoda gemina",
"ACV9482" = "Cricotopus tasmania",
"AAF0821" = "Tanytarsus fuscithorax",
"ACB6471" = "Chaetogaster diastrophus",
"AAW2994" = "Austrheithrus glymma",
"ACD5693" = "Dinotoperla thwaitesi",
"ABX4166" = "Dinotoperla walkeri/evansi",
"ABV8830" = "Ulmerophlebia sp. B-ABV8830", # included here because genus was wrong in library
"AAW4309" = "Cardiocladius sp. B-AAW4309", # included here because genus was wrong in library
"ADJ0699" = "Byrrocryptus sp. B-ADJ0699", # late genus-level id
"ACV9616" = "Bothrioneurum vejdovskyanum", # overlapping bin_uris
"AAX5275" = "Bothrioneurum vejdovskyanum",
"ACI5239" = "Bothrioneurum vejdovskyanum",
"ACB6594" = "Bothrioneurum vejdovskyanum",
"ABV0255" = "Limnophyes sp. B-ABV0255", # one record incorrectly called "Echinocladius martini"
"ABX0996" = "Atrichopogon sp. B-ABX0996", # 6 bold record call this Atrichopogon (some tfill records took it to family)
"ABX1092" = "Limnophila sp. B-ABX1092", # Bold identifies this as Limnophila (not Ozeoura convoluta as in some tfill records)
"ACG2297" = "Notriolus sp. B-ACG2297", # Bold identifies this as Notriolus (some tfill entries took it to family)
"ACN2323" = "Orthotrichia sp. B-c", # Bold identifies this as Orthotrichia (some tfill entries had it as Hellyethira basilobata)
"ADJ9699" = "Naididae sp. B-ADJ9699", # Bold identifies this only as Naididae (some tfill entries had it as Limnodrilus hoffmeisteri)
"AEV0976" = "Simuliidae sp. B-AEV0976", # Bold identifies this to Simuliidae. 
"ABX3905" = "Trinotoperla sp. B-ABX3905", # BOLD has no consensus on which Trinotoperla species this is. Some tfill entries had it as Trinotoperla montana. Will be named as a B- group below
"AAT9499" = "Chamaedrilus varisetosus",
"AAT9501" = "Chamaedrilus varisetosus",
"ACQ1237" = "Chamaedrilus varisetosus",
"AAU1095" = "Chamaedrilus varisetosus", # All 4 called Cognettia varisetosa in some cases both in tfill and in bold. 
"AAT8936" = "Cognettia chlorophila/sphagnetorum",# called Cognettia chlorophila and Cognettia sphagnetorum in BOLD. 2 records incorrectly called it "Chamaedrilus varisetosus" in tfill
"ADW4709" = "Baetidae sp. B-ADW4709", # only identified to Baetidae in BOLD (some tfill entries had it as Offadens)  
"AEO9040" = "Diptera sp. B-AEO9040", # Recorded in some past scripts as Aphroteniinae, but BOLD only identifies it to Diptera
"AAD2412" = "Asmicridea sp. B-AAD2412", # BOLD has one record calling this Asmicridea edwardsii, but many only to genus
"ABV8740" = "Asmicridea sp. B-ABV8740",
"ACG0009" = "Asmicridea sp. B-ACG0009", # BOLD Asmicridea; tfill Asmicridea edwardsii or Asmicridea sp. B-ABV8740 Asmicridea sp. B-AAD2412
"AGO0445" = "Austroargiolestes sp. B-AGO4455", # BOLD has no consensus on which Austroargiolestes species this is
"ACL1905" = "Austroargiolestes sp. B-ACL1905",  # BOLD has no consensus on which Austroargiolestes species this is
"ACL1904" = "Austroargiolestes sp. B-ACL1904", # BOLD has no consensus on which Austroargiolestes species this is
"ACG0290" = "Austroargiolestes sp. B-ACG0290", # BOLD has no consensus on which Austroargiolestes species this is
"AAW3080" = "Austropsyche sp. B-AAW3080", # BOLD identifies this as "Austropsyche CJG sp. AU1". one tfill record has it as Austropsyche sp.
"AAW3122" = "Austropyrgus centralia/turbatus", #centralia and turbatus grouped below. One tfill record had this incorrectly as Austropyrgus angasi
"ABX5220" = "Austrosimulium furiosum", # BOLD id;  tfill had one incorrectly identifed as Austrosimulium sp. B-AEH7071
"AGK3234" = "Anthocara anthophilia", # BOLD id only to family, tfill variously identified this as Pseudomicrocara anthophilia or Anthocara anthophilia. GenBank have corrected the id to the latter. 
"ADC3729" = "Telephlebia brevicauda/godeffroyi", # BOLD has no consensus on which Telephlebia species it is. tfill had it as both
"AAB3146" = "Anopheles annulipes", # BOLD id
"ADW7166" = "Blepharhymenus apicornis", # BOLD id
"ACM3453" =  "Cloeon sp. B-ACM3453", # BOLD identifies this as both Centroptilum and Cloeon 
"ADT1789" =  "Schizonyxhelea sp. B-ADT1789", # tfill variously Ceratopogonidae sp. MC-25,Schizonyxhelea sp. B-ABX1780, Schizonyxhelea sp. B-AFV6727, BOLD Ceratopogonidae (but overlaps with the following 5) 
"AGO4766" = "Schizonyxhelea sp. B-AGO4766", # ditto
"AGO4767" = "Schizonyxhelea sp. B-AGO4767", # ditto
"AFV6727" = "Schizonyxhelea sp. B-AFV6727", # ditto
"ABX1780" = "Schizonyxhelea sp. B-ABX1780", # ditto
"AGO4768" = "Schizonyxhelea sp. B-AGO4768", # ditto
"AFS8198" = "Chaetogaster sp. B-AFS8198", # BOLD id 
"ACQ6787" = "Cricotopus sp. B-ACQ6787", # BOLD  id only to genus
"ABA7845" = "Chironomidae sp. B-ABA7845", # BOLD has this only to Chironomidae tfill either Chironomidae or Tanytarsus. More conservative ID used.
"ADC3509" = "Chironomidae sp. B-ADC3509", # BOLD id: tfill variously this or Diptera unident or Diptera MC-032
"AED8094" = "Tanytarsini sp. B-AED8094", # BOLD has this only to Chironomidae: Mel Carew matched an unpublished specimen (BR17Chir1) that matched AED8094 on bold to Tanytarsini.
"AAZ8055" = "Matasia sp. B-AAZ8055",  # formerly Matasia sp. AV1
"ABV8714" = "Aphilorheithrus sp. B-ABV8714", #BOLD only ids to genus
"AEW1288" = "Pristina sp. B-AEW1288", # BOLD calls this Pristina CEE
"AEW1092" = "Monopylephorus irroratus", # BOLD id
"AAO8233" = "Coenagrionidae sp. B-AAO8233", # BOLD only to family. Some tfill records said Ischnura heterosticta
"ACN2272" = "Notriolus quadriplagiatus", #BOLD id, but  tfill says Notriolus sp. B-ADV4730. The ID on BOLD by James Anderson is credible.
"AGN0208" = "Nothocyphon serratipenis", # BOLD ids this as Contacyphon, but the GenBank ID as Nothocyphon serratipenis by Chris Watts is credible.
"AEK9922" = "Coronapelopia valedon", # BOLD id, tfill either that or "Yarrhpelopia norrisi"
"ACM3391" = "Molophilus exsertus", # BOLD id. tfill that or unidentified
"ABW4945" = "Molophilus neboissi", # BOLD id. tfill unidentified
"ABX1091" = "Limnophila sp. B-ABX1091", # BOLD id, tfill that or unidentified or Limnophila sp. MC-1
"ABA7040" = "Molophilus sp. B-ABA7040", # BOLD id, tfill that or unidentified
"ABX1094" = "Limnophila sp. B-ABX1094", # BOLD id, tfill that or unidentified or Limnophila sp. MC-1
"AAW0925" = "Nothorhaphium aemulans", # BOLD id, tfill that or Dolichopodidae sp. B-AAW0925
"AGL9353" = "Enochrus sp. B-AGL9353", # BOLD id, tfill either Enochrus sp. MC-5 or Hydrophilidae sp. MC-5
"AEU6610" = "Tubifex tubifex", # BOLD id, tfill either that or unidentified
"ADZ9729" = "Hyalinella punctata", # BOLD id, tfill either that or Plumatella reticulata
"ACG3222" = "Isopoda sp. B-ACG3222",  # BOLD has this only to Isopoda tfill either Isopoda or Sphaeromatidae. Conservative ID selected
"ABW1138" = "Leptoceridae sp. B-ABW1138", # BOLD has this only to Leptoceridae tfill either Leptoceridae or Triaenodes. Conservative ID selected
"AGD4258" = "Mesolimnophila austroalpina", # BOLD id, tfill that or Limnophila sp. EPAsp13
"AGD4254" = "Mesolimnophila obscuripennis", # BOLD id, tfill either Limnophila sp. EPAsp13 or Mesolimnophila austroalpina. 
"ABW2416" = "Limnophilinae sp. B-ABW2416", # BOLD id, tfill either that or Limoniidae sp. MC-1.
"ABX1292" = "Limnophilinae sp. B-ABX1292", # BOLD id, tfill either that or Limoniidae sp. MC-2.
"ABX1111" = "Molophilus pulchripes", # BOLD id, tfill either that or unidentified Limoniidae
"ABA3795" = "Molophilus sp. B-AEW5624", # BOLD id only to genus, but this overlaps with ABX1111
"AEW5624" = "Paranais botniensis", # BOLD id, tfill either that or unident. naid
"AAN7517" = "Naididae sp. B-AAN7517", # BOLD id to family, but uncertain genus. tfill either that or Tubifex tubifex
"ACF9345" = "Orthocladiinae sp. B-ACF9345", # BOLD id only to subfamily Orthocladiinae, tfill either Pseudosmittia or Orthocladiinae. Conservative ID used
"ACW4137" = "Pionidae sp. B-ACW4137", # BOLD id only to family. tfill either that or Piona sp. B-ACW4137 Conservative ID used
"AAY5550" = "Lingora sp. B-AAY5550", # BOLD identifies this as Lingora aurata; tfill identifies it as Lingora aurata, Lingora sp. B-AAY5550/ADF2103 Lingora sp. B-ACC8619
"ABY8640" = "Lingora aurata", # BOLD id - this bin_uri overlaps with "AAY5550"
"AAY5549" = "Lingora sp. B-AAY5549", # BOLD identifies this as Lingora spAV1 (also overlaps with AAY5550); tfill identifies it as Lingora aurata, Lingora sp. B-AAY5550/ADF2103, Lingora sp. B-ACC8619
"ACC8619" = "Lingora sp. B-ACC8619", # BOLD id only to Conoesucidae, but overlaps with AAY5550
"ACS4478" = "Cryptochironomus sp. B-ACS4478", # BOLD id only to genus  # the bin_uris all overlap
"ACS3865" = "Cryptochironomus sp. B-ACS3865", # BOLD id only to genus
"ACS5094" = "Cryptochironomus sp. B-ACS5094", # BOLD id only to genus
"ACS3851" = "Cryptochironomus sp. B-ACS3851", # BOLD id only to genus
"ABX1153" = "Ozeoura sp. B-ABX1153", # BOLD id only to genus tfill Ozeoura tonnoiri and Ozeoura sp. T21048
"ABY3364" = "Ozeoura sp. B-ABY3364",# BOLD id only to genus tfill Ozeoura sp. (Unident.) and Ozeoura tonnoiri
"AGB3428" = "Ozeoura tonnoiri",# BOLD id, tfill Ozeoura sp. T21048 and Ozeoura tonnoiri
"ACM3256" = "Ozeoura tonnoiri",# BOLD id and tfill id
"ACI1082" = "Austrochiltonia australis", # OLD id, tfill that and Austrochiltonia sp. MC-1
"ACQ4376" = "Hydra vulgaris", # BOLD id, tfill that and Hydra sp. MC-O1
"AEU9413" = "Chaetogaster limnaei", # BOLD id Chaetogaster limnaei CEB, tfill Chaetogaster limnaei and Chaetogaster diaphanus
"AEX7218" = "Chaetogaster limnaei", # BOLD id Chaetogaster limnaei CEA, tfill Chaetogaster limnaei and Chaetogaster diaphanus
"ADR9727" = "Chostonectes gigas", # OLD id, tfill that and Chostonectes johnsonii (one BIN ADR9726)
"ADR5837" = "Chostonectes gigas", # BOLD id, tfill both Chostonectes johnsonii and Chostonectes gigas, johnsonii is wrong
"ACB6731" = "Pristina aequiseta", # BOLD id, tfill only identified to that and "Pristina aequiseta/foreli" 
"AFH3276" = "Culicoides sigmoidus", # BOLD id, tfill Culicoides sp. MC-24
"AFN1635" = "Culicoides sigmoidus", # BOLD id, tfill Culicoides sp. MC-24
"ADF0531" =  "Tonnoiromyia tasmaniensis", # BOLD id, tfill Tonnoiromyia sp. EPAsp3 and Tonnoiromyia tasmaniensis
"AGD4701" =  "Tonnoiromyia sp. B-AGD4701", # BOLD id only to family, but overlaps with ADF0531, tfill Tonnoiromyia sp. EPAsp3 and Tonnoiromyia tasmaniensis 
"AGD4720" = "Limnophilinae sp. B-AGD4720", # BOLD id to subfamily, tfill  Diptera sp. MC-O27 and Diptera sp. (Unident.)
"ADA8919" = "Ceratopogonidae sp. B-ADA8919", # BOLD id to family, tfill identified as Diptera sp. MC-O27
"ADF0137" = "Limnophila sp. B-ADF0137",# BOLD id to order, tfill Limnophila sp. EPAsp30 and Limoniidae sp. B-ADF0137. Limnophila IDed by Zac Billingham
"AGD4740" = "Limnophila implicita", # BOLD id, tfill that and Limnophila sp. EPAsp30
"AGL9709" = "Dixella sp. B-AGL9709", # BOLD id to genus, tfill as Diptera sp. MC-O14 and Diptera sp. (Unident.)
"AGQ8909" = "Chironomidae sp. B-AGQ8909", # BOLD id to family, tfill as Diptera sp. MC-O10 and Diptera sp. (Unident.)
"ABW5528" = "Limnophyes sp. B-ABW5528", # BOLD id to genus, tfill as Limnophyes sp. MC-A1
"AAJ0256" = "Spongillidae sp. B-AAJ0256", # BOLD has multiple genus and family ids (Lubomirskiidae, Malawispongiidae, Spongillidae), tfill has it as Spongillidae sp. B-AAJ0256, which is probably as good a name as any!
"AGN3459" = "Ceratopogonidae sp. B-AGN3459", # BOLD Ceratopogonidae (but overlaps with ADR7325, next), tfill either Ceratopogonidae sp. MC-3 or Ceratopogonidae sp. MC-26
"ADR7325" = "Ceratopogonidae sp. B-ADR7325",  # BOLD Ceratopogoninae, tfill either Ceratopogonidae sp. MC-3 or Ceratopogonidae sp. MC-26
"AGL9707" = "Dixella humeralis", # BOLD either Dixidae or Dixella but Dixella humeralis id by Chris Hardy has been confirmed.
"AGL9705" = "Dixella sp. B-AGL9705", # BOLD Dixidae, but it overlaps with AGL9707, tfill either Dixidae sp. MC-2 or Dixidae sp. MC-4 
"AGN3107" = "Dytiscidae sp. B-AGN3107", # BOLD Chostonectes, but see next, tfill Platynectes sp. MC-6 CHRIS: This is my specimen (KWG17Dyt2) identified to genus as Chostonectes. Please use Chostonectes  # MEL: I have to insist on using the family name (or alternatively you need to decide which species "AGN3107" and "AGK5172" are, and give them that name). # MEL: I have to insist on using the family name (or alternatively you need to decide which species "AGN3107" and "AGK5172" are, and give them that name). These two bins have 100% similarity and cannot be given different genus names.
"AGK5172" = "Dytiscidae sp. B-AGK5172", # BOLD  Platynectes and Costonectes overlaps with AGN3107, so lump to family, given uncertainty, tfill Platynectes sp. MC-6 CHRIS: This is my specimen (KWG17Dyt1) identified to genus as . Please use Platynectes #MEL:see the previous bin_uri CHRIS2: I remember addressing this maybe it was in the other .qmd. Please use Dytiscidae (not the genus names at this point). Looking back can see I have create this confusion and need to correct it on BOLD. I'm pretty sure it is Chostonectes and Platynectes is wrong, but I really need to go back a check the specimens.
"AGQ6047" = "Polypedilum sp. B-AGQ6047", # BOLD Chironomidae, but overlaps with AGK4964 see next, tfill Polypedilum sp. B-AGQ6047 or Polypedilum sp. MC-FS1
"AGK4964" = "Polypedilum sp. B-AGK4964", # BOLD Polypedilum, tfill Polypedilum sp. B-AGQ6047 or Polypedilum sp. MC-FS1
"ACG8753" = "Polypedilum sp. B-ACG8753", # BOLD Chironomidae or Polypedilum, but a small overlap with AGK4964 and AGQ6047, tfill Polypedilum sp. B-ACG8753 or Polypedilum sp. MC-FS1 
"AEF3323" = "Sphaeriinae sp. B-AEF3323", # BOLD mainly identifies this as Euglesa casertana, but also many other species. This bin_uri overlaps with many others (see treatment of Sphaeriinase below)
"AES9495" = "Muscidae sp. B-AES9495",  # BOLD identifies this as Muscidae tfill agrees
"ACG9457" = "Riethia sp. B-ACG9457",
"AGB9918" = "Diptera sp. B-AGB9918", 
"ACG4785" = "Orthocladiinae sp. B-ACG4785", # BOLD calls this both Orthocladiinae and Psectrocladius. Conservative ID chosen
"AGD4745" = "Limnophila antennella", # BOLD id
"ADF0063" = "Agapetus sp. B-ADF0063", # BOLD id
"AEG5961" = "Aulodrilus pigueti", # BOLD id
"ADC2719" = "Austroaeschna sigma", # BOLD id
"ADC2975" = "Austrolestes psyche", # BOLD id
"AFU5450" = " Caloca sp. B-AFU5450", # BOLD id
"AEF5699" = "Cernosvitoviella microtheca", # BOLD id
"AGQ9451" = "Chironomidae sp. B-AGQ9451", # BOLD id
"ADC3923" = "Diphlebia lestoides", # BOLD id
"AGD4707" = "Limnophilinae sp. B-AGD4707", # BOLD id
"AEV7032"  = "Marionina argentea", # BOLD id
"ACM3329"  = "Molophilus aphanta", # BOLD id
"ACM3397" = "Molophilus capitatus", # BOLD id
"ACM3428" = "Molophilus sp. B-ACM3428",# BOLD id
"GBAAZ11256-24" = "Phreodrilidae sp. B-GBAAZ11256-24" # BOLD id
)

# # # # # #  #  ## Code used for checking the above  ABY8640
# bini <- "ACM7596"
# spp_bini <- tfill_spp_bins[tfill_spp_bins$bin_uri %in% bini,]
# asvs_with_mult_bins <- tfill$asv_code[tfill$no_bin_match > 1 & tfill$asv_code %in% spp_bini$asv_code]
# unique(tfill_spp_bins[tfill_spp_bins$asv_code %in% asvs_with_mult_bins, c("species","bin_uri")])
# spp_bini
# bold_results[!is.na(bold_results$family) & !is.na(bold_results$bin_uri) &
#                 bold_results$bin_uri %in% bini & bold_results$similarity >= 97,]
# # check_with_bold[check_with_bold$bold_bin_uri == bini,] # for use only after loading cross_check script

# non-aqu taxa revealed by bin search 
non_aqu_bins <- c("AEJ9583","AEE4516","AFS3667","ACQ3785","AFD6947","AFO3404",
                  "AFV7101","ADC6982", "ADD9619", "AEY0933","AGR8644","AGR8283", #Chrysomelidae, Curculionidae, Diptera, Hemiptera not necessarily aquatic)
                  "AFS0123","AFT5978","ABX3271","AFX2296","ADT5567",
                  "ADA4572","AFI9194","AEO9062","AGR8590","ABY0923",
                  "ACQ9362","AEV6150","GBAAZ5840-24","AGL9403","AAU4676",
                  "AFF7326", # Enoplea- unlikely to be freshwater
                  "AGL8425", "ADH9003","AFN9893","AAZ0768","ACQ9816", "AFJ0079",
                  "AGB2975","ADA1282","AET4867","ADC6313","ACH7901","AFW4797",
                  "AFU5686","ACP1899","ADU2224","AFJ0001")

# missing bins c("ACV8324","ABV8714","AAW3092","ACG1960","AAZ8934","ABW1132","AAW2994","ADX1240","ADF0434","AFN4160","ABW1138","AAE7976")
# tfill record with missing bin_uri "ABV8714"

# # Adopt the above corrections
bnc_df <- data.frame(bin_uri = names(bold_name_corrections), 
                       new_species = bold_name_corrections)
# Check for duplicates
xc <- bnc_df[duplicated(bnc_df$bin_uri) | duplicated(bnc_df$bin_uri, fromLast = TRUE),]
xc[order(xc$bin_uri),]  # should be empty data.frame (i.e. no duplicates)
bnc_df$checks <- 0

# Check that the above names are consistent with at least one name in each BOLD match.
for(i in 1:nrow(bnc_df)){
  first_word <- strsplit(bnc_df$new_species[i], " ")[[1]][1]
  if(first_word %in% taxon_gen$genus){
    bold_genera_names <- unique(bold_results$genus[!is.na(bold_results$bin_uri) & 
                bold_results$bin_uri == bnc_df$bin_uri[i] & bold_results$similarity >= 97])
    if(first_word %in% bold_genera_names) bnc_df$checks <- 1
  }else{
  if(first_word %in% subfams$subfamily){
    bold_subfam_names <- unique(bold_results$subfamily[!is.na(bold_results$bin_uri) & 
                bold_results$bin_uri == bnc_df$bin_uri[i] & bold_results$similarity >= 97])
    if(first_word %in% bold_subfam_names) bnc_df$checks <- 1
  }else{
  if(first_word %in% taxon_fam$family){
    bold_fam_names <- unique(bold_results$family[!is.na(bold_results$bin_uri) & 
                bold_results$bin_uri == bnc_df$bin_uri[i] & bold_results$similarity >= 97])
    if(first_word %in% bold_fam_names) bnc_df$checks <- 1
    
  }
    }
  }
}
sum(bnc_df$checks == 0)  #0, so all consistent with bold_results

# Check that genera names are consistent for all overlapping bin_uris in bnc_df
for(i in 1:nrow(bnc_df)){
  bini <- bnc_df$bin_uri[i]
  geni <- strsplit(bnc_df$new_species[i]," ")[[1]][1]
  bini_asvs <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == bini]
  other_bins_i <- unique(tfill_spp_bins$bin_uri[tfill_spp_bins$asv_code %in% bini_asvs & 
                                   tfill_spp_bins$bin_uri != bini])
  other_bnc_bins <- other_bins_i[other_bins_i %in% bnc_df$bin_uri]
  other_bins <- other_bins_i[!other_bins_i %in% bnc_df$bin_uri]
  if(length(other_bnc_bins) > 0)  {
    other_names <- unique(bnc_df$new_species[bnc_df$bin_uri %in% other_bnc_bins])
    other_genus <- unique(sapply(strsplit(other_names," "),"[[",1))
    if(length(other_genus) > 1) stop("2a")
       if(geni != other_genus) stop("3a")
  }
  # other_bins don't matter as mis-id in tfill_spp_bins get corrected below.
  # This is just checking for consistency within bnc_df
}
# No stops mean that there are no inconsistencies with genus names (Chostonectes and Platynectes above were a problem)
# CW check that 86b33bf13e66c6c67d3f5474293b571e gets corrected to Cheumatopsyche alampeta

for(i in 1:nrow(bnc_df)){
  asvcodei <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                                        tfill_spp_bins$bin_uri == bnc_df$bin_uri[i]]
  tfill_spp_bins$species[tfill_spp_bins$asv_code %in% asvcodei] <- 
                                                    bnc_df$new_species[i]
  tfill$species[tfill$asv_code %in% asvcodei] <- bnc_df$new_species[i]
}

### 1. Record only identified to Amphipoda (could be terrestrial)
###      But note that in some samples you have identified this (incorrectly) as a lumbriculid
tfill_nonaq <- rbind(tfill_nonaq, 
                     tfill[tfill$asv_code %in% tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "AFN5257"],
                           match(names(tfill_nonaq),names(tfill))])
tfill <- tfill[!tfill$asv_code %in% tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "AFN5257"],]
tfill_spp_bins <- tfill_spp_bins[tfill_spp_bins$bin_uri != "AFN5257",]
### 2. terrestrial species identified in bold above
terr_to_remove <- tfill_spp_bins[tfill_spp_bins$bin_uri %in% non_aqu_bins,]
tfill_nonaq <- rbind(tfill_nonaq, 
                     tfill[tfill$asv_code %in% terr_to_remove$asv_code,
                           match(names(tfill_nonaq),names(tfill))])
tfill <- tfill[!tfill$asv_code %in% terr_to_remove$asv_code,]  #20,321
tfill_spp_bins <- tfill_spp_bins[!tfill_spp_bins$bin_uri %in% non_aqu_bins,] #22,509

### MC species equivalences
tfill$species[tfill$species %in% "Girardia sp. MC-1"] <- "Girardia sinensis" # Many overlapping bin_uris
tfill$species[tfill$species %in% "Tonnoiromyia sp. EPAsp3"] <- "Tonnoiromyia tasmaniensis" # Many overlapping bin_uris

# Formally named groups (formally named species that share bin_uris)
tfill$species[tfill$species %in% c("Dinotoperla aryballoi","Dinotoperla christinae")] <- "Dinotoperla christinae/aryballoi" #BOLD identifies this as both species
tfill$species[tfill$species %in% c("Pristina aequiseta","Pristina foreli")] <- "Pristina aequiseta/foreli" 
tfill$species[tfill$species %in% c("Culex orbostiensis","Culex australicus")] <- "Culex australicus/orbostiensis"
tfill$species[tfill$species %in% c("Nais stolci","Nais pardalis")] <- "Nais stolci/pardalis"
tfill$species[tfill$species %in% c("Kiefferulus cornishi","Kiefferulus intertinctus")] <- "Kiefferulus cornishi/intertinctus"
tfill$species[tfill$species %in% c("Tamasia acuta","Tamasia variegata")] <- "Tamasia acuta/variegata"
tfill$species[tfill$species %in% c("Austropyrgus centralia","Austropyrgus turbatus","Austropyrgus angasi","Austropyrgus centralia/turbatus")] <- "Austropyrgus angasi group"
tfill$species[tfill$species %in% c("Hydra oligactis","Hydra robusta")] <- "Hydra oligactis/robusta"
tfill$species[tfill$species %in% c("Hydra sinensis","Hydra viridissima")] <- "Hydra sinensis/viridissima"
tfill$species[tfill$species %in% c("Gynoplistia bimaculata","Gynoplistia lowanna")] <- "Gynoplistia bimaculata/lowanna"
tfill$species[tfill$species %in% c("Nais elinguis","Nais pseudobtusa")] <- "Nais elinguis/pseudobtusa"
tfill$species[tfill$species %in% c("Rheumatometra dimorpha","Rheumatometra philarete")] <- "Rheumatometra dimorpha/philarete"
tfill$species[tfill$species %in% c("Leptoperla kimminsi group")] <- "Leptoperla kimminsi"
tfill$species[tfill$species %in% c("Nannochorista dipteroides group")] <- "Nannochorista dipteroides" 
tfill$species[tfill$species %in% c("Triplectides truncatus group")] <- "Triplectides truncatus"
# Add "Nais variabilis" to "Nais communis group" (shares AAF7606 and AEV1351)
tfill$species[tfill$species == "Nais variabilis"] <- "Nais communis group"
tfill_spp_bins$species[tfill_spp_bins$species == "Nais variabilis"] <- "Nais communis group"

# ### Code used for checking the above
# tfill[tfill$asv_code == tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "ABV8830"][1], names(tfill) != "asv_sequence"]
# match_list_bin_uri[[tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "ADJ0699"][1]]]

### discarded as unnecessary
# # # ABX4126 "Eusthenia sp. B-ABX4126"  NOT "Dinotoperla thwaitesi"
# asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) &
#                      tfill_spp_bins$bin_uri == "ABX4126" &
#                      tfill_spp_bins$species == "Dinotoperla thwaitesi"]
# tfill$species[tfill$asv_code %in% asvi] <- "Eusthenia sp. B-ABX4126"
# 
# # "Hydrobiosella waddama" and "Hydrobiosella perangusta" are distinct except for 
# # asv_code cf4d8b16cb64eb29dd6eb8aeff774878, which has similarity >0.985 with 
# # Hydrobiosella waddama AAZ5125 and similarity 0.9706 to one record of AAZ4813...
# # just over the criterion.  Sufficiently different to keep separate. Thus:
# tfill_spp_bins$bin_uri[(tfill_spp_bins$species == "Hydrobiosella waddama" & 
#                      tfill_spp_bins$bin_uri == "AAZ4813")] <- "AAZ5125"


# The taxonomic tables taxon_fam and taxon_gen introduce some inconsistencies in family names
# Some, noted here for reference, are Telephlebiidae (predominately Austroaeschna) - Aeshnidae (on BOLD), 
# and , Nanophyidae - Brentidae (on BOLD for ADD0490).

## Check genus and family fields throughout the table ensuring: 
## a) the genus name matches the first word of the species name (or is blank if 
##     the first word is a higher taxonomic level)
## b) the family name is the correct family for the given genus (or species name
##     if the species name is not a genus) 
tfill$genus_old <- tfill$genus
tfill$family_old <- tfill$family
# Remove dodgy genus and family names
tfill$family[!is.na(tfill$family) & tfill$family == "Pisidiidae"] <- "Sphaeriidae"
tfill$genus[!is.na(tfill$genus) & !tfill$genus %in% taxon_gen$genus] <- NA
tfill$family[!is.na(tfill$genus) & !tfill$family %in% taxon_fam$family] <- NA
tfill$family[grep("Diptera", tfill$species)] <- NA
tfill$genus[grep("Diptera", tfill$species)] <- NA

# sum(grepl("Unident.", max_p_update_df$species))  #198
## 198 records without a species name (all from the max_p_update table)

# Ensure family field is consistent with the max_p_identity rules
sum(!is.na(tfill$family[tfill$max_p_identity < 95]))  #281 records with a family value but sim <95 (some also have a genus listed)
tfill$genus[tfill$max_p_identity < 95] <- NA
tfill$family[tfill$max_p_identity < 92] <- NA
### sum(!is.na(tfill$order[tfill$max_p_identity < 92])) #280 records with an order value but sim < 92
tfill$order[tfill$max_p_identity < 85] <- NA
# Leave genus values for now.

# One over-reaching family-level id
tfill$genus[tfill$species == "Chironomidae sp. B-ADC2098"] <- NA

## Finally loop through each record correcting genus and family names (having
## kept a record of old names and identifying those that have changed above.)
correct_gen_fam <- function(taxon_tab){
for(i in 1:nrow(taxon_tab)){
  recordi <- taxon_tab[i,]
  if(!is.na(taxon_tab$species[i])){
  first_word <- strsplit(recordi$species," ")[[1]][1]
  # If the first word in the species name is not a listed genus, family or subfamily...
  if(!first_word %in% taxon_gen$genus & 
     (is.na(recordi$order) | !first_word == recordi$order) & 
     !first_word %in% c(taxon_fam$family, 
                  taxon_fam$subfamily[!is.na(taxon_fam$subfamily)],
                  taxon_fam$tribe[!is.na(taxon_fam$tribe)]) & 
     # Some valid subfamily names not used in taxonomic hierarchy
     !first_word %in% subfams$subfamily){
    next()  # Some names above family are ignored and may be incorrect
    }
  }else{
    if(!is.na(recordi$family))  first_word <- recordi$family
    if(!is.na(recordi$genus)) first_word <- recordi$genus
  }
 #...only proceed if "genus" and "family" fields have a value - stop if so
  if(!(is.na(recordi$genus) & is.na(recordi$family))) {
     #If it's a listed genus, then give the genus field that name , 
     # and give the family name the correct family name from the mwbugs database
  if(first_word %in% taxon_gen$genus){
    # if non genus is listed or it doesn't match the first_word
    if(is.na(recordi$genus) | recordi$genus != first_word){
      taxon_tab$genus[i] <- strsplit(recordi$species," ")[[1]][1]
    }
    taxon_geni <- taxon_gen[taxon_gen$genus == taxon_tab$genus[i],]
    taxon_fam_tab <- taxon_fam[taxon_fam$famcode == taxon_geni$famcode,]
    taxon_fami <- taxon_fam_tab$family
    # If the genus is a Tubificid, make the family field "Naididae"
    if(taxon_fam_tab$famcode == "LO04"){
         taxon_fami <- "Naididae"
        }
    # If the genus is a chironomid make the family field the subfamily
    if(grepl("QDA",taxon_fam_tab$famcode)){
        taxon_fami <- taxon_fam_tab$subfamily
        }
    taxon_tab$family[i] <- taxon_fami
  }
  }
  }
  taxon_tab
}
tfill <- correct_gen_fam(tfill)

tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code, tfill$asv_code)]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]

### And re-run the tfill_spp_bins compilation...maybe not necessary?
tfill$n_bold_matches <- 0
for(i in 1:nrow(tfill)){
  if(tfill$asv_code[i] %in% names(match_list_bin_uri)){
    matchi <- match_list_bin_uri[[tfill$asv_code[i]]]
    matchi_97 <- matchi[matchi$similarity >= 97,]
    if(nrow(matchi_97) > 0)
    tfill$n_bold_matches[i] <- length(unique(matchi_97$bin_uri))
  }}

tfill_spp_bins <- data.frame(tfill[tfill$n_bold_matches > 0, c("asv_code","species")],
                             bin_uri = NA)
add_bins <- tfill_spp_bins[0,]
for(i in 1:nrow(tfill_spp_bins)){
    matchi <- match_list_bin_uri[[tfill_spp_bins$asv_code[i]]]
    bins <- matchi$bin_uri[matchi$similarity >= 97]
    bins <- unique(bins[!is.na(bins) & !bins == ""])
  if(length(unique(bins)) == 0){
     stop("1")
    }else{
    tfill_spp_bins$bin_uri[i] <- unique(bins)[1]
    if(length(unique(bins)) > 1){
      add_bins <- rbind(add_bins, 
                              data.frame(asv_code = tfill_spp_bins$asv_code[i],
                              species = tfill$species[tfill$asv_code == tfill_spp_bins$asv_code[i]],      
                              bin_uri =bins[-1]))
    }
    }
}
tfill_spp_bins <- rbind(tfill_spp_bins, add_bins)
tfill_spp_bins <- tfill_spp_bins[order(tfill_spp_bins$species),]

tfill_spp_bins_bu <- tfill_spp_bins
tfill_bu <- tfill
```

With genus and family fields correct, correct species names, using the following rules:

- Species without a formal identification, but with a single match to a bin_uri are given a species name using the bin_uri (e.g. );

- Species without a formal identification, that match two or more bin_uris are given a species names using one bin_Uri and the term "group" (e.g. );

- Species with a formal identification, that match one or more bin_uris (and none of those bin_uris are validly associated with any other formal species names) are given the formal species name as it is. (e.g. , which matches bin_uris....)

- Species with a formal identification, that match more than one bin_uris that are validly associated with two formal spcies names are given both species names separated by "/" (e.g.)

- Species with a formal identification, that match more than two bin_uris that are validly associated with two formal spcies names are given the most common formal species name followed by group (e.g.)

To begin this process, we ensure all species without formal identifications are given a name matching a single bin_uri (prior to grouping below).

The chunk below identifies the number of distinct species names associated with bin_uris. (There should only be one species name per bin_uri, while each species name can have multiple bin_uris).  

The loop creates a list to catch any groups of bin_uris that need to be given formal group names (form_gps).  To ensure transparent grouping decisions, we ran the loop first, and then made the requisite manual changes before re-running the loop.  

The loop also creates a list of groups with inconsistent names (inc_groups), which were similarly caught and corrected before re-running the loop.

```{r}
# Check for bin_url inconsistencies, and create new group names where appropriate
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]
tfill_spp_bins_bu <- tfill_spp_bins

tfill_spp_bins <- tfill_spp_bins_bu
tfill <- tfill_bu

tfill_asv_spp_unq <- unique(tfill_spp_bins[,1:2])
sum(duplicated(tfill_asv_spp_unq$asv_code)) # 0.  Only a single name per asv_code

# The above process has created multiple names for some bin_uris. Here, all species names
# are reconciled with the bold_results tables and renamed according to the rules above
tfill_asv_spp_unq$species_corrected <- NA
# Keep formally named groups (form_gps) and inconsistently named groups (inc_gps) for iterative correction
form_gps <- inc_gps <- list()
# Create a check list that contains all bin_uris associated with species_corrected names created in the following loop
bin_check <- data.frame(species_corrected = NA, bin_uri = NA)
for(i in 1:nrow(tfill_asv_spp_unq)){
  # Find all bin_uris associated with the current asv_code
  binis <-  unique(bold_results$bin_uri[bold_results$asv_code == tfill_asv_spp_unq$asv_code[i] & 
                                         bold_results$similarity >= 97])
  binis2 <- c(binis, binis)
  # Iteratively extract all bin_uris from bold_results that overlap with binis with similarity >= 97
  while(length(binis2) > length(binis)){
  asvsi <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri %in% unique(binis2)]
  binis2 <- unique(bold_results$bin_uri[bold_results$asv_code %in% asvsi & bold_results$similarity >= 97])
  binis <- binis2[order(binis2)]
  }
  binis <- binis[!is.na(binis)]
  # Create spi, a vector of unique species names associated with each bin_uri
  spi <- unique(tfill_asv_spp_unq$species[i])
  # Check all names in spi start with the first name (add to inc_gps if not, and use this to correct for next iteration)
  spi_first_name <- unique(sapply(strsplit(spi," "),"[[",1))
   if(length(spi_first_name) != 1) { 
        stop("1") 
        inc_gps <- c(inc_gps, list(spi))
#        next()
        }
  # If spi only contains one name 
   if(length(spi) == 1){
       # If the current bin_uri is already in the bin_check table, then  give this bin_uri its existing name from the bin_checks table
    if(sum(binis %in% bin_check$bin_uri) > 0){
        exist_species <- unique(bin_check$species_corrected[bin_check$bin_uri %in% binis])
        # But first check that there is only one existing species names, and that its first name matches the current species name 
          if(length(exist_species) > 1) stop("8")
            exist_species_first_name <- strsplit(exist_species, " ")[[1]][1]
          if(exist_species_first_name != spi_first_name) stop("9")
            #if spi is a not a formal name and...
    if(grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi)){
         # ...use exist_species (doesn't matter if it's formal or not)
                  new_name <- exist_species
          }else{  #i.e otherwise, if spi is a formal name, use spi
                  new_name <- spi
            # and if exist_species is informal update previous name allocations to the new formal name
          if(grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", exist_species)){
                  tfill_asv_spp_unq$species_corrected[tfill_asv_spp_unq$species_corrected == exist_species] <- spi
                  bin_check$species_corrected[bin_check$species_corrected == exist_species] <- spi 
               }
   }
    }else{
      new_name <- ifelse(grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi),
                         paste0(spi_first_name, " sp. B-", binis[1]), spi)
    }
     }else{  #i.e. if spi contains more than one name
  # Check if spi contains more than two formal names (add to form_grps if not, and use this to correct for next iteration)
   if(sum(!grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi)) > 1) {
     stop("3") 
     form_gps <- c(form_gps, list(spi))
#     next()
     }
  # If there is only one formal name, then call the species that (i.e. replace the non-formal names)
  if(sum(!grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi)) == 1){
       # But if the bin_uri is already in the bin_check table, stop, check and correct (it shouldn't be)
       if(sum(binis %in% bin_check$bin_uri) > 0) {
        exist_species <- unique(bin_check$species_corrected[bin_check$bin_uri %in% binis])
        # But first check that there is only one existing species names, and that its first name matches the current species name 
          if(length(exist_species) > 1) stop("8")
            exist_species_first_name <- strsplit(exist_species, " ")[[1]][1]
          if(exist_species_first_name != spi_first_name) stop("9a")
            new_name <- exist_species
       }else{ # otherwise, give it a B- name using this bin_uri
         new_name <- paste0(spi_first_name, " sp. B-", binis[1])
       }
   }else{  # i.e. if there is no formal name (having considered the other possibilities above), 
    # then give it a single B- name using the first bin_uri (alphabetically - ordered above) associated with this name...
    # But first check that none of the bins associated with this name do not already appear in species_corrected
      if(sum(grepl(binis[j], bin_check$bin_uri)) > 0){  
        # Check the existing species_corrected name has the same first word (and that there is only one 
        # if so, use the existing species name if not stop
        exist_species <- unique(bin_check$species_corrected[bin_check$bin_uri %in% binis])
        if(length(exist_species) > 1) stop("5")
         exist_species_first_name <- strsplit(exist_species, " ")[[1]][1]
         if(exist_species_first_name != spi_first_name) stop("6")
         # If spi is a formal name and exist species is not, then change all previous records to the formal name
         # and make it new name as well
         if(!grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi) > 0 & 
            grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", exist_species) ){
           stop("23")
                tfill_asv_spp_unq$species_corrected[tfill_asv_spp_unq$species_corrected == exist_species] <-
                  spi[!grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi)]
                new_name <- spi[!grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi)]
                bin_check$species_corrected[bin_check$species_corrected == exist_species] <- 
                  spi[!grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi)]
                new_name <- spi[!grepl("B-|MC|MEC-|CEF|CEB|CEO|T21048|EPAsp|G-|Unident", spi)]
         }else{
           new_name <- exist_species
         }
      }else{ # i.e. if this is the first occurrence of this bin_uri in the dataset, use it to name the species
         new_name <- paste0(spi_first_name, " sp. B-", binis[1])
      }
   }
   }
   if(is.na(new_name)) stop("15")
     tfill_asv_spp_unq$species_corrected[i]  <- new_name
    # add all bin_uris that overlap with these records to bin_check
     bin_check <- unique(rbind(bin_check, 
                          data.frame(species_corrected = new_name,
                                     bin_uri = binis)))
     bin_check <- bin_check[!is.na(bin_check$bin_uri),]
}

```

```{r}
tfill_spp_bins$species_corrected <- 
  tfill_asv_spp_unq$species_corrected[match(tfill_spp_bins$asv_code, tfill_asv_spp_unq$asv_code)]

n_unq <- function(x) length(unique(x))
# Re-calculate the number of species per bin, and check each bin has only one name
spp_per_bin <- aggregate(tfill_spp_bins$species_corrected, by = list(bin_uri = tfill_spp_bins$bin_uri), FUN = n_unq)
max(spp_per_bin$x) # 1 as it should be

# Now, calculate the number of bin_uris per name
bin_per_sp <- aggregate(tfill_spp_bins$bin_uri, by = list(species_corrected = tfill_spp_bins$species_corrected), FUN = n_unq)
max(bin_per_sp$x) # as many as 15 bin_uris per species
# Finally add 'group' to any 'B-' species_corrected that has more than bin_uri
for(i in 1:nrow(bin_per_sp)){
  if(grepl("B-", bin_per_sp$species_corrected[i]) & bin_per_sp$x[i] > 1)
    tfill_spp_bins$species_corrected[tfill_spp_bins$species_corrected == bin_per_sp$species_corrected[i]] <- 
      paste(bin_per_sp$species_corrected[i], "group")
}
spp_per_bin <- aggregate(tfill_spp_bins$species_corrected, by = list(bin_uri = tfill_spp_bins$bin_uri), FUN = n_unq)
max(spp_per_bin$x) # 1 as it should be

# After the above changes update the three tfill-related tables
tfill_spp_bins$species <- tfill_spp_bins$species_corrected
# Remove duplicates generated by the above changes
tfill_spp_bins <- unique(tfill_spp_bins)


tfill_spp_bins <- tfill_spp_bins[,names(tfill_spp_bins) != "species_corrected"]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,c("species","bin_uri")])
tfill$species[tfill$asv_code %in% tfill_spp_bins$asv_code] <- 
     tfill_spp_bins$species[match(tfill$asv_code[tfill$asv_code %in% tfill_spp_bins$asv_code], tfill_spp_bins$asv_code)]
# ### Finally correct all taxonomy names (after any changes to species names)
 tfill <- correct_gen_fam(tfill)

```

An early version of the library had a separate "max_p_update" table that included records for which max_p_identity was adjusted based on BOLD matches. While the adjustments made to max_p_identity can be identified by comparing the original vsearch max_p_identity with the maximum BOLD similarity, the original vsearch values have been lost from many of the records in the original "max_p_update" table. As a result, we now include a field "max_p_update" that allows quick identification of records with updated max_p_identity (1 = updated, 0 = not)

# MEL, as explained above, I decided against heading down the rabbit hole of finding original vsearch max_p_identites, given your response about 'for the ARC data' suggests it won't be possible for all records. So the 'max_p_update' field is a work around.

The following logic is used to adjust max_p_identity values:

1. if the maximum match with BOLD records (saved as max_sim_bold) is greater than the vsearch max_p_identity (saved as sim_vsearch), change max_p_identity to the max_sim_bold value

2. if max_sim_bold is  <97, and sim_vsearch is >=97, change max_p_identity to the max_sim_bold value.

3. MEL: what I do with the <94 matches ...depends on answers to my questions I sought clarification on in the email on Tuesday. CHRIS2: I assume this is 293 sequences that you send me. I'll deal with these at the end of the Appendix_2_cross_check_manual.qmd


```{r}
# Create a field identifying records with changed max_p_identity
tfill$max_p_update <- 0
tfill$max_p_update[tfill$asv_code %in% max_p_update_df$asv_code] <- 1

# Keep a record of the original vsearch max_p_identity (where this field hasn't already been changed: see above)
tfill$sim_vsearch <- tfill$max_p_identity
# Find the maximum BOLD similarity for each record
tfill$max_sim_bold <- NA
for(i in 1:nrow(tfill)){
  if(tfill$asv_code[i] %in% names(match_list_bin_uri)){
  matchi <- match_list_bin_uri[[tfill$asv_code[i]]]
  tfill$max_sim_bold[i] <- max(matchi$similarity, na.rm = TRUE)
  }
}

# 1. replace max_p_identity with max_sim_bold if the latter is higher.
sum(tfill$max_sim_bold > tfill$sim_vsearch, na.rm = TRUE) #10888 
for(i in 1:nrow(tfill)){
  if(!is.na(tfill$max_sim_bold[i]) & tfill$max_sim_bold[i] > tfill$sim_vsearch[i]) {
    tfill$max_p_identity[i] <- tfill$max_sim_bold[i]
    tfill$max_p_update[i] <- 1
  }
  }

# 2, replace max_p_identity with max_sim_bold if  if the latter is <97 and the former is >=97
sum(tfill$max_sim_bold < 97 & tfill$sim_vsearch >= 97, na.rm = TRUE)  # 589
for(i in 1:nrow(tfill)){
  if(!is.na(tfill$max_sim_bold[i]) & tfill$max_sim_bold[i] < 97 & tfill$sim_vsearch[i] >= 97){
    tfill$max_p_identity[i] <- tfill$max_sim_bold[i]
    tfill$max_p_update[i] <- 1
    }
}

# And having corrected the max_p_identity field, repeat clean up of taxon fields
tfill$species[tfill$max_p_identity < 97] <- NA
tfill$genus[tfill$max_p_identity < 95] <- NA
tfill$family[tfill$max_p_identity < 92] <- NA
### sum(!is.na(tfill$order[tfill$max_p_identity < 92])) #280 records with an order value but sim < 92
tfill$order[tfill$max_p_identity < 85] <- NA
# Leave genus values for now.

```

```{r}
# Check that tfill and tfill_spp_bins are consistent.
for(i in 1:nrow(tfill_spp_bins)){
  if(unique(tfill$species[tfill$asv_code == tfill_spp_bins$asv_code[i]]) != tfill_spp_bins$species[i])
    stop("Check")
}
tfill_spp_bins_unq <- unique(tfill_spp_bins[,c("species","bin_uri")])

check <- tfill_spp_bins[!grepl("group", tfill_spp_bins$species) & 
                          !grepl("/", tfill_spp_bins$species) & 
                          grepl("B-", tfill_spp_bins$species),]
wronguns <- check[!is.na(check$bin_uri) & check$bin_uri != right(check$species,7),]
nrow(wronguns) # 6, all on BOLD, but without registered bins, so they are ok.

tfill_with_unidents <- tfill
tfill$species[grep("Unident", tfill$species)] <- NA

```

Non-aquatic/non-macroinvertebrate records were checked and corrected by Mel Carew in a separate, non-scripted process. These records are corrected and added to tfill here using a file compiled from Mel's correction spreadsheets.  MEL: this is not going to be 100% right (I know some of the taxonomic fields are not fully populated - I am not familiar enough with the taxonomy of these species to do any more), but it will be better than if it was uncorrected. I've wasted too much time on your non-aquatic records to spend any more time on this. CHRIS2: I will deal with these. Pretty sure I know how to tackle it.

```{r}
# Some ad-hoc corrections to max_p_update not captured with the above being restricted to aquatic records
tfill_nonaq$genus[!is.na(tfill_nonaq$genus) & tfill_nonaq$genus == "Cernosvitoviella aggtelekiensis"] <- "Cernosvitoviella"
tfill_nonaq$species[!is.na(tfill_nonaq$genus) & tfill_nonaq$genus == "Miselaoma"] <- "Miselaoma sinistra"
tfill_nonaq$genus[grep("idae",tfill_nonaq$genus)] <- NA
tfill_nonaq$species <- gsub("\\(sp. Unident.\\)","sp. (Unident.)",tfill_nonaq$species)
tfill_nonaq$species[!is.na(tfill_nonaq$genus) & grepl("Unident.", tfill_nonaq$species)] <- 
  paste0(tfill_nonaq$genus[!is.na(tfill_nonaq$genus) & grepl("Unident.", tfill_nonaq$species)],
         " sp. (Unident.)")
tfill_nonaq$species[!is.na(tfill_nonaq$family) & is.na(tfill_nonaq$genus) & grepl("Unident.", tfill_nonaq$species)] <- 
  paste0(tfill_nonaq$family[!is.na(tfill_nonaq$family) & is.na(tfill_nonaq$genus) & grepl("Unident.", tfill_nonaq$species)],
         " sp. (Unident.)")

# non-macro non-aqu checked records
nmna <- all_MC_checks[!all_MC_checks$asv_code %in% tfill$asv_code,]
# Only those records identified as requiring a change 
nmna <- nmna[grep("name", nmna$action),]  # 526 records

# MEL: there are 13 records (here, in not_in_asv_lib: MEL: this was 22 in the last version), most of which look aquatic that are in all_MC_checks, but not in any of the input data used to build asv_library as far as I can see.  I will ignore for now, unless you really want to include them in the library (in which case, can you please dig up their original records with the fields that match tfill?)
#CHRIS: Looking at the nmna records above I can see 1a81e300f12b366e35d95243952e2b37 and 43409a5e755ee995f4afa01e3188fe10 should not be renamed according to my 'checked_species' name (i was mistaken) the remainder are either terrestrial (which I don't expect you to check), additional taxonomic information for available for aquatic/terrestrial species or Proteobacteria (that may be identified as invertebrate DNA in the vsearch library - some people deposit what they think the have an invert DNA sequence when they have actually have the bacteria living in the insect) CHRIS2: please read in the file below for explanations
not_in_asv_lib_exp <- read.csv("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library/not_in_asv_lib_reasons.csv")

not_in_asv_lib <- nmna[!nmna$asv_code %in% tfill_nonaq$asv_code & 
                         !nmna$asv_code %in% all_records_non_aq$asv_code & 
                         !nmna$asv_code %in% bact_records$asv_code & 
                         !nmna$asv_code %in% all_records$asv_code,]
# sum(nmna$asv_code %in% all_records_non_aq$asv_code)
#CHRIS: On my checking all these records come from the MW46 dataset prior to any filtering.
# MEL: I still haven't included these in tfill. The two records you identify above are from mw46 and have no match with BOLD (according to bold_results), and therefore should not keep their original names of Micronecta sp. B-ACG1960 and Nais sp. B-AAF9652.  A few other records in nmna are aquatic, but I cannot find them in any of the source files I have been working with (e.g. "f6a0d1f9bec02a7dc7e59e894a3e874d", "0d73b0f475b83e1069d9f2e38f4b5758"). Unless you can point me to their original records, I will continue to not include these records. CHRIS2: I suspect the source file you has been filtered by you and used the version on your database for subsequent checks, You will find the records without filtering here:
MW46_unfiltered <- readxl::read_xlsx("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library/All_MW46_metabarcoding_data.xlsx", sheet = "raw_data")


nmna <- nmna[!nmna$asv_code %in% not_in_asv_lib$asv_code,] #513 records

new_non_aq <- nmna[nmna$asv_code %in% all_records_non_aq$asv_code,]
new_non_aq <- new_non_aq[!new_non_aq$asv_code %in% tfill_nonaq$asv_code,] # 141 new
new_non_aq <- all_records_non_aq[all_records_non_aq$asv_code %in% new_non_aq,]
names(new_non_aq)[names(new_non_aq) == "asv_seq"] <- "asv_sequence"

# Add these to tfill_nonaq
tfill_nonaq <- rbind(tfill_nonaq, new_non_aq)
tfill_nonaq$species_old <- tfill_nonaq$species

nmna$bold_match <- as.numeric(nmna$bold_match)

tfill_nonaq$phylum[tfill_nonaq$asv_code == nmna$asv_code[nmna$checked_species_name == "Ascomycota"]] <- "Ascomycota"
nmna <- nmna[nmna$checked_species_name != "Ascomycota",]
# # Remove records with now taxonomic info
nmna <- nmna[nmna$checked_species_name != "",]  #508

for(i in 1:nrow(nmna)){
  if(nmna$asv_code[i] %in% tfill_nonaq$asv_code){  
  splitname <- strsplit(nmna$checked_species_name[i]," ")[[1]]
  # correct spelling error
  if(splitname[1] == "Enchytraeida")
  splitname[1] <- gsub("Enchytraeida","Enchytraeidae",splitname[1])
  # if nmna$bold_match[i] is NA , or if bold_match >= 97, assume private library species name is right
  if(is.na(nmna$bold_match[i]) | nmna$bold_match[i] >= 97){
    if(length(splitname) < 2) {
    tfill_nonaq$species[tfill_nonaq$asv_code == nmna$asv_code[i]] <- NA
    if(right(splitname[1],2) == "ae"){
      tfill_nonaq$family[tfill_nonaq$asv_code == nmna$asv_code[i]] <- splitname[1]
      tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]] <- NA
       }else{
      tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]] <- splitname[1]
       }
    }else{
     tfill_nonaq$species[tfill_nonaq$asv_code == nmna$asv_code[i]] <- nmna$checked_species_name[i]
     if(right(splitname[1],2) == "ae"){
       tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]] <- ""
     if(is.na(tfill_nonaq$family[tfill_nonaq$asv_code == nmna$asv_code[i]]) | 
        tfill_nonaq$family[tfill_nonaq$asv_code == nmna$asv_code[i]] != splitname[1]) 
       tfill_nonaq$family[tfill_nonaq$asv_code == nmna$asv_code[i]] <- splitname[1]
     }else{
     if(is.na(tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]]) | 
        tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]] != splitname[1] & 
        right(splitname[1],2) != "ae") 
        tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]] <- splitname[1]
     }
  }
    }else{
    if(length(splitname) < 2) {
    tfill_nonaq$species[tfill_nonaq$asv_code == nmna$asv_code[i]] <- NA
    if(right(splitname[1],2) == "ae"){
      tfill_nonaq$family[tfill_nonaq$asv_code == nmna$asv_code[i]] <- splitname[1]
      tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]] <- NA
       }else{
      tfill_nonaq$genus[tfill_nonaq$asv_code == nmna$asv_code[i]] <- splitname[1]
       }
  }
  }
  }
}

# Re-add all Proteobacteria records 
bact_records$species_old <- NA
tfill_nonaq <- rbind(tfill_nonaq, bact_records)


# build tfill_nonaq_spp_bin
tfill_nonaq$n_bold_matches <- 0
for(i in 1:nrow(tfill_nonaq)){
  if(tfill_nonaq$asv_code[i] %in% names(match_list_bin_uri)){
    matchi <- match_list_bin_uri[[tfill_nonaq$asv_code[i]]]
    matchi_97 <- matchi[matchi$similarity >= 97,]
    if(nrow(matchi_97) > 0)
    tfill_nonaq$n_bold_matches[i] <- length(unique(matchi_97$bin_uri))
  }}

tfill_nonaq_spp_bins <- data.frame(tfill_nonaq[tfill_nonaq$n_bold_matches > 0, c("asv_code","species")],
                             bin_uri = NA)
add_bins <- tfill_nonaq_spp_bins[0,]
for(i in 1:nrow(tfill_nonaq_spp_bins)){
    matchi <- match_list_bin_uri[[tfill_nonaq_spp_bins$asv_code[i]]]
    bins <- matchi$bin_uri[matchi$similarity >= 97]
    bins <- unique(bins[!is.na(bins) & !bins == ""])
  if(length(unique(bins)) == 0){
     stop("1")
    }else{
    tfill_nonaq_spp_bins$bin_uri[i] <- unique(bins)[1]
    if(length(unique(bins)) > 1){
      add_bins <- rbind(add_bins, 
                              data.frame(asv_code = tfill_nonaq_spp_bins$asv_code[i],
                              species = tfill$species[tfill$asv_code == tfill_nonaq_spp_bins$asv_code[i]],      
                              bin_uri =bins[-1]))
    }
    }
}
tfill_nonaq_spp_bins <- rbind(tfill_nonaq_spp_bins, add_bins)
tfill_nonaq_spp_bins <- tfill_nonaq_spp_bins[order(tfill_nonaq_spp_bins$species),]

# Having corrected names, repeat max_p_update procedure from above
# Create a field identifying records with changed max_p_identity
tfill_nonaq$max_p_update <- 0
tfill_nonaq$max_p_update[tfill_nonaq$asv_code %in% max_p_update_df$asv_code] <- 1

# Keep a record of the original vsearch max_p_identity (where this field hasn't already been changed: see above)
tfill_nonaq$sim_vsearch <- tfill_nonaq$max_p_identity
# Find the maximum BOLD similarity for each record
tfill_nonaq$max_sim_bold <- NA
for(i in 1:nrow(tfill_nonaq)){
  if(tfill_nonaq$asv_code[i] %in% names(match_list_bin_uri)){
  matchi <- match_list_bin_uri[[tfill_nonaq$asv_code[i]]]
  tfill_nonaq$max_sim_bold[i] <- max(matchi$similarity, na.rm = TRUE)
  }
}

# 1. replace max_p_identity with max_sim_bold if the latter is higher.
sum(tfill_nonaq$max_sim_bold > tfill_nonaq$sim_vsearch, na.rm = TRUE) #10888 
for(i in 1:nrow(tfill_nonaq)){
  if(!is.na(tfill_nonaq$max_sim_bold[i]) & tfill_nonaq$max_sim_bold[i] > tfill_nonaq$sim_vsearch[i]) {
    tfill_nonaq$max_p_identity[i] <- tfill_nonaq$max_sim_bold[i]
    tfill_nonaq$max_p_update[i] <- 1
  }
  }

# 2, replace max_p_identity with max_sim_bold if  if the latter is <97 and the former is >=97
sum(tfill_nonaq$max_sim_bold < 97 & tfill_nonaq$sim_vsearch >= 97, na.rm = TRUE)  # 589
for(i in 1:nrow(tfill_nonaq)){
  if(!is.na(tfill_nonaq$max_sim_bold[i]) & tfill_nonaq$max_sim_bold[i] < 97 & tfill_nonaq$sim_vsearch[i] >= 97){
    tfill_nonaq$max_p_identity[i] <- tfill_nonaq$max_sim_bold[i]
    tfill_nonaq$max_p_update[i] <- 1
    }
}

# And having corrected the max_p_identity field, repeat clean up of taxon fields
tfill_nonaq$species[tfill_nonaq$max_p_identity < 97] <- NA
tfill_nonaq$genus[tfill_nonaq$max_p_identity < 95] <- NA
tfill_nonaq$family[tfill_nonaq$max_p_identity < 92] <- NA
### sum(!is.na(tfill_nonaq$order[tfill_nonaq$max_p_identity < 92])) #280 records with an order value but sim < 92
tfill_nonaq$order[tfill_nonaq$max_p_identity < 85] <- NA
# Leave genus values for now.

# Remove Unassigned records as agreed above
tfill_nonaq <- tfill_nonaq[tfill_nonaq$kingdom != "Unassigned",]  # reduced to 3648

```

Recompile final ASV_library tables, adding back in the non-macroinvertebrate, non-aquatic species removed before the above BOLD matches, adding a column "cw_checked" to identify those records that have been checked by the above processes (cw_checked = 1), and species excluded by the only_aqu_inverts() function (cw_checked = 0)

```{r}

# # MEL: We can combine the aquatic and non_aquatic tables when we are done, but I want to leave the aquatic separate while we are still working on cross-checking CHRIS2: no problem.
# Create a column flagging those aquatic records (checked by cw), and non-aquatic records (only partly checked by cw)
tfill$aqu <- 1
tfill_nonaq <- 0
# tfill <- rbind(tfill, tfill_nonaq[match(names(tfill),names(tfill_nonaq))])
# tfill_spp_bins <- rbind(tfill_spp_bins, tfill_nonaq_spp_bins)
# tfill_spp_bins_unq <- rbind(tfill_spp_bins_unq, unique(tfill_nonaq_spp_bins[c("species","bin_uri")]))

# And save the output xlsx to the data directory
wd <- "data/"
WriteXLS::WriteXLS(list(tfill = tfill,
                        bin_uris = tfill_spp_bins,
                        bin_uri_unq = tfill_spp_bins_unq),
                        ExcelFileName = paste0(wd, "asv_library_corrected.xlsx"))

```
