---
title: "Corrections_to_ASV_library"
author: "MCarew"
date: "2024-09-06"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Function equivalent to excel's =RIGHT() and =LEFT() functions
right <- function(x, n) {substr(x, nchar(x) - n + 1, nchar(x))}
left <- function(x, n) {substr(x, 1, n)}
```

## Introduction

This document amends the file 'asv_library_97_aug24.xlsx' [MEL: can you describe how this file was generated? Are there scripts or was it all in excel? CHRIS: The initial file was generated in excel] by:  
- adding records from subsequent miSeq runs [MEL: is this the right way to describe the origin of the addition records? CHRIS: The additional records not covered in the initial 'asv_library_97_aug24.xlsx ];
[MEL#2: I was hoping you would add text here with the aim of making this a document ready for publication/consumption by another audience, rather than just answer my question for me.  I don't really feel that another audience would understand how the source file was generated from your response...I note in your previous email that you went looking at another file called 'asv_library_97_aug24.csv'...I'm thinking that would have been a more appropriate source file to build this document from. But I think it's too late to do that now. But for next time you do an exercise like this: if the miSeq runs are the source of the data in 'asv_library_97_aug24.xlsx', then you should really have a code-based trail of how you build the excel file.  That is the sort of process I have been trying to produce here.  Anyway, on the next run through, can you please delete these comments here and provide some text describing the source of 'asv_library_97_aug24.xlsx' for a general audience]
CHRIS#2: I didn't use code to compile the file but if I did it again I would. This is the best way I can describe it for an outside audience.... "Vsearch output files containing taxonomic assignments for asv's from each miseq run were inspected for incomplete taxonomic classifications (truncated_fills), i.e., where a match of >97 max-p-identity was observed and no species name was assigned. This can occur when there are conflicting taxonomic classification for similar sequences in the reference database used by vsearch or specimens in the reference database have not been identified to species. These asv records meeting this criteria, were manually compiled into a excel spreadsheet. Each asv sequence was then checked against BOLD and in instances where BOLD did not return a match they were checked against GenBank. If additional taxonomic information was available this was added to the asv's taxonomic classification. For sequences with species matches on BOLD, but no species name was available, species names were constructed using their BOLD identifiers (bin_uri) combined with the lowest level classification on BOLD (see below). We also found errors where sequences classified >97 max-p-identity were not invertebrates but showed matches to fungi or endosymbionts for example, and some additional species not in vsearch the reference database. These were added to the asv records in a separate spreadsheet as the max-p-identity required updating (max-p-update)."

- correcting spelling errors in taxonomic names;

- looking up identifiers matching the sequences from boldsystems.org, naming un-named aquatic macroinvertebrate species using their BOLD identifiers (bin_uri), and grouping species with multiple bin_uris that overlap with >97% similarity

- recompiling the worksheets of 'asv_library_97_aug24.xlsx' and saving it as ''asv_library_97_jan25.xlsx'.

# Read in source data 

First, primary data from 'asv_library_97_aug24.xlsx' spreadsheets

```{r}
# read in files

source_path <- "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files/"
source_file <- "asv_library_97_aug24.xlsx"

# Read the sheets into as dataframes
tf0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
      sheet = "truncated_fills"))  

  # contains full taxonomic information for classifications with truncated taxonomy
otu_groups_df <- 
  as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                          sheet = "otu_groups", col_types = "text")) 
  # groups unclassified sequences into 'OTUs'
mp0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                                    sheet = "max_p_update"))
 # remove a duplicate record
mp0 <- mp0[!duplicated(mp0),]
  #updates/corrects any missing identifications or errors in classification

complexes_df <- readxl::read_excel(paste0(source_path,source_file),
                                       sheet = "complexes")

```

Then, additional data from:

- additions_asv_library_oct24.xlsx (additional records for truncated_fills); [MEL: can you describe where these additional records come from? CHRIS: These are records found after the 'asv_library_97_aug24.xlsx' was constructed] [MEL#2: As above - I was hoping you would just complete the document ready for others to read. And once again, I think others will need a little more explanation than that.] CHRIS#2: I'll have another go but it is messy as these records are ones that I found after running vsearch again after I found an problem in the code used to make the reference library. I not sure a reader needs to know this? Is this OK?... "Some additional asv records were found with incomplete taxonomic classifications after updating the vsearch reference libraries and re-running vsearch based taxonomic assignments. These records are to be added to the file asv_library_97_aug24.xlsx"

- asv_library_97_add_miseq15-20_records.csv (additional records for truncated_fills  from miSeq runs 15-20 with species identifications that match those in the above source tables for truncated_fills);

- filtered_<97_data.csv;

```{r}
# Additional truncated_fills records
tf1 <- as.data.frame(readxl::read_excel(paste0(source_path, 
                                               "additions_asv_library_oct24.xlsx"), 
                                        sheet = "trunc_fills")) 
tf2 <- read.csv(paste0(source_path, "asv_library_97_add_miseq15-20_records.csv"))[,-1]

# Combine the three truncated_fill source tables into a new table 
# (keeping all three original tables to permit back-checking)
truncated_fills_df <- rbind(tf0, tf1, tf2)

# Additional max_p_update records
mp1 <- read.csv(paste0(source_path, "filtered_97_data.csv"))
# update max_p_identify for those records with a corrected value
mp1$max_p_identity[!is.na(mp1$max_p_identity_corrected)] <- 
  mp1$max_p_identity_corrected[!is.na(mp1$max_p_identity_corrected)]
# [MEL: species names for those records are updated below - I have not used the 'recomended_species_name' field: see my email CHRIS: I have seen your e-mail and was unclear what the issue was?) [MEL#2: Look at the file ("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files/filtered_97_data.csv" - copying it to a local file before opening it in excel- The main problem was that there are no values after row 158 (I can't remember what the other problems were) - The whole point of my questions about this was to get you to confirm that I have used the right file: I suspect I haven't....anyway, if there are no other problems with this file, then I think this is ok, as I believe the code below correctly deals with the naming)] CHRIS#2: I see. The file is correct and I didn't provide recommend names after row 158 as I was happy with your names beyond this point. So you can understand what I have done.. I have given names to asvs with a max-p-identity above 90 based checking them against BOLD. Where there was additional taxonomic information available where I have suggested name changes, where there were matches consistent with genus (max-p-identity of 95-96), family (max-p-identity of 95-92), order (max-p-identity of 92-85). e.g. for asv 6a9ea49438ba346534d213bc5fa3412e Arthropoda (sp. Unident.) is a 96.8 match to Dinotoperla hirsuta so it would be more appropriately called Dinotoperla (sp. Unident.).

# Combine the source tables into a new table, but replace records in mp0 with those in mp1 where there are duplicates
max_p_update_df <- rbind(mp0[!mp0$asv_code %in% mp1$asv_code,], 
                         mp1[match(names(mp0),names(mp1))])

# Keep max_p_update_df records and remove matching records from truncated_fills
truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in%
                                           max_p_update_df$asv_code,]

truncated_fills_df[truncated_fills_df == ""] <- NA
max_p_update_df[max_p_update_df == ""] <- NA

# Check for duplicate asv_codes/sequences
sum(duplicated(truncated_fills_df$asv_code)) # 2 - not good
 # Remove the one complete duplicate
truncated_fills_df <- truncated_fills_df[!duplicated(truncated_fills_df),]
 # [MEL: you need to decide which of the following need to be removed. CHRIS: The duplicates are both truncated_fills_df and asv duplicated is 0a50789e3a9a9ee30d85a361ac7da535. Correct? The removed has a max-p-identity of 100. Not following below at this point?)
#[MEL#2: if you have run every line up to this point as I asked you to, all you need to do is run the next line and look at the resulting 2 lines to see the problem.  You need to decide which one needs to be deleted (neither have max-p-identity of 100)]
#[MEL#2: PS - I was really hoping you could run the code I have written here and start to see that the way I have coded it is easier to follow and check, and more reproducible than your original code] 
#CHIRS#2: I had run through the code here as you suggested but it was not clear to me at the time. I am sorry. I hope I have it right this time. The max-p-identity for  25e0eb7ec4e2897802c911efcfc806f5 is 99.3 when checked against the BarcodeID search engine on BOLD (as you have assumed below). The other match likely came from vsearch.


truncated_fills_df[duplicated(truncated_fills_df$asv_code) | 
                  duplicated(truncated_fills_df$asv_code, fromLast = TRUE),]
 # I have assumed the one with max_p_identity = 98.0 (Just change 99.3 to 98.0 if I have guessed wrong)
truncated_fills_df <- 
  truncated_fills_df[!(duplicated(truncated_fills_df$asv_code) & 
                        truncated_fills_df$max_p_identity == 99.3),]
sum(duplicated(c(truncated_fills_df$asv_code, max_p_update_df$asv_code))) # 0 - good

truncated_fills_df[truncated_fills_df$asv_code == "9ca9760013a77462d9c5e2c942e4d27e",
                   c("phylum","class","order","family","genus")] <- 
                c("Heterokontophyta","Oomycota","Peronosporales", "Peronosporaceae", "Phytophthora")

# [MEL#2: I have edited the code so that the three odd records are deleted in the next line.  Can you please write some explanatory text in a comment here for a general audience justifying these deletions: You said the following in your reply:  "there was something odd with these records so I revert to the taxonomic identifications given by vsearch (as I only produced the asv tables to correct errors). These records no species match on BOLD."] CHRIS#2: See below..
# Records were removed from the asv library with the original assignments made by vsearch. This was discovered after double checking assignments against BOLD and GenBank and finding no matches
truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in%
                                           c("9725daabf323ef5cf9b512ee0b06f682",
                                             "160985800d21d905b2e3dff1edc1bf18",
                                             "238f54c32343060e69613167f345dd15"),]
```

The truncated_fills_df and max_p_update_df are now complete with unique records from all source files (13613 and 1983 records respectively). To make corrections to taxonomic naming more efficient, the following combines the two tables for recompilation at the end of this document (using asv_codes to re-assemble the two tables).

Taxonomic corrections have been made only to aquatic macroinvertebrates, excluding non-aquatic, non-macroinvertebrate species using the function only_aqu_inverts() in bug_database_functions.R from the [mwbugs database website](https:://tools.thewerg.unimelb.edu.au/mwbugs/data_dl.html). In this document, the function reads from the table of exclusions (), which is a copy of the table of the same name in the mwbugs database.

Similarly to correct genus and family names in the library, we use the taxonomic tables from the mwbugs database.

```{r}
tfill_all <- rbind(truncated_fills_df, max_p_update_df)    # 15596 records

source("https://tools.thewerg.unimelb.edu.au/data/mwbugs/bug_database_functions.R")
# Record of how non_aqu_macroinvert.csv was created
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# non_aqu_macro_invert <- DBI::dbReadTable(db, "non_aqu_macro_invert")
# write.csv(non_aqu_macro_invert, 
#           "~/git/metabarcoding_workflow/data/non_aqu_macro_invert.csv", 
#           row.names = FALSE)
non_aqu_macro_invert <- read.csv("data/non_aqu_macro_invert.csv")

# Record of how taxonomy.xlsx was created, noting that when complete this can be read 
# directly from the mwbugs downloads page (not yet updated)
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# taxon_gen <- DBI::dbReadTable(db, "taxon_gen")
# taxon_fam <- DBI::dbReadTable(db, "taxon_fam")
# WriteXLS::WriteXLS(list(taxon_gen = taxon_gen, taxon_fam = taxon_fam),
#           "~/git/metabarcoding_workflow/data/taxonomy.xlsx")
taxon_gen <- readxl::read_excel("~/git/metabarcoding_workflow/data/taxonomy.xlsx", 
                                "taxon_gen")
taxon_fam <- readxl::read_excel("~/git/metabarcoding_workflow/data/taxonomy.xlsx", 
                                "taxon_fam")

tfill <- only_aqu_inverts(tfill_all, 
                          non_aqu_macro_invert_already_loaded = TRUE)$include #11,975 records
# And exclude two additional records only identified to phylum (Arthropoda and Zygomycota)
tfill <- tfill[!is.na(tfill$species),]  #11,973 records
tfill <- tfill[tfill$species != "Isopoda sp. MC-1",] #11,953 records

```

Note that tfill_all records excluded from tfill will be added unchanged to the final table at the end.

The term 'complex' in the asv_library is changed to 'group' to remove any implication of true taxonomic complexes in the grouping of species. Finally, spelling errors in the source data are corrected.

[MEL: Note that the following is a reduced version of your code chunks that corrected spelling.
      Note several major differences:
      1. Having (temporarily) reduced and combined the truncated_fills and maximum_p_update tables above, there is no need to duplicated these corrections as you had in your script
      2. The corrections are made line-by-line rather than being grouped into a single dplyr::mutate function.  This permits easier checking that each line a) is necessary and b) does what is intended.
      3. gsub() is used sparingly - only to make partial changes that are relevant to multiple species names. 
      4. Where a single species name is being replaced with a corrected name, it is better to use the approach I use after the gsub lines. By running the left hand side of each statement you can check if the change is necessary (several in your script weren't: the left hand side returned no records)]
      5. Corrections to B- codes are no longer done here- they are done more systematically later in the script ]
[MEL#2: You didn't respond to the above. I was hoping you would find this a useful explanation of the logic behind my changes, and a guide for making similar corrections in the future.  If you are happy with that (and happy with my logic, please feel free to delete these two comments)] CHRIS#2: Sorry for not responding. I did read youe comments and I was happy with your logic. I'll let you delete so you can see I have responded.

```{r}
# Keep a record of the original species name for checking later on.
tfill$species_old <- tfill$species
# Correct spelling errors
tfill$species <- gsub("  ", " ", tfill$species)
tfill$species <- gsub("Cricptopus", "Cricotopus", tfill$species)
tfill$species <- gsub("sp.B", "sp. B", tfill$species)
tfill$species <- gsub("GB-", "G-", tfill$species)
tfill$species <- gsub("ZB-", "", tfill$species)
tfill$species <- gsub("complex", "group", tfill$species)
tfill$species <- gsub("Iilliesoperla","Illiesoperla",tfill$species)

tfill$species[grep("Asmicridea edwardsi", tfill$species)] <- "Asmicridea edwardsii"
tfill$species[tfill$species == "Chironomidae sp. B-ABX4803"] <- "Chironominae sp. B-ABX4803"
tfill$species[tfill$species == "Chironomidae sp. B-AEE9278"] <- "Orthocladiinae sp. B-AEE9278"
tfill$species[tfill$species == "Dero obtusa"] <- "Dero obtusa/nivea"
tfill$species[tfill$species == "Lingora aurata"] <- "Lingora aurata group"
tfill$species[tfill$species == "Limnodrilus claparedeanus"] <- "Limnodrilus claparedianus"
tfill$species[tfill$species == "Antiporus gilbertii"] <- "Antiporus gilberti"
tfill$species[tfill$species == "Austrolimnius waterhouseii"] <- "Austrolimnius waterhousei"
tfill$species[tfill$species == "Culicoides bundyensi"] <- "Culicoides bundyensis"
tfill$species[tfill$species == "Hyderodes shuckardi"] <- "Hyderodes schuckardi"
tfill$species[tfill$species == "SImsonia longipes"] <- "Simsonia longipes"
tfill$species[tfill$species == "Musculium sp. B-ADJ8477"] <- "Sphaerium sp. B-ADJ8477"
tfill$species[tfill$species == "Dinotoperla aff. thwaitesi"] <- "Dinotoperla thwaitesi group"
tfill$species[tfill$species == "Austropyrgus centralia group"] <- "Austropyrgus centralia/turbatus"
tfill$species[tfill$species == "Centroptilum sp. B-ACM3150"] <- "Centroptilum elongatum"
tfill$species[tfill$species == "Hydraenidae sp. B-ADK5039"] <- "Gymnochthebius australis"
tfill$species[tfill$species == "Helicophida queenslandensis"] <- "Helicopha queenslandensis"
tfill$species[tfill$species == "Riethia zeylandica"] <- "Riethia sp. B-ADU5431" 
tfill$species[tfill$species == "Notalina bifara group B-ABV8023"] <- "Notalina bifara"
tfill$species[tfill$species == "Notalina sp. B-AAX5636"] <- "Notalina bifara"
# [MEL: Perhaps you want to call this "Notalina bifara group"? (the two bin_uris overlap...you had originally called this "Notalina bifara  B-ABV8023 group"!) CHRIS: That's fine.] [MEL#2: Note that the code calls it Notalina bifara - are you happy with that, or do you want it called "Notalina bifara group"?] CHRIS#2: Can we call it Notalina bifara group.
tfill$species[tfill$species == "Ferrissia sp. MC-1"] <- "Ferrissia sp. B-AAE6642"

# [MEL: the spelling corrections in your Appendix 2 of species with B- names are taken care of automatically below.
#       Some have ended up using different bin_uris than their original names, but I don't think this matters (the 
#       changes can be tracked easily using the species_old field).  One of your original changes doesn't seem right
#       ...unless I've made a mistake somewhere...
# tfill$species[tfill$species == "Trinotoperla sp. complex B-ABX3905"] <- "Trinotoperla sp. B-ABX3905 group"
#  ...as far as I can tell, there is no other bin_uris overlap with ABX3905
# CHRIS: One BIN but many names Trinotoperla nivata, Trinotoperla montana, Trinotoperla minor, Trinotoperla sp. Group A, Trinotoperla sp. JMH879, hence why 'group' was added. How do you want to deal with this?]
# [MEL#2: If you run the code down to the commented out line that starts with "# ABX3905 "Trinotoperla nivata" (4)" (line 900 and something, liable to change), then there are only three names listed in the asv_library file ("Trinotoperla montana", "Trinotoperla sp. B-ABX3905 group", "Trinotoperla sp. group B-ABX3905"). I don't really mind what we call it: your call! Let me know (here) and I'll change the code accordingly] CHRIS#2: can we call all "Trinotoperla sp. B-ABX3905 group"
```

The following was run using the bold package V1.3.0 to download from the boldsystems API  before their upgrade at the end of 2024. The script thus includes steps to allow for errors arising from exceeding download quotas from bold.  It involves two steps:

- First, match_list is a list of tables, each table the complete list of matching  BOLD records to the asv_sequence in the input data (using the function bold_identify).  The name of each table in the list is the asv_code.

- Second, match_list_bin_uri is a list of tables with same names as those in match_list but each table is reduced to include only those records that are >=97% similar to the asv_sequence. The function bold_specimens() is then used to extract the 
bin_uri for each BOLD ID.  

It is likely that the new API will not require the steps to work around errors or the two-step process for extracting bin_uris.
The process was error free using RStudio 2024.09.0 (Each step took ~30 h to  extract data for 10,000 asv records), but failed many times, requiring restarting of the loop in both steps, using RStudio Server 2023.03.02

The following chunk is step 1, saving the full list of BOLD matches (each with name = asv_code) to "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library_97_match_list_to_BOLD_2024-12-05.rda".

[MEL: when we have finalised this, we need to place big files such as these match_list files in a repository, and then re-write this script to allow users to download and use them. I can help you do this. (Note for me later on - example code at L20 of https://github.com/cjbwalsh/urban_riffle_experiment/blob/master/urban_riffle_exp_figs_code.qmd)]
[MEL2: Let's leave these comments here for now until the final version, and I can have a final go] CHRIS#2: Thank you. 

The chunk is set not to evaluate, as it took ~30 h to run.

[MEL: Don't run this chunk!] [MEL#2: Just another reminder in case you are running through the code again...can be deleted when we are happy] CHRIS#2: OK

```{r eval:FALSE}

match_list <- list()

# Download all matching records from bold for each asv record 
for(i in 1:nrow(tfill)){  
  # ran without error on RCP server in a single process (taking ~30 h)
  seqi <- tfill$asv_seq[i]
  # The BOLD server returns an error if it is being overloaded
  # Here I handle this with the retry function
  matchi <- retry::retry(bold::bold_identify(seqi, db = "COX1"),
                         when = "NULL", max_tries=12, interval= (5 * 60 + 1))
  # Name each list element by asv_code (which should remain unchanged)
  names(matchi) <- tfill$asv_code[i]
  match_list <- c(match_list, matchi)
  # Save a working copy and report progress every 100 iterations.
  if(i %% 100 == 0)  
    cat(i, as.character(Sys.time()),"\n")
  save(match_list, file = paste0("~/temp/match_list_rerun.rda"))
}

# Saved to same folder as asv data source files with datestamp to avoid over-writing
save(match_list, file = 
       paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_to_BOLD_", Sys.Date(), ".rda"))
```

The following chunk then reduces each match_list table to those records with >=97% similarity and extracts their bin_uris, saving them as a second list of tables with fields: ID, taxonomicidentification, similarity, specimen_country, bin_uri.

The list was saved as "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library_97_match_list_with_bin_uris2024-12-05.rda".

[MEL: Note that the name of each table allows matching back to the original asv tables (via the asv_code field), and the ID field in each table allows matching back to the BOLD records saved in the match_list list tables.]

As above, the chunk is set not to evaluate, as it also took ~30 h to run.

[MEL: Don't run this chunk either!] [MEL#2: Just another reminder in case you are running through the code again...can be deleted when we are happy] CHRIS#2: OK

```{r eval:FALSE}

match_list_bin_uri <- list()

system.time({
  # ran without error on RCP server in a single process (taking ~30 h)
  for(i in 1:length(match_list)) { 
        matchi <- match_list[[i]][match_list[[i]]$similarity >= 0.97,
                                  c("ID","taxonomicidentification","similarity","specimen_country")]
        # If there are no sufficiently similar BOLD records, create a blank record
        if(nrow(matchi) == 0){
          matchi <- data.frame(ID = NA, taxonomicidentification = NA,
                               similarity = NA, specimen_country = NA,
                               bin_uri = NA)[0,]
        }else{
          # Otherwise use the bold_specimens function to extract the bin_uri for each record.
          if(nrow(matchi) <= 50) {
            bini <- bold::bold_specimens(ids = matchi$ID) #seqspec
          }else{
            # If there are more than 50 sufficiently <- similar records, break it into lots
            # of 50 or less so as not to overload the BOLD API
            J <- c(which(1:nrow(matchi) %% 50 == 0),nrow(matchi))
            for(j in 1:length(J)){
              indJ <- ifelse(j == 1, 1, J[j - 1] + 1):J[j] 
              binj <- bold::bold_specimens(ids = matchi$ID[indJ])
              Sys.sleep(1)
              if(j == 1){
                bini <- binj
              }else{
                bini <- rbind(bini, binj)
              }
            }   
          }
          # The bold_specimens function returns a warning if the BOLD API quota is 
          # exceeded. Catch this warning and wait up to 70 minutes (trying every 5 min) 
          # until the API begins accepting requests again.
          if(grepl("exceeded",names(bini)[1])){
            cat("BOLD retrieval quota exceeded: pausing process at i =", i,"\n")
            tries <- 1
            retry_time_seconds <- c(61,4)*60
            while(grepl("exceeded",names(bini[1])) & tries <= 2){
              Sys.sleep(retry_time_seconds[tries])
              if(nrow(matchi) == 0){
                matchi <- data.frame(ID = NA, taxonomicidentification = NA,
                                     similarity = NA, specimen_country = NA,
                                     bin_uri = NA)[0,]
              }else{
                # Otherwise use the bold_specimens function to extract the bin_uri for each record.
                if(nrow(matchi) <= 50) {
                  bini <- bold::bold_specimens(ids = matchi$ID) #seqspec
                }else{
                  # If there are more than 50 sufficiently similar records, break it into lots
                  # of 50 or less so as not to overload the BOLD API
                  J <- c(which(1:nrow(matchi) %% 50 == 0),nrow(matchi))
                  for(j in 1:length(J)){
                    indJ <- ifelse(j == 1, 1, J[j - 1] + 1):J[j] 
                    binj <- bold::bold_specimens(ids = matchi$ID[indJ])
                    Sys.sleep(1)
                    if(j == 1){
                      bini <- binj
                    }else{
                      bini <- rbind(bini, binj)
                    }
                  }
                }
              }
              cat("...for", cumsum(retry_time_seconds[1:tries])[tries]/60, "minutes")
              tries <- tries + 1
            }
          }
          # A very small number of bini get returned with no header row.
          # This is a work around for them
          if(names(bini)[1] != "processid"){
            stop("2: missing header row?")
            bini <- bini[,c(1,grep("BOLD",names(bini)[1]))]
            lostline <- names(bini)
            names(bini) <- c("processid","bin_uri")
            bini <- rbind(data.frame(processid = lostline[i],bin_uri = lostline[2]),
                          bini)
          }
          bini <- bini[,c("processid","bin_uri")]
          matchi$bin_uri <- gsub("BOLD:","",bini$bin_uri[match(matchi$ID,bini$processid)])
          # add the reduced table with bin_uri to match_list_bin_uri
        }
        match_list_bin_uri <- c(match_list_bin_uri,list(matchi))
        if(length(match_list_bin_uri) != i ) stop("1")
        names(match_list_bin_uri)[i] <- names(match_list)[i]
        # Save a working copy and report progress every 100 iterations.
        if(i %% 100 == 0){
          save(match_list_bin_uri, 
               file = paste0("~/temp/match_list_bin_uri.rda"))
          cat(i, as.character(Sys.time()),"\n")
        }
      }
    })  
    
# Saved to same folder as asv data source files with datestamp to avoid over-writing
save(match_list_bin_uri, file = 
       paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_with_bin_uris_", Sys.Date(), ".rda"))

```

Some ad-hoc changes to provisional species names can be made without recourse to the BOLD database.  They are made here first.

```{r}

tfill$species[tfill$species == "Austrochiltonia sp. MC-1"] <- 
                                                 "Austrochiltonia australis"
tfill$species[tfill$species == "Culicoides sp. MC-24"] <- 
                                                      "Culicoides sigmoidus"
tfill$species[tfill$species == "Limnophyes sp. MC-A1"] <- 
                                                  "Limnophyes sp. B-ABW5528"
tfill$species[tfill$species == "Limoniidae sp. MC-1"] <- 
                                                   "Limnophilinae sp. B-ABW2416"
tfill$species[tfill$species == "Limoniidae sp. MC-2"] <- 
                                                   "Limnophilinae sp. B-ABX1292"
tfill$species[tfill$species == "Isopoda sp. B-ACG3222"] <- 
                                                  "Sphaeromatidae sp. B-ACG3222"
```

[MEL: here are some comments on changes in your earlier Appendix 2. FYI. This chunk can be deleted if you are happy CHRIS: Not sure what you mean here? Are these errors are addressed elsewhere so this chunk can be deleted?] 
[MEL#2: Perhaps you could check what I've done manually for each of these: I'm not 100% sure I haven't made errors...for instance, I checked the first correction from your original Appendix 2 (after running the whole script to the bottom, so that we have a final, corrected version of tfill) by running this code 
tfill[tfill$asv_code == "b167c9e6e63d586c8f79138f640da0cb",]
The result suggests that your correction of the family of that asv_code to Eustheniidae is incorrect. 
I suggest you run a similar line for each of the asv_codes in the chunk below to assess if my tfill is correct]
CHRIS#2: I have checked the tfill for the asv's in the chunk below
b167c9e6e63d586c8f79138f640da0cb is Eustheniidae	Eusthenia Eusthenia sp. B-ABX4126 (not Dinoperla) so all the genus and species fields also require correction
9ca9760013a77462d9c5e2c942e4d27e is Heterokontophyta	Oomycota	Pythiales	Pythiaceae		Phytophthora	according to BOLD. It appears different order and family names are used on BOLD for the same genus to what have below. If we want to be consistent with BOLD we should change the order and family names in the code below. Also the sequence has multiple species matches. I sugeest it might be best if we add code to leave the species blank as we will be excluding this data.
d54cf91de2a56cbde204c32eea369742 is correct as Fridericia sp. B-ADR5065
a3b763c11784ab20ccb6053c998cd0e4 is correct as Leptophelbiidae Ulmerophlebia Ulmerophlebia sp. B-ABV8830. However, the max-p-identity is 100 on BOLD not 97
b0c8e99497b5ab0e503fa633d238f220 is correct as Zavrelimyia sp. B-AEN0522/AEN0524

```{r}
asv_family_corrections_tf <- c("b167c9e6e63d586c8f79138f640da0cb" = "Eustheniidae",
  # taken care of automatically below.
"9ca9760013a77462d9c5e2c942e4d27e" = "Peronosporaceae")
  # not aquatic - changes added above...as are the following three lines)
asv_order_corrections_tf <- c("9ca9760013a77462d9c5e2c942e4d27e" = "Peronosporales")
asv_class_corrections_tf <- c("9ca9760013a77462d9c5e2c942e4d27e" = "Oomycota")
asv_phylum_corrections_tf <- c("9ca9760013a77462d9c5e2c942e4d27e" = "Heterokontophyta")

# The following not necessary - captured automatically below (but correction to 
# Ulmerophlebia genus (from Ulmerochorema) name added below)
asv_species_corrections_mpu <- c("d54cf91de2a56cbde204c32eea369742" = "Fridericia sp. B-ADR5065",
                             "a3b763c11784ab20ccb6053c998cd0e4" = "Ulmerophlebia sp. B-ABV8830",
                             "b0c8e99497b5ab0e503fa633d238f220" = "Zavrelimyia sp. B-AEN0522/AEN0524")
                             # Update the species column based on asv_code matching the correction vector
# As above, correction to Ulmerophlebia in genus field captured below 
asv_genus_corrections_mpu <- c("a3b763c11784ab20ccb6053c998cd0e4" = "Ulmerophlebia")
# And correction to family field also updated automatically (with correct spelling, as opposed to this)
asv_family_corrections_mpu <- c("a3b763c11784ab20ccb6053c998cd0e4" = "Leptophelbiidae")
# And this change to max_p_identity added to asv_list in next chunk
asv_max_p_identity_corrections_mpu <- c("a3b763c11784ab20ccb6053c998cd0e4" = "97")
```

# add corrections to revised matches  
[MEL: I'm not crazy about this matching by asv_codes, but I don't understand enough about these changes to revise them in a safer way.
Can you tell me where you got these values from? CHRIS: from checks against BOLD or GenBank.
I've left them as they are, but have changed the code for making the changes from dplyr to base code]
[MEL#2: As above - It would be good if you included some short explanatory text here to explain the logic of what's going on here; I can't help but think there must be a more transparent way to have made these changes...but let's just go with it. Please delete these two comments when you've added some text.] CHRIS#2: see below
```{r}
# some asv's produced different max-p-identities when sequences were directly compared to the BOLD or GenBank databases. As these changed the assignment of species in some cases we chose to adjust these identification max-p-identities to be consistent with BOLD and GenBank.In most cases this result in courser levels of taxonomic assignment
max_p_identity_corrections <- c("9e5035bf7ec6a1f2c651ed0e98ed2da7" = "96.6",
"d453f558117b6d43a6d2feafbd877e0e" = "96.4",
"5ec678fc07a30a88297abe1aa71a4ead" = "96.5",
"d32a5e240858359c1bd7d6ebde67fe5b" = "96.5",
"314b908770c6f9c296aaab2da5698807" = "96.7",
"81530c1415a28a9a62322a482d714cef" = "94.6",
"3dc52e2c7a31e2a01a84549b92911bcb" = "95",
"f0e1b9af3b6dbb9a5afc88807a33f535" = "95",
"aa465397725596f1c084e4e48197372d" = "96",
"155515de679ea3f96eb251597a8355f5" = "96",
"7e9db264fabad9a9b2ac755cc524baa3" = "96.7",
"66c7e7bc806cfca10de70609b1ae1117" = "96.5",
"7abdbe52662941a5b1d6956f74fc8ccf" = "96.7",
"fb92efc10fba6e13b30c4e20f3f4be70" = "96.7",
"d971c3c25d994549e1ab94b17048486a" = "96.4",
"2a8674533aa6463808dced5102f0a1e5" = "96.5",
"384f60818615b4dc43d21b4fde820d21" = "96.4",
"2a09b204ea25d3ee0c23b26d00822dcf" = "96.4",
"c3ef326630a4b7eee124b7f4aa844cd6" = "96.4",
"3ea037839cc56c6adab4409ca544f57a" = "96",
"5fa5b580d9fb1c0503c5b4d05ce567e0" = "96.4",
"f2700c9ffaef418a7a9823b08b2b83c9" = "96.8",
"6a9ea49438ba346534d213bc5fa3412e" = "96.8",
"693405ffa22eb11c8a4302db0e8b6b7e" = "96.8",
"edc9cb8e69fe75af9826b60ecbc8f39b" = "96.8",
"a06bcf800ab074457f826c9026d93a05" = "96.8",
"60b0c55b3de6bcf0a4a4d4f2485a7ff7" = "90",
"c648f0859a67b40edf948409b8a4967a" = "90",
"bb9f84db19013052915d3b1ac559f11f" = "90",
"c3a2b4cfa3238dd8f6e5bf800290fd05" = "93",
"c56010a8847101c6f955be8758ba6963" = "95",
"f4c35e10c8e86a6dcee244a349473149" = "95",
"0bcf51bb494deb438b90e3e956a645bb" = "95",
"17edbbd11bdd22030c71999c0ed07036" = "95",
"2aadb65453c6df2420448394917cbc2f" = "95",
"94dda310e20d3e23a2752787a41a30f3" = "96",
"cb50aead3ff372183a06f8d09c03ef86" = "96.7",
"48b5d8e5472a2cf15d8acf17bfe90ccc" = "96.5",
"aad7ed86c3f30cfe5ee5bf4b8226d159" = "96.7",
"8ef04e58e9a04a7345c1310b8cc48b58" = "96",
"e64a94ea4d2c5000abac84231068b15b" = "96.5",
"65b850c96c49333ef25d783db98a5f9d" = "96",
"20c0f2c414bc8b2ff71a32ef4a6da942" = "96",
"4ff6a29cd87280c79d609ba2690b9b92" = "92",
"50a1d897e621e2dbb170bc4a7d206319" = "96",
"91162e539c973809dfa49f065bcb46c2" = "92",
"a3b763c11784ab20ccb6053c998cd0e4" = "97")

max_p_identity_corrections <- data.frame(asv_code = names(max_p_identity_corrections),
                                         max_p_identity = as.numeric(max_p_identity_corrections))
for(i in 1:nrow(max_p_identity_corrections)){
  if(!max_p_identity_corrections$asv_code[i] %in% tfill$asv_code) stop("") # didn't stop, so all in tfill
  tfill$max_p_identity[tfill$asv_code == max_p_identity_corrections$asv_code[i]] <- 
                      max_p_identity_corrections$max_p_identity[i]
}
# sum(!max_p_identity_corrections$asv_code %in% max_p_update_df$asv_code) #0
```

The following chunk creates a new table of asv_codes, species names, and their bin_uris. Many asv_codes have multiple bin_uris, so this table is longer than tfill. (15,939 rows rather than 11,979).

```{r}
# load list "match_list_bin_uri", compiled in the chunk above
load(paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_with_bin_uris_2024-12-15.rda"))
# And load "match_List" - the full list of matching records to BOLD (not limited to >0.97 similarity)
load(paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_to_BOLD_2024-12-15.rda"))

# There are 60 asv_codes in the match_lists that aren't in tfill...not sure of their origin
# Exclude them here
match_list_bin_uri <- match_list_bin_uri[match(tfill$asv_code, names(match_list_bin_uri))]
match_list <- match_list[match(tfill$asv_code, names(match_list))]

# Create a tfill_spp_bins, which lists all bin_uris associated with each asv_code
tfill_spp_bins <- data.frame(asv_code = names(match_list_bin_uri),
                             species = tfill$species[match(names(match_list_bin_uri), tfill$asv_code)],
                             bin_uri = NA)
for(i in 1:nrow(tfill_spp_bins)){
  tfill_spp_bins$species[i] <- tfill$species[tfill$asv_code == names(match_list_bin_uri)[i]]
}

for(i in 1:nrow(tfill_spp_bins)){
    bins <- match_list_bin_uri[[i]]$bin_uri
    bins <- bins[!is.na(bins) & !bins == ""]
  if(length(unique(bins)) == 0){
     next()
    }else{
    tfill_spp_bins$bin_uri[i] <- unique(bins)[1]
    if(length(unique(bins)) > 1){
      tfill_spp_bins <- rbind(tfill_spp_bins, 
                              data.frame(asv_code = names(match_list_bin_uri)[i],
                              species = tfill$species[tfill$asv_code == names(match_list_bin_uri)[i]],      
                              bin_uri = unique(bins)[-1]))
    }
    }
}

tfill_spp_bins <- tfill_spp_bins[order(tfill_spp_bins$species),]
tfill_spp_bins$bin_uri <- gsub("BOLD:","",tfill_spp_bins$bin_uri)

```

Species without a formal name are given a name based on their BOLD identifiers (bin_uri).  Species that have two bin_uris are given a name containing both bin_uris separated by a slash (/).  Species that have more than 2 bin_uris are given the name of one of the bin_uris followed by "group".  The following chunks renders those names. 

The first chunk ensures that the first word of the name (usually genus, but potentially a higher taxonomic level) are correct, first by making manual corrections using the BOLD database and taxonomic identifications of specimens.

[CHRIS: DON"T FORGET TO PUT THE MATCH LIST SCRIPT IN!]

```{r}
# tfill_bu <- tfill
# tfill_spp_bins_bu <- tfill_spp_bins
# tfill <- tfill_bu
# tfill_spp_bins <- tfill_spp_bins_bu

tfill$species_old <- tfill$species

# Some records named Sphaerium not correct (Set species to "" for those without a bold match)
for(i in grep("Sphaerium", tfill$species)){
  if(nrow(match_list_bin_uri[[tfill$asv_code[i]]]) == 0){
    tfill$genus[i] <- NA
    tfill$species[i] <- "Pisidiidae sp. (Unident.)"
  }else{
    # Make sure we're dealing with just Sphaerium sp. B-ADJ8477
    if(!"ADJ8477" %in% match_list_bin_uri[[tfill$asv_code[i]]]$bin_uri) stop()
    tfill$genus[i] <- "Sphaerium"
  }
}

# An unidentified naididae previously classed as Limnodrilus hoffmeisteri should be Naididae sp. B-ADJ9699
naid_asvs <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "ADJ9699"]
tfill$genus[tfill$asv_code %in% naid_asvs] <- NA

# [MEL: the above (and the subsequent check and update of genus names) does the 
#  job of your asv_code chunk changing genus names. 
# See "unravel_asv_code_changes.R". Note that I have aimed to ensure that the code 
# in this document makes all of the changes in your original code chunks. However, 
# there were three changes that you made that I cannot verify (or understand). 
# Can you check these please? CHRIS: All errors. 51bb3b643e6c884ac72e340348a32c33 the nearest BIN is ACG8949 so this name should not be changed; d67b66092a6572d57ac7290d21ef39c4 should remain Coloburiscoides sp. B-ADW5046; 19661209bd3d6750ef55e93b6f8f400b is closest to BIN AAE6642)
# [MEL#2: OK. I think I understand where you're coming from here.  I re-ran my <<bold::bold_identify(seqi, db = "COX1")>> code above for the first of these ("51bb3b643e6c884ac72e340348a32c33"), and confirmed that it returns no matches.  I then went to the bold web interface and also see no match, but with the supplementary information of Ablabesmyia sp. GRM1.1 having 96.02% similarity to the sequence. But its bin_uri is AEN3809! And even if AAP5135 was right, I don't think it is appropriate to then call an approximate match "Ablabesmyia sp. B-AAP5135": presumably this sequence would be given a new bin_uri when submitted to BOLD." I think it would be more appropriate to call it something like Ablabesmyia sp. MC-1 for now. What do you think? If you agree, can you check the other two and confirm an appropriate name for them?] CHRIS#2: When I check 51bb3b643e6c884ac72e340348a32c33 on the Barcode ID, I get a match of 97.44 to Ablabesmyia sp. NSW17YH8 (ACG8949) not sure what is happening here?

# #                             asv_code                        new_species                   species_old         bold_species bin_uri n_bins del
# 158 51bb3b643e6c884ac72e340348a32c33          Ablabesmyia sp. B-AAP5135     Ablabesmyia sp. B-ACG8949                 <NA>    <NA>      0   0
# 159 d67b66092a6572d57ac7290d21ef39c4           Coloburiscoides munionga Coloburiscoides sp. B-ADW5046                 <NA>    <NA>      0   0
# 212 19661209bd3d6750ef55e93b6f8f400b            Ferrissia sp. B-AAY1880            Ferrissia sp. MC-1                 <NA>    <NA>      0   0
# Note your code changed the given asv_code from old_species to new_species. 
# None of these three had a matching bold record for me to assess their veracity]

# And the following are changes in part from your asv_code chunk changing species names
bold_name_corrections <- 
c("AAE9243" = "Cheumatopsyche alampeta",
"ACG2503" = "Coloburiscoides munionga",
"ACV9482" = "Cricotopus tasmania",
"ABX3893" = "Illiesoperla mayi",	
"ACG1875" = "Rhadinosticta simplex",
"ADJ8523" = "Limnodrilus hoffmeisteri",
"AEI0789" = "Procorticacarus victorianus",
"ABV8829" = "Ulmerochorema onychion",
"AAU4648" = "Psychoda gemina",
"ACV9482" = "Cricotopus tasmania",
"AAT8936" = "Cognettia chlorophila/sphagnetorum",
"AAF0821" = "Tanytarsus fuscithorax",
"ACB6471" = "Chaetogaster diastrophus",
"ABX5220" = "Austrosimulium furiosum",
"ABY8640" = "Lingora aurata",
"AAW2994" = "Austrheithrus glymma",
"ACD5693" = "Dinotoperla thwaitesi",
"ABX4166" = "Dinotoperla walkeri/evansi",
"ABV8830" = "Ulmerophlebia sp. B-ABV8830", # included here because genus was wrong in library
"AAW4309" = "Cardiocladius sp. B-AAW4309", # included here because genus was wrong in library
"ADJ0699" = "Byrrocryptus sp. B-ADJ0699", # late genus-level id
"ACV9616" = "Bothrioneurum vejdovskyanum",
"AAX5275" = "Bothrioneurum vejdovskyanum",
"ACI5239" = "Bothrioneurum vejdovskyanum")

bnc_df <- data.frame(bin_uri = names(bold_name_corrections), 
                       new_species = bold_name_corrections)
for(i in 1:nrow(bnc_df)){
  asvcodei <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                                        tfill_spp_bins$bin_uri == bnc_df$bin_uri[i]]
  tfill_spp_bins$species[tfill_spp_bins$asv_code %in% asvcodei] <- 
                                                    bnc_df$new_species[i]
  tfill$species[tfill$asv_code %in% asvcodei] <- bnc_df$new_species[i]
  
}

chamaedrilus_asv_codes <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri %in% c("AAT9499","AAT9501","ACQ1237","AAU1095")]
tfill_spp_bins$species[tfill_spp_bins$asv_code %in% chamaedrilus_asv_codes] <- "Chamaedrilus varisetosus"
tfill$species[tfill$asv_code %in% chamaedrilus_asv_codes] <- "Chamaedrilus varisetosus" 

cognettia_asv_codes <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri %in% "AAT8936"]
tfill_spp_bins$species[tfill_spp_bins$asv_code %in% cognettia_asv_codes] <- "Cognettia chlorophila/sphagnetorum"
tfill$species[tfill$asv_code %in% cognettia_asv_codes] <- "Cognettia chlorophila/sphagnetorum" 

# "Hydrobiosella waddama" and "Hydrobiosella perangusta" are distinct except for 
# asv_code cf4d8b16cb64eb29dd6eb8aeff774878, which has similarity >0.985 with 
# Hydrobiosella waddama AAZ5125 and similarity 0.9706 to one record of AAZ4813...
# just over the criterion.  Sufficiently different to keep separate. Thus:
tfill_spp_bins$bin_uri[(tfill_spp_bins$species == "Hydrobiosella waddama" & 
                     tfill_spp_bins$bin_uri == "AAZ4813")] <- "AAZ5125"

# Add "Nais variabilis" to "Nais communis group"
tfill$species[tfill$species == "Nais variabilis"] <- "Nais communis group"
tfill_spp_bins$species[tfill_spp_bins$species == "Nais variabilis"] <- "Nais communis group"

# Check and correct family names, requiring the taxon_gen and taxon_fam tables from mwbugs
# [MEL: Are you happy to use the mwbugs taxonomy to correct the genus and family fields in tfill?
# I will make these tables accessible in the final version...] CHRIS: OK. but there may be some inconsistency between these names and those on BOLD/GenBank. [MEL#2: I suspect there it will only be a small number of inconsistencies. If you can identify what those are, we can easily code a translator for the next stage if necessary. Let me know. If you are happy to proceed with this as it is, then please delete this group of comments] CHRIS#2: Some that I know of are Telephlebiidae (predominately Austroaeschna) - Aeshnidae (on BOLD), Pisidiidae - Sphaeriidae (on BOLD) and , Nanophyidae - Brentidae (on BOLD for ADD0490). Happy to delete comment 

## Check genus and family fields throughout the table ensuring: 
## a) the genus name matches the first word of the species name (or is blank if 
##     the first word is a higher taxonomic level)
## b) the family name is the correct family for the given genus (or species name
##     if the species name is not a genus) [CHRIS: The step below does not work for me. I suspect I have had this problem before. Added a revised version suggested by you a while back which worked (# out)]
db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
#db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs", host = "localhost", user = "readonly", password = "reachcode_42")
taxon_gen <- DBI::dbReadTable(db, "taxon_gen")
taxon_fam <- DBI::dbReadTable(db, "taxon_fam")
# ]
tfill$genus_old <- tfill$genus
tfill$family_old <- tfill$family
tfill$genus_recode <- 0
tfill$family_recode <- 0
# Remove duplicated species names from family, genus, order
tfill$order[!is.na(tfill$order) & tfill$order == tfill$species] <- NA
tfill$family[!is.na(tfill$family) & tfill$family == tfill$species]  <- NA
tfill$genus[!is.na(tfill$genus) & tfill$genus == tfill$species] <- NA

# sum(grepl("Unident.", max_p_update_df$species))  #198
## 198 records without a species name (all from the max_p_update table)
## The following gives them species names using their lowest identified taxonomic level
# [MEL: The following assumes that the "class","order","family","genus" details  are correct. Is that right? CHRIS: Yes. This is right. I can't quite make sense of the bit below. Sorry. Which data should I be looking at? [MEL:  Once again, if you have run all the lines up to this point.  You could have just run the commented-out lines (e.g. just select the line containing <<tfill[grep("Unident.", tfill$species),3:8]>> leaving out the leading # ) to inspect the results. To make it easier, I have uncommented out the lines I suggested that you run.] CHRIS#2: I think I've got it this time. I hope. So, if I look at 693405ffa22eb11c8a4302db0e8b6b7e agianst BOLD Barcode ID you get a max-p-identity of 97.56 to Arthropoda	Insecta	Plecoptera	Gripopterygidae	Dinotoperlinae	Illiesoperla	Illiesoperla mayi. When you tried this via API (match_list_bin_uri) you get no match? From what I am seeing if the threshold for a match is 97 we should have a match. Maybe the particular record that matches is not available via the API?

#        Some of these look odd also: e.g. several have a species name in the genus column...I deal with those first...
#        But you might want to look at them yourself...try this code (with Chunk output set to in console: cog menu above]
    tfill[grep("Unident.", tfill$species),3:8]
#   One example I'm suspicious about is grep("Unident.", tfill$species)[7] # = 11776
#   Genus = Illiesoperla mayi and the following script makes that the species name also,  see  - 
  tfill[grep("Unident.", tfill$species)[7],]
#   But the asv_code 
  match_list_bin_uri$`693405ffa22eb11c8a4302db0e8b6b7e` 
  # doesn't match anything in BOLD
#   even though all other Illiesoperla mayi records match bin_uri ABX3893.
#   Another dodgy looking one is 5148a3678b70de5db884a99af7734de4 - order Trombidiformes, genus Sarcoptiformes.. CHRIS#2: This has likely come from a coding error by me. There should be nothing in the genus field and the order is Sarcoptiformes
#   I'll just delete that one here, because it makes the following script fall over
tfill <- tfill[tfill$asv_code != "5148a3678b70de5db884a99af7734de4",]
tfill_spp_bins <- tfill_spp_bins[tfill_spp_bins$asv_code != "5148a3678b70de5db884a99af7734de4",]
#[MEL:   Is it possible you have been writing over the source max_similarity_update table in excel?  You really need to quarantine the
#   source table somewhere where it's not going to be written over (somewhere you will never open it in excel and never overwrite it from R)
#   That's why I've moved the source tables that this script reads into a separate out-of-the-way folder. PLEASE do not open any of those files in Excel. CHRIS: I don't know what you mean here. I don't think I wrote over a source table/file?
#[MEL#2: Well the fact that the max_p_update species names have changed from containing many "" values to containing many values ending in "Unident.)" since the first time I wrote code to work with "asv_library_97_aug24.xlsx" suggests that changes have been made: this is related to my earlier comment that perhaps this file should be starting with the csv version of that file.  But as I said before, I think it's too late to do anything about this, but to move on using your final edited xlsx version]
#   Best to inspect them in R (or if you MUST look at them in Excel, copy them to a different local directory and open them up from there.)
#  Is there a more direct source for these data than an excel file you are adding to manually? If so, I'd be happy to work with you on a coding approach to using your direct data source to update your library tables.
# CHRIS#2: I'm sorry but I don't believe I wrote over the source files?? I'm not sure how I could. I did not add any "Unident.)" to any names with code or otherwise with the exception of the 'recomended_species_name' in the filter_97_data, which I made in excel. 
#   HERE IS ONE CORRECTION TO THESE ARISING FROM YOUR EMAILS...(An enchytraeid listed as a Dytiscid)]
tfill[tfill$asv_code == "9cb0fd3c74a7d78345ce9dab0d7f1a87", c("class","order","family","species")] <- 
                       c("Clitellata", "Enchytraeida", "Enchytraeidae","Enchytraeidae sp. (Unident.)")

for(i in grep("Unident.", tfill$species)){
  if(length(strsplit(tfill$genus[i]," ")[[1]]) > 1){
    tfill$species[i] <- tfill$genus[i]
  }else{
  if(sum(is.na(which(!is.na(tfill[i,c("class","order","family","genus")])))) > 0) stop()
  if(length(which(!is.na(tfill[i,c("class","order","family","genus")]))) == 0){
    tfill$species[i] <- paste(tfill$phylum[i], "sp. (Unident.)")
  }else{
  record_identified_to <- max(which(!is.na(tfill[i,c("class","order","family","genus")]))) + 3
  tfill$species[i] <- paste(tfill[i,record_identified_to], "sp. (Unident.)")
  }
    }
}

## Finally loop through each record correcting genus and family names (keeping
## a record of old names and identifying those that have changed.)
# Remove erroneous genus names first
tfill$genus[!is.na(tfill$genus) & tfill$genus == "Chironomidae"] <- NA
tfill$genus[!is.na(tfill$genus) & tfill$genus == "Trombidiformes"] <- NA

# [MEL: To get the following loop to run, I needed to exclude a few taxon names.
 #      None of these exclusions matter for this exercise, but I do need to confirm whether
 #      the following taxa should be excluded from our analyses for being non-aquatic or non-macroinvertebrate
 #      Can you check the following and let me know if I should add them to the exclusions table
 #      (noting that the subfamily names I have excluded below are fine, and don't need checking)] CHRIS: I assume you wanted feed back here...in brackets
 #      "Eupodidae"(exclude) ,"Triophtydeidae" (exclude),"Isopoda sp. MC-1" (exclude),"Listronotus" (not sure so maybe safe to exclude),"Paederus"(exclude),"Spanioda"(exclude),"Geranomyia" (aquatic - Limoniidae),"Marionina" (some aquatic species but not all so I guess exclude if id only at genus)
 #      In looking through these, I read that Enchytraeidae are a primarily terrestrial family, but I have not 
 #      excluded any Enchytraeidae to date.  Can you help with advice on what to do with members of this family?] CHRIS: I believe some species in the family are aquatic, such as Cognettia sphagnetorum, Lumbricillus semifuscus, Globulidrilus riparius, Lumbricillus variegatus, Marionina argentea, Chamaedrilus cognettii, Chamaedrilus varisetosus, Cernosvitoviella aggtelekiensis, Cernosvitoviella microtheca. NOT aqautic Buchholzia appendiculata, Cernosvitoviella minor, Enchytraeus buchholzi, all Fridericia, Henlea perpusilla
# [MEL#2: Thanks Mel, that's all useful. I will update the exclusion table accordingly - not important for this process, so I'll do it when I get a bit more time (soon) - As for the Enchytraeids - should I exclude species that you don't list above?] CHRIS#2: I included only ones with full species names not those with interm. I think we should exclude all other as we can not be sure if they are aquatic or not.

for(i in 1:nrow(tfill)){
  recordi <- tfill[i,]
  first_word <- strsplit(recordi$species," ")[[1]][1]
  # If the first word in the species name is not a listed genus, family or subfamily...
  if(!first_word %in% taxon_gen$genus & 
      !first_word %in% c(taxon_fam$family, 
                  taxon_fam$subfamily[!is.na(taxon_fam$subfamily)],
                  taxon_fam$tribe[!is.na(taxon_fam$tribe)]) & 
     !tfill$family[i] %in% c("Eupodidae","Triophtydeidae") & 
     !tfill$species[i] %in% c("Isopoda sp. MC-1") &
     !first_word %in% c("Galerucinae","Limnophilinae","Coenosiinae","Atalophlebiinae",
                        "Listronotus","Paederus","Spanioda","Geranomyia","Marionina")){
     #...check that neither "genus" or "family" fields have a value - stop if so
    if(!is.na(recordi$genus) | !is.na(recordi$family)) stop("1")
  }
     #If it's a listed genus, then give the genus field that name , 
     # and give the family name the correct family name from the mwbugs database
  if(first_word %in% taxon_gen$genus){
    # if non genus is listed or it doesn't match the first_word
    if(is.na(recordi$genus) | recordi$genus != first_word){
      tfill$genus[i] <- strsplit(recordi$species," ")[[1]][1]
      tfill$genus_recode[i] <- 1
    }
    taxon_geni <- taxon_gen[taxon_gen$genus == tfill$genus[i],]
    taxon_fam_tab <- taxon_fam[taxon_fam$famcode == taxon_geni$famcode,]
    taxon_fami <- taxon_fam_tab$family
    # If the genus is a Tubificid, make the family field "Naididae"
    if(taxon_fam_tab$famcode == "LO04"){
         taxon_fami <- "Naididae"
        }
    # If the genus is a chironomid make the family field the subfamily
    if(grepl("QDA",taxon_fam_tab$famcode)){
        taxon_fami <- taxon_fam_tab$subfamily
        }
    tfill$family[i] <- taxon_fami
  }
  # If the above resulted in a change to the genus or fam field mark them as recoded
    if(is.na(tfill$family_old[i]) & !is.na(tfill$family[i])){
      tfill$family_recode[i] <- 1
      }else{
       if(!(is.na(tfill$family_old[i]) & is.na(tfill$family[i]))){
         if(tfill$family[i] != tfill$family_old[i]){
                            tfill$family_recode[i] <- 1
                   }}
      }
    if((is.na(tfill$genus_old[i]) & !is.na(tfill$genus[i])) | 
       (!is.na(tfill$genus_old[i]) & is.na(tfill$genus[i]))){
      tfill$genus_recode[i] <- 1
      }else{
        if(!(is.na(tfill$genus_old[i]) & is.na(tfill$genus[i]))){
           if(tfill$genus[i] != tfill$genus_old[i]){
                            tfill$genus_recode[i] <- 1
                   }}
      }
  # If it's a listed family or subfamily, then give the family field that name
  # and check that the genus field is empty. Stop if so.
  if(first_word %in% c(taxon_fam$family, 
                  taxon_fam$subfamily[!is.na(taxon_fam$subfamily)],
                  taxon_fam$tribe[!is.na(taxon_fam$tribe)])){
    if(!is.na(recordi$genus)) stop("2")
    # if the given family name is a tribe, then make the family name Chironomidae
    # Otherwise
    if(!is.na(recordi$family)){ 
      if(recordi$family != first_word){
      tfill$family[i] <- ifelse(first_word %in% taxon_fam$tribe[!is.na(taxon_fam$tribe)], 
                                "Chironominae", #only subfamily with tribes listed
                                first_word)
      tfill$family_recode[i] <- 1
    }}
  }
}

# [MEL: the above loop corrected:  
# sum(tfill$family_recode) # = 3065 family names. To inspect the unique changes, 
#   unique(tfill[tfill$family_recode == 1,c("family","family_old"),]) # Just 17 unique family changes
# sum(tfill$genus_recode) # = 61 genus names. To inspect the unique changes
#   unique(tfill[tfill$genus_recode == 1,c("genus","genus_old"),]) # 27 unique genus changes
# To inspect the records for a particular change you can do something like this:
# tfill[!is.na(tfill$genus) & !is.na(tfill$genus_old) & tfill$genus == "Chamaedrilus" & tfill$genus_old == "Cognettia",]
# # If you are unhappy about any of these changes, let me know and I can recode] CHRIS: looks fine to me.
# [MEL#2: just checking, given your confusion about running lines above, have you checked the outputs of the commented out  lines above?..If you are still happy, then please delete this group of comments] CHRIS#2: Yes. Only thing to not was there were 62 genus names when I ran the code. Happy for you to delete the comments
```

With genus and family fields correct, correct species names, using the following rules:

- Species without a formal identification, but with a single match to a bin_uri are given a species name using the bin_uri (e.g. );

- Species without a formal identification, that match two bin_uris are given a species names using both bin_uris separated by a "/" (e.g. );
[MEL: I wonder about the wisdom of this rule. What if a new bin_uri is created down the trak, that also matches this species? Wouldn't it be better just to call these "group" like the next case?  What purpose do the "/" names serve?] CHRIS: Yes. This could happen but some BINs may be replaced with species names. I think keeping the "/" is good as it provides information without having to go to another table. I am not super commited so if you what to change it do so.

- Species without a formal identification, that match three or more bin_uris are given a species names using one bin_Uri and the term "group" (e.g. );

- Species with a formal identification, that match one or more bin_uris (and none of those bin_uris are validly associated with any other formal species names) are given the formal species name as it is. (e.g. , which matches bin_uris....)

- Species with a formal identification, that match more than one bin_uris that are validly associated with two formal spcies names are given both species names separated by "/" (e.g.)

- Species with a formal identification, that match more than two bin_uris that are validly associated with two formal spcies names are given the most common formal species name followed by group (e.g.)

To begin this process, we ensure all species without formal identifications are given a name matching a single bin_uri (prior to grouping below).

```{r}

# check all B- species names match the first bin_uri for that species name
tfill$no_bin_match <- 0
for(i in grep("B-",tfill$species)){
  # remove all "group" and "/" names (to be re-instated later)
  tfill$species[i] <- gsub(" group", "", tfill$species[i])
  if(grepl("/", tfill$species[i])){
    tfill$species[i] <- substr(tfill$species[i], 1, nchar(tfill$species[i]) - 8)
  }
  bin_i <- match_list_bin_uri[tfill$asv_code[i]][[1]]
  if(nrow(bin_i) == 0)  {
    tfill$no_bin_match[i] <- 1
    }else{
#      if(!is.na(bin_i$bin_uri[1]) & bin_i$bin_uri[1] == "AAP5135") stop("1")
  tfill$species[i] <- paste0(substr(tfill$species[i], 1, nchar(tfill$species[i]) - 7), 
                             bin_i$bin_uri[1])
    }
}

# three given the wrong name in the above because of matches to multiple bin_uris. Correct manually
tfill$species[tfill$species == "Koorrnonga sp. B-ABV9140"] <- "Koorrnonga sp. B-ABV9142"
tfill$species[tfill$species == "Cryptochironomus sp. B-ACS3865"] <- "Cryptochironomus sp. B-ACS3851"
tfill$species[tfill$species == "Schizonyxhelea sp. B-ABX1780"] <- "Schizonyxhelea sp. B-ADT1789"

dodge_bs <- data.frame(species = unique(tfill$species[tfill$no_bin_match == 1]), 
                       some_bin_matches = 0)
for(i in 1:nrow(dodge_bs)){
  if(sum(tfill$no_bin_match[tfill$species == dodge_bs$species[i]]) != sum(tfill$species == dodge_bs$species[i]))
    dodge_bs$some_bin_matches[i] <- 1
}

# [MEL: dodge_bs lists 55 species names that you created using bin_uris that either have no matches in the bold database (19: sum(dodge_bs$some_bin_matches == 0) ), or some records given that name have no match (36: sum(dodge_bs$some_bin_matches) )].  What do you want to do about them? I will leave them as they are for now.] CHRIS: I think ones with no matches are new BINs not yet updated into the database. For example, if I search for BIN:AEW4330 on the BIN database there is no match. If I put the sequence in the 'Barcode ID' and search it matches (100) to Chaetogaster with bin AEW4330. This was the case for all the ones I checked. So leave these BINs for now.
# [MEL#2: fair enough. Probably worth including an explanatory section here justifying that. Could you have a crack at writing something for a general audience to understand this decision] CHRIS#2: For some asv records we found no matches in the bold database or some records given that name have no match using the API. However, when these asv records were identified using the BarcodeID web interface additional bold matches and bin_uri's were found.

# Having corrected the species names, update the species name in tfill_spp_bins
tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code,tfill$asv_code)]

```

The chunk below identifies the number of distinct species names associated with bin_uris. (There should only be one species name per bin_uri, while each species name can have multiple bin_uris).  

The loop creates a list to catch any groups of bin_uris that need to be given formal group names (form_gps).  To ensure transparent grouping decisions, we ran the loop first, and then made the requisit manual changes before re-running the loop.  

The loop also creates a list of groups with inconsistent names (inc_groups), which were similarly caught and corrected before re-running the loop.

```{r}
# Check for bin_url inconsistencies, and create new group names where appropriate
# This removed all such problems!
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]
tfill_spp_bins_unq_bu <- tfill_spp_bins_unq

# Formally named groups created after running the loop below first (identified in form_gps)
tfill$species[tfill$species %in% c("Tamasia acuta","Tamasia variegata")] <- "Tamasia acuta/Tamasia variegata"
tfill$species[tfill$species %in% c("Nannochorista dipteroides","Nannochorista dipteroides group")] <- "Nannochorista dipteroides"
tfill$species[tfill$species %in% c("Austropyrgus centralia","Austropyrgus turbatus","Austropyrgus centralia/turbatus")] <- "Austropyrgus centralia/turbatus"
tfill$species[tfill$species %in% c("Hydra oligactis","Hydra robusta")] <- "Hydra oligactis/robusta"
tfill$species[tfill$species %in% c("Hydra sinensis","Hydra viridissima")] <- "Hydra sinensis/viridissima"
tfill$species[tfill$species %in% c("Triplectides truncatus","Triplectides truncatus group")] <- "Triplectides truncatus"
tfill$species[tfill$species %in% c("Gynoplistia bimaculata","Gynoplistia lowanna")] <- "Gynoplistia bimaculata/lowanna"
tfill$species[tfill$species %in% c("Leptoperla kimminsi","Leptoperla kimminsi group")] <- "Leptoperla kimminsi"
tfill$species[tfill$species %in% c("Dinotoperla thwaitesi","Dinotoperla thwaitesi group")] <- "Dinotoperla thwaitesi"
tfill$species[tfill$species %in% c("Nais elinguis","Nais pseudobtusa")] <- "Nais elinguis/pseudobtusa"
tfill$species[tfill$species %in% c("Dinotoperla christinae", "Dinotoperla aryballoi")] <- "Dinotoperla christinae/aryballoi"
tfill$species[tfill$species %in% c("Rheumatometra dimorpha","Rheumatometra philarete")] <- "Rheumatometra dimorpha/philarete"

#[MEL: I looked the following inconsistently named species up on BOLD and come to the following conclusions
#      Can you please check I have made the right decisions?  CHRIS: The above look correct.
#[MEL#2: I wask asking about the lines below, down to the Trinotoperla lines]
#      NOTE: these may be grouped later - Primary interest is correct genus name (and one corrected bin_uri)
#CHRIS#2:  All are correct except ABX1092 which I believe should remain  "Limnophila sp. B-ABX1092" and AEV0976 which should be Simulium sp. B-AEV0976 (genus from GenBank). Plus as mention above I in favour of adding group to the end of Trinotoperla sp. B-ABX3905.



# ABV0255   "Limnophyes sp. B-ABV0255"  NOT "Echinocladius martini" 
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABV0255" & 
                     tfill_spp_bins$species == "Echinocladius martini"]
tfill$species[tfill$asv_code %in% asvi] <- "Limnophyes sp. B-ABV0255"

# ABX0996 "Atrichopogon sp. B-ABX0996"  presumably not  "Ceratopogonidae sp. B-ABX0996"
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX0996" & 
                     tfill_spp_bins$species == "Ceratopogonidae sp. B-ABX0996"]
tfill$species[tfill$asv_code %in% asvi] <- "Atrichopogon sp. B-ABX0996"

# ABX1092 "Limnophila sp. B-ABX1092" "Ozeoura convoluta"  (Presumably Ozeoura is a corrected ID?) 
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX1092" & 
                     tfill_spp_bins$species == "Limnophila sp. B-ABX1092"]
tfill$species[tfill$asv_code %in% asvi] <- "Ozeoura convoluta"

# # ABX4126 "Eusthenia sp. B-ABX4126"  NOT "Dinotoperla thwaitesi"
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) &
                     tfill_spp_bins$bin_uri == "ABX4126" &
                     tfill_spp_bins$species == "Dinotoperla thwaitesi"]
tfill$species[tfill$asv_code %in% asvi] <- "Eusthenia sp. B-ABX4126"

# ACG2297 "Notriolus sp. B-ACG2297" "Elmidae sp. B-ACG2297" Notriolus (1)  
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ACG2297" & 
                     tfill_spp_bins$species == "Elmidae sp. B-ACG2297"]
tfill$species[tfill$asv_code %in% asvi] <- "Notriolus sp. B-ACG2297"

# ACN2323 "Hellyethira basilobata"     "Orthotrichia sp. B-ACN2323" Orthotrichia (3)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ACN2323" & 
                     tfill_spp_bins$species == "Hellyethira basilobata"]
tfill$species[tfill$asv_code %in% asvi] <- "Orthotrichia sp. B-ACN2323"

# ADJ9699 "Limnodrilus hoffmeisteri" "Naididae sp. B-ADJ9699"  Naididae (2)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ADJ9699" & 
                     tfill_spp_bins$species == "Limnodrilus hoffmeisteri"]
tfill$species[tfill$asv_code  %in% asvi] <- "Naididae sp. B-ADJ9699"

# AEV0976 "Simuliidae sp. B-AEV0976" "Simulium sp. B-AEV0976"  Simuliidae (corrected in previous script with manual grouping)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "AEV0976" & 
                     tfill_spp_bins$species == "Simulium sp. B-AEV0976"]
tfill$species[tfill$asv_code %in% asvi] <- "Simuliidae sp. B-AEV0976"

# ABX3905 "Trinotoperla nivata" (4), "Trinotoperla montana" (2) )
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX3905" & 
                     tfill_spp_bins$species == "Trinotoperla montana"]
tfill$species[tfill$asv_code %in% asvi] <- "Trinotoperla sp. B-ABX3905"

tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code, tfill$asv_code)]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]

# Formally named groups created after running the loop below first (identified in form_gps)
n_unq <- function(x) length(unique(x))
spp_per_bin <- aggregate(tfill_spp_bins_unq$species, by = list(bin_uri = tfill_spp_bins_unq$bin_uri), FUN = n_unq)
# The above process has created multiple names for some bin_uris. Here, find them, check they all share the first word, and then give them the same (temporary) name.
# keep formally named groups and inconsistently named groups for later consideration
form_gps <- inc_gps <- list()
for(i in which(spp_per_bin$x > 1)){
  spi <- unique(tfill_spp_bins$species[!is.na(tfill_spp_bins$bin_uri) & 
                                         tfill_spp_bins$bin_uri == spp_per_bin$bin_uri[i]])
  if(spp_per_bin$bin_uri[i] == "AAX5636") stop("1")
  # Check all first words are the same
  if(length(unique(sapply(strsplit(spi," "),"[[",1))) != 1)  inc_gps <- c(inc_gps, list(spi))
  # Check if there is a non-B species name, if so, use that - if not, use the first name
  # first check no more than one non-B species name
  if(sum(!grepl(" B-", spi)) > 1)  form_gps <- c(form_gps, list(spi))
  if(sum(!grepl(" B-", spi)) == 1){
    tfill$species[tfill$species %in% spi] <- spi[!grepl(" B-", spi)]
  }else{
    tfill$species[tfill$species %in% spi] <- spi[1]
  }
}
# After the above corrections were applied form_gps and inc_gps are now empty.

tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code, tfill$asv_code)]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]

spp_per_bin <- aggregate(tfill_spp_bins_unq$species, by = list(bin_uri = tfill_spp_bins_unq$bin_uri), FUN = n_unq)
max(spp_per_bin$x) # 1 - so only one name per bin. Good! (It took a bit of effort to get there!)
```

```{r}
bins_per_sp <- aggregate(tfill_spp_bins_unq$bin_uri, by = list(species = tfill_spp_bins_unq$species), FUN = length)
# Any taxa named a group with only one bin_uri
bins_per_sp[bins_per_sp$x == 1 & grepl("group", bins_per_sp$species),]  # None. Good.

# Any group of bins with one formal species name leave it as the formal name
# Only one such species is already named group. (p1 Nais communis group)
p1 <- bins_per_sp[bins_per_sp$x > 1 & grepl("group", bins_per_sp$species) & 
              !grepl("B-", bins_per_sp$species),] 
# "B"- species names with more than one bin.
bin_spp_groups <- bins_per_sp[bins_per_sp$x > 1 & 
                  grepl("B-", bins_per_sp$species),]  # 53 
for(i in 1:nrow(bin_spp_groups)){
# Make new_name = the existing name (in preparation for changing it necessary)
  new_name <- bin_spp_groups$species[i]
  gp_bins_i <- tfill_spp_bins_unq[tfill_spp_bins_unq$species == bin_spp_groups$species[i],]
  #if the species names has just 2 bin_uris
  if(bin_spp_groups$x[i] == 2){
    # If the name already has a slash...
    if(grepl("/",bin_spp_groups$species[i])){
      # if the bin_uris in the name are right leave it and move on - if not stop for now...
      if(!(grepl(gp_bins_i$bin_uri[1],gp_bins_i$species[1]) & 
           grepl(gp_bins_i$bin_uri[2],gp_bins_i$species[1]))){
        stop("1")
      }
# and if the name doesn't have a slash, create a new 'slash' name.
    }else{
      bin_i <- right(bin_spp_groups$species[i],7)
      bin_i2 <- gp_bins_i$bin_uri[gp_bins_i$bin_uri != bin_i]
      sp_trunk_i <- substr(bin_spp_groups$species[i],1, nchar(bin_spp_groups$species[i]) - 7)
      # If the existing name doesn't match either of the bin_uris, stop for now...
      if(!bin_i %in% gp_bins_i$bin_uri){
        stop("2")
      }else{
        # Otherwise make new_name a new 'slash' name
        new_name <- paste0(sp_trunk_i, bin_i,"/",bin_i2)
      }
    }
    # and if the species names has more than 2 bin_uris
  }else{
        # If the name has a slash, rename it a group 
    if(grepl("/",bin_spp_groups$species[i])){
      sp_trunk_i <- substr(new_name, 1, nchar(new_name) - 8)
      new_name <- paste(sp_trunk_i, "group")
            # but if this new name does not match one of the bin_uris, stop for now...
      if(!right(sp_trunk_i,7) %in% gp_bins_i$bin_uri)
              stop("3")
    }else{
        # if no slash and if the bin_uri in the name doesn't match any of the bin_uris, stop for now...
      bin_i <- right(bin_spp_groups$species[i],7)
      if(!bin_i %in% gp_bins_i$bin_uri){
        stop("4")
      }else{
        # otherwise, just add group the existing name to make new_name
        new_name <- paste(new_name, "group")
      }
    }
  }
  tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == bin_spp_groups$species[i]]  <- new_name
  tfill_spp_bins$species[tfill_spp_bins$species == bin_spp_groups$species[i]]  <- new_name
  tfill$species[tfill$species == bin_spp_groups$species[i]]  <- new_name
}

# Check that tfill and tfill_spp_bins are consistent.
for(i in 1:nrow(tfill_spp_bins)){
  if(tfill$species[tfill$asv_code == tfill_spp_bins$asv_code[i]] != tfill_spp_bins$species[i])
    stop("Check")
}
tfill_spp_bins_unq <- unique(tfill_spp_bins[,c("species","bin_uri")])

check <- tfill_spp_bins[!grepl("group", tfill_spp_bins$species) & 
                          !grepl("/", tfill_spp_bins$species) & 
                          grepl("B-", tfill_spp_bins$species),]
wronguns <- check[!is.na(check$bin_uri) & check$bin_uri != right(check$species,7),]
# Zero wronguns ...run the following if wronguns return....
# unq_wronguns <- unique(wronguns$species)
# for(i in 1:length(unq_wronguns)){
#   pot_group_i <- tfill_spp_bins_unq[tfill_spp_bins_unq$species == unq_wronguns[i],]
#   if(nrow(pot_group_i) == 2 & sum(pot_group_i$bin_uri == right(pot_group_i$species,7)) == 1){
#     group_name_i <- paste0(substr(unq_wronguns[i],1,nchar(unq_wronguns[i]) - 7),
#                             pot_group_i$bin_uri[1], "/", pot_group_i$bin_uri[2])
#     tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == unq_wronguns[i]] <- group_name_i
#     tfill$species[tfill$species == unq_wronguns[i]] <- group_name_i
#     wronguns <- wronguns[wronguns$species != unq_wronguns[i],]
#     }
#   if(nrow(pot_group_i) > 2 & sum(pot_group_i$bin_uri == right(pot_group_i$species,7)) == 1){
#     group_name_i <- paste0(unq_wronguns[i], " group")
#     tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == unq_wronguns[i]] <- group_name_i 
#     tfill$species[tfill$species == unq_wronguns[i]] <- group_name_i
#     wronguns <- wronguns[wronguns$species != unq_wronguns[i],]
#   }
# }

# sum(tfill$species != tfill$species_old)  # 1893 records have had their species name changed
# changed_species <- unique(tfill[tfill$species != tfill$species_old, c("species","species_old")])
# nrow(changed_species)  #246 species names changed.
# sum(grepl("Zavrelimyia", changed_species$species)) # including 13 distinct Zavrelimyia groups. More than before?
```

[MEL: A shortcoming of the process I have taken here is that I am unable to check asv_codes that do not have a match to the bold database. The following chunk finds the asv_codes of records without a matching bin_uri that have been given a species name that has matches to the BOLD database for other records. There are 387 of them. The Nothocyphon frater records look a bit odd to me, as does the single record of Aulodrilus pluriseta (among others) - maybe they're ok,  but I thought it worth bringing them to your attention. The following chunk can be removed ultimately, but it should stay until we are convinced these 387 records are right]. CHRIS. some identification of records are from GenBank e.g. Nothocyphon frater (it is also matches on BOLD to family (Scirtidae)). Some have matches on BOLD above 97 when I check using the Barcode ID web interface e.g 06a66d49b92dc893e459482b6d8d811f - Caenobates sp. B-AEI4004 matches 100 to the genus and BIN AEI4004 if I search the sequence. There are also records that don't match using BOLD (they are borderline i.e. 96, but likely did with vsearch or GenBank which use different methods to match sequences to BOLD). I guess what I am saying is BOLD is not perfect or fully update. I reckon I have checked most of these records in the past and I'd be reluctant to leave them out.
[MEL#2: that's all good, but once again it would be good to include text here explaining these decisions for the reader]. CHRIS#2: A number of records only showed matches to sequences deposited on GenBank or records on the bold BarcodID web interface when private and public sequences were searched or were specimens sequenced by us but not yet published on bold database. These sequences could not be check via the API.

```{r}
# 387 asv_codes in the same group have NA bin_uri. is that ok? CHRIS: See just above
# This code finds those entries, returns the nearest matches returned by BOLD, with the
# three most common names used by BOLD and the maximum similarity returned by bold
# The bin_uri column returns the bin_uri values of other tfill records that have been given 
# the same species name
seq_no_match_to_bold_sp <- tfill_spp_bins[0,]
unq_spp <- unique(tfill$species)
for(i in 1:length(unq_spp)){
  sp_bin_i <- tfill_spp_bins[tfill_spp_bins$species== unq_spp[i],]
  if(sum(is.na(sp_bin_i$bin_uri)) > 0 & sum(is.na(sp_bin_i$bin_uri)) < nrow(sp_bin_i)){
    seq_no_match_to_bold_sp <- rbind(seq_no_match_to_bold_sp, sp_bin_i[is.na(sp_bin_i$bin_uri),])
  }
}
seq_no_match_to_bold_sp$bold_id3 <- seq_no_match_to_bold_sp$bold_id2 <- seq_no_match_to_bold_sp$bold_id1 <- NA
seq_no_match_to_bold_sp$max_sim <- NA
for(i in 1:nrow(seq_no_match_to_bold_sp)){
  bin_uri_other_records <- 
    unique(tfill_spp_bins$bin_uri[tfill_spp_bins$species == seq_no_match_to_bold_sp$species[i]])
  bin_uri_other_records <- bin_uri_other_records[!is.na(bin_uri_other_records)]
  seq_no_match_to_bold_sp$bin_uri[i] <- paste(bin_uri_other_records, collapse = ", ")
bold_match_i <- match_list[seq_no_match_to_bold_sp$asv_code[i]][[1]]
if(nrow(bold_match_i) > 0){
bold_names_i <- aggregate(bold_match_i$taxonomicidentification, 
                  by = list(species = bold_match_i$taxonomicidentification), FUN = length)
bold_names_i <- bold_names_i[order(bold_names_i$x, decreasing = TRUE),]
seq_no_match_to_bold_sp$bold_id1[i] <- bold_names_i$species[1]
if(nrow(seq_no_match_to_bold_sp) > 1)
seq_no_match_to_bold_sp$bold_id2[i] <- bold_names_i$species[2]
if(nrow(seq_no_match_to_bold_sp) > 3)
seq_no_match_to_bold_sp$bold_id3[i] <- bold_names_i$species[3]
seq_no_match_to_bold_sp$max_sim[i] <- max(bold_match_i$similarity)
}
}
WriteXLS::WriteXLS(seq_no_match_to_bold_sp, "~/temp/seq_no_match_to_bold_sp.xlsx")
# Corrections from Mel that have not come across cleanly to tfill


```


Recompile final ASV_library tables, adding back in the non-macroinvertebrate, non-aquatic species removed before the above BOLD matches, adding a column "cw_checked" to identify those records that have been checked by the above processes (cw_checked = 1), and species excluded by the only_aqu_inverts() function (cw_checked = 0)

```{r}
# separate the records originally taken from the max_p_update sheet (imported as x4 above)
max_p_update <- tfill[tfill$asv_code %in% max_p_update_df$asv_code,]
tfill_t <- tfill[!tfill$asv_code %in% max_p_update_df$asv_code,]

tfill_non_am <- tfill_all[!tfill_all$asv_code %in% tfill_t$asv_code & 
                            !tfill_all$asv_code %in% max_p_update_df$asv_code,]
tfill_non_am$cw_checked <- 0 
tfill_non_am <- dplyr::mutate(tfill_non_am, species_old = tfill_non_am$species, genus_old = tfill_non_am$genus, 
                              family_old = tfill_non_am$family, genus_recode = 0, family_recode = 0,
                              no_bin_match = NA,
                              .before = cw_checked)
tfill_non_am <- tfill_non_am[!duplicated(tfill_non_am$asv_code),]
tfill_t <- rbind(tfill_t, tfill_non_am)

max_p_update_non_am <- tfill_all[!tfill_all$asv_code %in% tfill_t$asv_code & 
                                   !tfill_all$asv_code %in% max_p_update$asv_code & 
                                   tfill_all$asv_code %in% max_p_update_df$asv_code,]
max_p_update_non_am$cw_checked <- 0 
max_p_update_non_am <- dplyr::mutate(max_p_update_non_am, species_old = max_p_update_non_am$species, 
                                     genus_old = max_p_update_non_am$genus, 
                              family_old = max_p_update_non_am$family, 
                              genus_recode = 0, family_recode = 0,
                              no_bin_match = NA,
                              .before = cw_checked)
max_p_update <- rbind(max_p_update, max_p_update_non_am)

nrow(max_p_update) + nrow(tfill_t) #15596 = number of rows in tfill_all

wd <- "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/"
WriteXLS::WriteXLS(list(truncated_fills = tfill_t, 
                        max_p_update = max_p_update,
                        bin_uris = tfill_spp_bins_unq),
                        ExcelFileName = paste0(wd, "asv_library_cw_corrected.xlsx"))

# # tfill <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "asv_library")
# max_p_update <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "max_p_update")
# bin_uris <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "bin_uris")
# load(paste0(wd, "asv_library_97_match_list_with_bin_uris_2024-12-11.rda"))
# match_list_bin_uri[tfill$asv_code[1]]
# tfill$asv_code[1]
```