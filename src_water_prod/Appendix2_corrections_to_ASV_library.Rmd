---
title: "Corrections_to_ASV_library"
author: "MCarew"
date: "2024-09-06"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Function equivalent to excel's =RIGHT() and =LEFT() functions
right <- function(x, n) {substr(x, nchar(x) - n + 1, nchar(x))}
left <- function(x, n) {substr(x, 1, n)}
```

## Introduction

This document amends the file 'asv_library_97_aug24.xlsx', generated in excel from earlier miSeq runs. Vsearch output files containing taxonomic assignments for asv's from each miseq run were inspected for incomplete taxonomic classifications (truncated_fills), i.e., where a match of >97 max-p-identity was observed and no species name was assigned. This can occur when there are conflicting taxonomic classification for similar sequences in the reference database used by vsearch or specimens in the reference database have not been identified to species. These asv records meeting this criteria, were manually compiled into a excel spreadsheet. Each asv sequence was then checked against BOLD and in instances where BOLD did not return a match they were checked against GenBank. If additional taxonomic information was available this was added to the asv's taxonomic classification. For sequences with species matches on BOLD, but no species name was available, species names were constructed using their BOLD identifiers (bin_uri) combined with the lowest level classification on BOLD (see below). We also found errors where sequences classified >97 max-p-identity were not invertebrates but showed matches to fungi or endosymbionts for example, and some additional species not in vsearch the reference database. These were added to the asv records in a separate spreadsheet as the max-p-identity required updating (max-p-update).

The code in this document amends the file by:

- correcting spelling errors in taxonomic names;

- looking up identifiers matching the sequences from boldsystems.org, naming un-named aquatic macroinvertebrate species using their BOLD identifiers (bin_uri), and grouping species with multiple bin_uris that overlap with >97% similarity

- recompiling the worksheets of 'asv_library_97_aug24.xlsx' and saving it as ''asv_library_97_jan25.xlsx'.

# Read in source data 

First, primary data from 'asv_library_97_aug24.xlsx' spreadsheets

```{r}
# read in files

source_path <- "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files/"
source_file <- "asv_library_97_aug24.xlsx"

# Read the sheets into as dataframes
tf0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
      sheet = "truncated_fills"))  

  # contains full taxonomic information for classifications with truncated taxonomy
otu_groups_df <- 
  as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                          sheet = "otu_groups", col_types = "text")) 
  # groups unclassified sequences into 'OTUs'
mp0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                                    sheet = "max_p_update"))
 # remove a duplicate record
mp0 <- mp0[!duplicated(mp0),]
  #updates/corrects any missing identifications or errors in classification

complexes_df <- readxl::read_excel(paste0(source_path,source_file),
                                       sheet = "complexes")

```

Then, additional data from:

- additions_asv_library_oct24.xlsx, containing additional asv records that were found with incomplete taxonomic classifications after updating the vsearch reference libraries and re-running vsearch based taxonomic assignments.

- asv_library_97_add_miseq15-20_records.csv (additional records for truncated_fills  from miSeq runs 15-20 with species identifications that match those in the above source tables for truncated_fills);

- filtered_<97_data.csv;

```{r}
# Additional truncated_fills records
tf1 <- as.data.frame(readxl::read_excel(paste0(source_path, 
                                               "additions_asv_library_oct24.xlsx"), 
                                        sheet = "trunc_fills")) 
tf2 <- read.csv(paste0(source_path, "asv_library_97_add_miseq15-20_records.csv"))[,-1]

# Combine the three truncated_fill source tables into a new table 
# (keeping all three original tables to permit back-checking)
truncated_fills_df <- rbind(tf0, tf1, tf2)

# Additional max_p_update records
mp1 <- read.csv(paste0(source_path, "filtered_97_data.csv"))

# update max_p_identify for those records with a corrected value
mp1$max_p_identity[!is.na(mp1$max_p_identity_corrected)] <- 
  mp1$max_p_identity_corrected[!is.na(mp1$max_p_identity_corrected)]
## CHRIS#2: I see. The file is correct and I didn't provide recommend names after row 158 as I was happy with your names beyond this point. So you can understand what I have done.. I have given names to asvs with a max-p-identity above 90 based checking them against BOLD. Where there was additional taxonomic information available where I have suggested name changes, where there were matches consistent with genus (max-p-identity of 95-96), family (max-p-identity of 95-92), order (max-p-identity of 92-85). e.g. for asv 6a9ea49438ba346534d213bc5fa3412e Arthropoda (sp. Unident.) is a 96.8 match to Dinotoperla hirsuta so it would be more appropriately called Dinotoperla (sp. Unident.).

# Combine the source tables into a new table, but replace records in mp0 with those in mp1 where there are duplicates
max_p_update_df <- rbind(mp0[!mp0$asv_code %in% mp1$asv_code,], 
                         mp1[match(names(mp0),names(mp1))])

# Move one additional record to max_p_udate_df and adjust max_p_identity
max_p_update_df <- rbind(max_p_update_df, 
                         truncated_fills_df[truncated_fills_df$asv_code ==
                                              "9dff2f4111c972a6a195d38ee341bf74",])
max_p_update_df$max_p_identity[max_p_update_df$asv_code == 
                                 "9dff2f4111c972a6a195d38ee341bf74"] <- 94.14
truncated_fills_df <- truncated_fills_df[truncated_fills_df$asv_code !=
                                           "9dff2f4111c972a6a195d38ee341bf74",]

# Some asvs produced different max-p-identities when sequences were directly compared to the BOLD or GenBank databases, and are correct in the following chunk. As these changed the assignment of species in some cases we chose to adjust these identification max-p-identities to be consistent with BOLD and GenBank. In most cases this resulted in courser levels of taxonomic assignment

max_p_identity_corrections <- c("9e5035bf7ec6a1f2c651ed0e98ed2da7" = "96.6",
"d453f558117b6d43a6d2feafbd877e0e" = "96.4",
"5ec678fc07a30a88297abe1aa71a4ead" = "96.5",
"d32a5e240858359c1bd7d6ebde67fe5b" = "96.5",
"314b908770c6f9c296aaab2da5698807" = "96.7",
"81530c1415a28a9a62322a482d714cef" = "94.6",
"3dc52e2c7a31e2a01a84549b92911bcb" = "95",
"f0e1b9af3b6dbb9a5afc88807a33f535" = "95",
"aa465397725596f1c084e4e48197372d" = "96",
"155515de679ea3f96eb251597a8355f5" = "96",
"7e9db264fabad9a9b2ac755cc524baa3" = "96.7",
"66c7e7bc806cfca10de70609b1ae1117" = "96.5",
"7abdbe52662941a5b1d6956f74fc8ccf" = "96.7",
"fb92efc10fba6e13b30c4e20f3f4be70" = "96.7",
"d971c3c25d994549e1ab94b17048486a" = "96.4",
"2a8674533aa6463808dced5102f0a1e5" = "96.5",
"384f60818615b4dc43d21b4fde820d21" = "96.4",
"2a09b204ea25d3ee0c23b26d00822dcf" = "96.4",
"c3ef326630a4b7eee124b7f4aa844cd6" = "96.4",
"3ea037839cc56c6adab4409ca544f57a" = "96",
"5fa5b580d9fb1c0503c5b4d05ce567e0" = "96.4",
"f2700c9ffaef418a7a9823b08b2b83c9" = "96.8",
"6a9ea49438ba346534d213bc5fa3412e" = "96.8",
"693405ffa22eb11c8a4302db0e8b6b7e" = "96.8",
"edc9cb8e69fe75af9826b60ecbc8f39b" = "96.8",
"a06bcf800ab074457f826c9026d93a05" = "96.8",
"60b0c55b3de6bcf0a4a4d4f2485a7ff7" = "90",
"c648f0859a67b40edf948409b8a4967a" = "90",
"bb9f84db19013052915d3b1ac559f11f" = "90",
"c3a2b4cfa3238dd8f6e5bf800290fd05" = "93",
"c56010a8847101c6f955be8758ba6963" = "95",
"f4c35e10c8e86a6dcee244a349473149" = "95",
"0bcf51bb494deb438b90e3e956a645bb" = "95",
"17edbbd11bdd22030c71999c0ed07036" = "95",
"2aadb65453c6df2420448394917cbc2f" = "95",
"94dda310e20d3e23a2752787a41a30f3" = "96",
"cb50aead3ff372183a06f8d09c03ef86" = "96.7",
"48b5d8e5472a2cf15d8acf17bfe90ccc" = "96.5",
"aad7ed86c3f30cfe5ee5bf4b8226d159" = "96.7",
"8ef04e58e9a04a7345c1310b8cc48b58" = "96",
"e64a94ea4d2c5000abac84231068b15b" = "96.5",
"65b850c96c49333ef25d783db98a5f9d" = "96",
"20c0f2c414bc8b2ff71a32ef4a6da942" = "96",
"4ff6a29cd87280c79d609ba2690b9b92" = "92",
"50a1d897e621e2dbb170bc4a7d206319" = "96",
"91162e539c973809dfa49f065bcb46c2" = "92",
"a3b763c11784ab20ccb6053c998cd0e4" = "97")

max_p_identity_corrections <- data.frame(asv_code = names(max_p_identity_corrections),
                                         max_p_identity = as.numeric(max_p_identity_corrections))
for(i in 1:nrow(max_p_identity_corrections)){
  if(!max_p_identity_corrections$asv_code[i] %in% max_p_update_df$asv_code) stop("") # didn't stop, so all in tfill
  max_p_update_df$max_p_identity[max_p_update_df$asv_code == max_p_identity_corrections$asv_code[i]] <- 
                      max_p_identity_corrections$max_p_identity[i]
}
# three further ad_hoc corrections
max_p_update_df$species[max_p_update_df$asv_code == "d54cf91de2a56cbde204c32eea369742"] <- "Fridericia sp. B-ADR5065"
max_p_update_df$species[max_p_update_df$asv_code == "a3b763c11784ab20ccb6053c998cd0e4"] <- "Ulmerophlebia sp. B-ABV8830"
max_p_update_df[max_p_update_df$asv_code == "5148a3678b70de5db884a99af7734de4",c("order","family","genus")] <- c("Sarcoptiformes",NA,NA)

# Keep max_p_update_df records and remove matching records from truncated_fills
truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in%
                                           max_p_update_df$asv_code,]

truncated_fills_df[truncated_fills_df == ""] <- NA
max_p_update_df[max_p_update_df == ""] <- NA

# Check for duplicate asv_codes/sequences
sum(duplicated(truncated_fills_df$asv_code)) # 2 - not good
 # Remove the one complete duplicate
truncated_fills_df <- truncated_fills_df[!duplicated(truncated_fills_df),]

# truncated_fills_df[duplicated(truncated_fills_df$asv_code) | 
#                   duplicated(truncated_fills_df$asv_code, fromLast = TRUE),]
# Two duplicate records with different max_p_identity. We have kept the value taken from BOLD.
truncated_fills_df <- 
  truncated_fills_df[!(duplicated(truncated_fills_df$asv_code) & 
                        truncated_fills_df$max_p_identity == 99.3),]
sum(duplicated(c(truncated_fills_df$asv_code, max_p_update_df$asv_code))) # 0 - good

# Major classification errors in original library (corrrected by checking on BOLD)
truncated_fills_df[truncated_fills_df$asv_code == "9ca9760013a77462d9c5e2c942e4d27e",
                   c("phylum","class","order","family","genus")] <- 
                c("Heterokontophyta","Oomycota","Peronosporales", "Peronosporaceae", "Phytophthora")

truncated_fills_df[truncated_fills_df$asv_code == "b167c9e6e63d586c8f79138f640da0cb",
                   c("family","genus","species")] <- 
                c("Eustheniidae", "Eusthenia", "Eusthenia sp. B-ABX4126")

# Remove 3 records with incorrect original assignments made by vsearch. This was discovered after double checking assignments against BOLD and GenBank and finding no matches
truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in%
                                           c("9725daabf323ef5cf9b512ee0b06f682",
                                             "160985800d21d905b2e3dff1edc1bf18",
                                             "238f54c32343060e69613167f345dd15"),]
```

The truncated_fills_df and max_p_update_df are now complete with unique records from all source files (13,610 and 1,983 records respectively). To make corrections to taxonomic naming more efficient, the following combines the two tables for recompilation at the end of this document (using asv_codes to re-assemble the two tables).

Taxonomic corrections have been made only to aquatic macroinvertebrates, excluding non-aquatic, non-macroinvertebrate species using the function only_aqu_inverts() in bug_database_functions.R from the [mwbugs database website](https:://tools.thewerg.unimelb.edu.au/mwbugs/data_dl.html). In this document, the function reads from the table of exclusions (), which is a copy of the table of the same name in the mwbugs database.

Similarly to correct genus and family names in the library, we use the taxonomic tables from the mwbugs database.

```{r}
tfill_all <- rbind(truncated_fills_df, max_p_update_df)    # 15593 records

source("https://tools.thewerg.unimelb.edu.au/data/mwbugs/bug_database_functions.R")
# Record of how non_aqu_macroinvert.csv was created
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# non_aqu_macro_invert <- DBI::dbReadTable(db, "non_aqu_macro_invert")
# write.csv(non_aqu_macro_invert,
#           "~/git/metabarcoding_workflow/data/non_aqu_macro_invert.csv",
#           row.names = FALSE)
non_aqu_macro_invert <- read.csv("data/non_aqu_macro_invert.csv")

# Record of how taxonomy.xlsx was created, noting that when complete this can be read 
# directly from the mwbugs downloads page (not yet updated)
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# taxon_gen <- DBI::dbReadTable(db, "taxon_gen")
# taxon_fam <- DBI::dbReadTable(db, "taxon_fam")
# WriteXLS::WriteXLS(list(taxon_gen = taxon_gen, taxon_fam = taxon_fam),
#           "~/git/metabarcoding_workflow/data/taxonomy.xlsx")
taxon_gen <- readxl::read_excel("~/git/metabarcoding_workflow/data/taxonomy.xlsx", 
                                "taxon_gen")
taxon_fam <- readxl::read_excel("~/git/metabarcoding_workflow/data/taxonomy.xlsx", 
                                "taxon_fam")

tfill <- only_aqu_inverts(tfill_all, 
                          non_aqu_macro_invert_already_loaded = TRUE)$include #11,866 records
# And exclude two additional records only identified to phylum (Arthropoda and Zygomycota)
tfill <- tfill[!is.na(tfill$species),]  #11,864 records
tfill <- tfill[tfill$species != "Isopoda sp. MC-1",] #11,844 records
```

Note that tfill_all records excluded from tfill will be added unchanged to the final table at the end.

Below, we change the term 'complex' in the asv_library to 'group' to remove any implication of true taxonomic complexes in the grouping of species. We also correct spelling errors in the source data.

```{r}
# Keep a record of the original species name for checking later on.
tfill$species_old <- tfill$species
# Correct spelling errors
tfill$species <- gsub("  ", " ", tfill$species)
tfill$species <- gsub("Cricptopus", "Cricotopus", tfill$species)
tfill$species <- gsub("sp.B", "sp. B", tfill$species)
tfill$species <- gsub("GB-", "G-", tfill$species)
tfill$species <- gsub("ZB-", "", tfill$species)
tfill$species <- gsub("complex", "group", tfill$species)
tfill$species <- gsub("Iilliesoperla","Illiesoperla",tfill$species)

tfill$species[grep("Asmicridea edwardsi", tfill$species)] <- "Asmicridea edwardsii"
tfill$species[tfill$species == "Chironomidae sp. B-ABX4803"] <- "Chironominae sp. B-ABX4803"
tfill$species[tfill$species == "Chironomidae sp. B-AEE9278"] <- "Orthocladiinae sp. B-AEE9278"
tfill$species[tfill$species == "Dero obtusa"] <- "Dero obtusa/nivea"
tfill$species[tfill$species == "Lingora aurata"] <- "Lingora aurata group"
tfill$species[tfill$species == "Limnodrilus claparedeanus"] <- "Limnodrilus claparedianus"
tfill$species[tfill$species == "Antiporus gilbertii"] <- "Antiporus gilberti"
tfill$species[tfill$species == "Austrolimnius waterhouseii"] <- "Austrolimnius waterhousei"
tfill$species[tfill$species == "Culicoides bundyensi"] <- "Culicoides bundyensis"
tfill$species[tfill$species == "Hyderodes shuckardi"] <- "Hyderodes schuckardi"
tfill$species[tfill$species == "SImsonia longipes"] <- "Simsonia longipes"
tfill$species[tfill$species == "Musculium sp. B-ADJ8477"] <- "Sphaerium sp. B-ADJ8477"
tfill$species[tfill$species == "Dinotoperla aff. thwaitesi"] <- "Dinotoperla thwaitesi group"
tfill$species[tfill$species == "Austropyrgus centralia group"] <- "Austropyrgus centralia/turbatus"
tfill$species[tfill$species == "Centroptilum sp. B-ACM3150"] <- "Centroptilum elongatum"
tfill$species[tfill$species == "Hydraenidae sp. B-ADK5039"] <- "Gymnochthebius australis"
tfill$species[tfill$species == "Helicophida queenslandensis"] <- "Helicopha queenslandensis"
tfill$species[tfill$species == "Riethia zeylandica"] <- "Riethia sp. B-ADU5431" 
tfill$species[tfill$species == "Notalina bifara group B-ABV8023"] <- "Notalina bifara group"
tfill$species[tfill$species == "Notalina sp. B-AAX5636"] <- "Notalina bifara group"
tfill$species[tfill$species == "Ferrissia sp. MC-1"] <- "Ferrissia sp. B-AAE6642"
```

The following was run using the bold package V1.3.0 to download from the boldsystems API  before their upgrade at the end of 2024. The script thus includes steps to allow for errors arising from exceeding download quotas from bold.  It involves two steps:

- First, match_list is a list of tables, each table the complete list of matching  BOLD records to the asv_sequence in the input data (using the function bold_identify).  The name of each table in the list is the asv_code.

- Second, match_list_bin_uri is a list of tables with same names as those in match_list but each table is reduced to include only those records that are >=97% similar to the asv_sequence. The function bold_specimens() is then used to extract the 
bin_uri for each BOLD ID.  

It is likely that the new API will not require the steps to work around errors or the two-step process for extracting bin_uris.
The process was error free using RStudio 2024.09.0 (Each step took ~30 h to  extract data for 10,000 asv records), but failed many times, requiring restarting of the loop in both steps, using RStudio Server 2023.03.02

The following chunk is step 1, saving the full list of BOLD matches (each with name = asv_code) to "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library_97_match_list_to_BOLD_2024-12-05.rda".

[MEL: when we have finalised this, we need to place big files such as these match_list files in a repository, and then re-write this script to allow users to download and use them. I can help you do this. (Note for me later on - example code at L20 of https://github.com/cjbwalsh/urban_riffle_experiment/blob/master/urban_riffle_exp_figs_code.qmd)]
[MEL2: Let's leave these comments here for now until the final version, and I can have a final go] CHRIS#2: Thank you. 

The chunk is set not to evaluate, as it took ~30 h to run.

```{r eval:FALSE}

match_list <- list()

# Download all matching records from bold for each asv record 
for(i in 1:nrow(tfill)){  
  # ran without error on RCP server in a single process (taking ~30 h)
  seqi <- tfill$asv_seq[i]
  # The BOLD server returns an error if it is being overloaded
  # Here I handle this with the retry function
  matchi <- retry::retry(bold::bold_identify(seqi, db = "COX1"),
                         when = "NULL", max_tries=12, interval= (5 * 60 + 1))
  # Name each list element by asv_code (which should remain unchanged)
  names(matchi) <- tfill$asv_code[i]
  match_list <- c(match_list, matchi)
  # Save a working copy and report progress every 100 iterations.
  if(i %% 100 == 0)  
    cat(i, as.character(Sys.time()),"\n")
  save(match_list, file = paste0("~/temp/match_list_rerun.rda"))
}

# Saved to same folder as asv data source files with datestamp to avoid over-writing
save(match_list, file = 
       paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_to_BOLD_", Sys.Date(), ".rda"))
```

The following chunk then reduces each match_list table to those records with >=97% similarity and extracts their bin_uris, saving them as a second list of tables with fields: ID, taxonomicidentification, similarity, specimen_country, bin_uri.

The list was saved as "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library_97_match_list_with_bin_uris2024-12-05.rda".

As above, the chunk is set not to evaluate, as it also took ~30 h to run.

```{r eval:FALSE}

match_list_bin_uri <- list()

system.time({
  # ran without error on RCP server in a single process (taking ~30 h)
  for(i in 1:length(match_list)) { 
        matchi <- match_list[[i]][match_list[[i]]$similarity >= 0.97,
                                  c("ID","taxonomicidentification","similarity","specimen_country")]
        # If there are no sufficiently similar BOLD records, create a blank record
        if(nrow(matchi) == 0){
          matchi <- data.frame(ID = NA, taxonomicidentification = NA,
                               similarity = NA, specimen_country = NA,
                               bin_uri = NA)[0,]
        }else{
          # Otherwise use the bold_specimens function to extract the bin_uri for each record.
          if(nrow(matchi) <= 50) {
            bini <- bold::bold_specimens(ids = matchi$ID) #seqspec
          }else{
            # If there are more than 50 sufficiently <- similar records, break it into lots
            # of 50 or less so as not to overload the BOLD API
            J <- c(which(1:nrow(matchi) %% 50 == 0),nrow(matchi))
            for(j in 1:length(J)){
              indJ <- ifelse(j == 1, 1, J[j - 1] + 1):J[j] 
              binj <- bold::bold_specimens(ids = matchi$ID[indJ])
              Sys.sleep(1)
              if(j == 1){
                bini <- binj
              }else{
                bini <- rbind(bini, binj)
              }
            }   
          }
          # The bold_specimens function returns a warning if the BOLD API quota is 
          # exceeded. Catch this warning and wait up to 70 minutes (trying every 5 min) 
          # until the API begins accepting requests again.
          if(grepl("exceeded",names(bini)[1])){
            cat("BOLD retrieval quota exceeded: pausing process at i =", i,"\n")
            tries <- 1
            retry_time_seconds <- c(61,4)*60
            while(grepl("exceeded",names(bini[1])) & tries <= 2){
              Sys.sleep(retry_time_seconds[tries])
              if(nrow(matchi) == 0){
                matchi <- data.frame(ID = NA, taxonomicidentification = NA,
                                     similarity = NA, specimen_country = NA,
                                     bin_uri = NA)[0,]
              }else{
                # Otherwise use the bold_specimens function to extract the bin_uri for each record.
                if(nrow(matchi) <= 50) {
                  bini <- bold::bold_specimens(ids = matchi$ID) #seqspec
                }else{
                  # If there are more than 50 sufficiently similar records, break it into lots
                  # of 50 or less so as not to overload the BOLD API
                  J <- c(which(1:nrow(matchi) %% 50 == 0),nrow(matchi))
                  for(j in 1:length(J)){
                    indJ <- ifelse(j == 1, 1, J[j - 1] + 1):J[j] 
                    binj <- bold::bold_specimens(ids = matchi$ID[indJ])
                    Sys.sleep(1)
                    if(j == 1){
                      bini <- binj
                    }else{
                      bini <- rbind(bini, binj)
                    }
                  }
                }
              }
              cat("...for", cumsum(retry_time_seconds[1:tries])[tries]/60, "minutes")
              tries <- tries + 1
            }
          }
          # A very small number of bini get returned with no header row.
          # This is a work around for them
          if(names(bini)[1] != "processid"){
            stop("2: missing header row?")
            bini <- bini[,c(1,grep("BOLD",names(bini)[1]))]
            lostline <- names(bini)
            names(bini) <- c("processid","bin_uri")
            bini <- rbind(data.frame(processid = lostline[i],bin_uri = lostline[2]),
                          bini)
          }
          bini <- bini[,c("processid","bin_uri")]
          matchi$bin_uri <- gsub("BOLD:","",bini$bin_uri[match(matchi$ID,bini$processid)])
          # add the reduced table with bin_uri to match_list_bin_uri
        }
        match_list_bin_uri <- c(match_list_bin_uri,list(matchi))
        if(length(match_list_bin_uri) != i ) stop("1")
        names(match_list_bin_uri)[i] <- names(match_list)[i]
        # Save a working copy and report progress every 100 iterations.
        if(i %% 100 == 0){
          save(match_list_bin_uri, 
               file = paste0("~/temp/match_list_bin_uri.rda"))
          cat(i, as.character(Sys.time()),"\n")
        }
      }
    })  
    
# Saved to same folder as asv data source files with datestamp to avoid over-writing
save(match_list_bin_uri, file = 
       paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_with_bin_uris_", Sys.Date(), ".rda"))

```

Some ad-hoc changes to provisional species names can be made without recourse to the BOLD database.  They are made here first.

```{r}
tfill$species[tfill$species == "Austrochiltonia sp. MC-1"] <- 
                                                 "Austrochiltonia australis"
tfill$species[tfill$species == "Culicoides sp. MC-24"] <- 
                                                      "Culicoides sigmoidus"
tfill$species[tfill$species == "Limnophyes sp. MC-A1"] <- 
                                                  "Limnophyes sp. B-ABW5528"
tfill$species[tfill$species == "Limoniidae sp. MC-1"] <- 
                                                   "Limnophilinae sp. B-ABW2416"
tfill$species[tfill$species == "Limoniidae sp. MC-2"] <- 
                                                   "Limnophilinae sp. B-ABX1292"
tfill$species[tfill$species == "Isopoda sp. B-ACG3222"] <- 
                                                  "Sphaeromatidae sp. B-ACG3222"
```

The following chunk creates a new table of asv_codes, species names, and their bin_uris. Many asv_codes have multiple bin_uris, so this table is longer than tfill. (15,910 rows rather than 11,950).

```{r}
# load list "match_list_bin_uri", compiled in the chunk above
load(paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_with_bin_uris_2024-12-15.rda"))
# And load "match_List" - the full list of matching records to BOLD (not limited to >0.97 similarity)
load(paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_to_BOLD_2024-12-15.rda"))

# There are 60 asv_codes in the match_lists that aren't in tfill...not sure of their origin
# Exclude them here
match_list_bin_uri <- match_list_bin_uri[match(tfill$asv_code, names(match_list_bin_uri))]
match_list <- match_list[match(tfill$asv_code, names(match_list))]

# Create a tfill_spp_bins, which lists all bin_uris associated with each asv_code
tfill_spp_bins <- data.frame(asv_code = names(match_list_bin_uri),
                             species = tfill$species[match(names(match_list_bin_uri), tfill$asv_code)],
                             bin_uri = NA)
for(i in 1:nrow(tfill_spp_bins)){
  tfill_spp_bins$species[i] <- tfill$species[tfill$asv_code == names(match_list_bin_uri)[i]]
}

for(i in 1:nrow(tfill_spp_bins)){
    bins <- match_list_bin_uri[[i]]$bin_uri
    bins <- bins[!is.na(bins) & !bins == ""]
  if(length(unique(bins)) == 0){
     next()
    }else{
    tfill_spp_bins$bin_uri[i] <- unique(bins)[1]
    if(length(unique(bins)) > 1){
      tfill_spp_bins <- rbind(tfill_spp_bins, 
                              data.frame(asv_code = names(match_list_bin_uri)[i],
                              species = tfill$species[tfill$asv_code == names(match_list_bin_uri)[i]],      
                              bin_uri = unique(bins)[-1]))
    }
    }
}

tfill_spp_bins <- tfill_spp_bins[order(tfill_spp_bins$species),]
tfill_spp_bins$bin_uri <- gsub("BOLD:","",tfill_spp_bins$bin_uri)

```

Species without a formal name are given a name based on their BOLD identifiers (bin_uri).  Species that have two bin_uris are given a name containing both bin_uris separated by a slash (/).  Species that have more than 2 bin_uris are given the name of one of the bin_uris followed by "group".  The following chunks renders those names. 

The first chunk ensures that the first word of the name (usually genus, but potentially a higher taxonomic level) are correct, first by making manual corrections using the BOLD database and taxonomic identifications of specimens.

```{r}
# tfill_bu <- tfill
# tfill_spp_bins_bu <- tfill_spp_bins
# tfill <- tfill_bu
# tfill_spp_bins <- tfill_spp_bins_bu

tfill$species_old <- tfill$species

# Some records named Sphaerium not correct (Set species to "" for those without a bold match)
for(i in grep("Sphaerium", tfill$species)){
  if(nrow(match_list_bin_uri[[tfill$asv_code[i]]]) == 0){
    tfill$genus[i] <- NA
    tfill$species[i] <- "Pisidiidae sp. (Unident.)"
  }else{
    # Make sure we're dealing with just Sphaerium sp. B-ADJ8477
    if(!"ADJ8477" %in% match_list_bin_uri[[tfill$asv_code[i]]]$bin_uri) stop()
    tfill$genus[i] <- "Sphaerium"
  }
}

# An unidentified naididae previously classed as Limnodrilus hoffmeisteri should be Naididae sp. B-ADJ9699
naid_asvs <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "ADJ9699"]
tfill$genus[tfill$asv_code %in% naid_asvs] <- NA


# #                             asv_code                        new_species                   species_old         bold_species bin_uri n_bins del
# 158 51bb3b643e6c884ac72e340348a32c33          Ablabesmyia sp. B-AAP5135     Ablabesmyia sp. B-ACG8949                 <NA>    <NA>      0   0
# 159 d67b66092a6572d57ac7290d21ef39c4           Coloburiscoides munionga Coloburiscoides sp. B-ADW5046                 <NA>    <NA>      0   0
# 212 19661209bd3d6750ef55e93b6f8f400b            Ferrissia sp. B-AAY1880            Ferrissia sp. MC-1                 <NA>    <NA>      0   0
# Note your code changed the given asv_code from old_species to new_species. 
# None of these three had a matching bold record for me to assess their veracity]

# [MEL#3: see my email about these three problems.  If you are happy with the names that this script gives these three records (as given in the email), then you can delete this set of comments and nothing else is necessary.  If you want any of the names changed, then additional script lines are necessary. Let me know.]
# [MEL#4: As far as I can tell you still haven't addressed the question of whether you are happy with the final names given to these records. In the current final version the names given to these three records are: "Ablabesmyia sp. B-AEN3809", "Coloburiscoides sp. B-ADW5046", "Ferrissia sp. B-AAE6642 group". If you are happy with that, please delete this last group of comments.  If not, delete the comments anyway, and let me know how you want them changed.]

# And the following are changes in part from your asv_code chunk changing species names
bold_name_corrections <- 
c("AAE9243" = "Cheumatopsyche alampeta",
"ACG2503" = "Coloburiscoides munionga",
"ACV9482" = "Cricotopus tasmania",
"ABX3893" = "Illiesoperla mayi",	
"ACG1875" = "Rhadinosticta simplex",
"ADJ8523" = "Limnodrilus hoffmeisteri",
"AEI0789" = "Procorticacarus victorianus",
"ABV8829" = "Ulmerochorema onychion",
"AAU4648" = "Psychoda gemina",
"ACV9482" = "Cricotopus tasmania",
"AAT8936" = "Cognettia chlorophila/sphagnetorum",
"AAF0821" = "Tanytarsus fuscithorax",
"ACB6471" = "Chaetogaster diastrophus",
"ABX5220" = "Austrosimulium furiosum",
"ABY8640" = "Lingora aurata",
"AAW2994" = "Austrheithrus glymma",
"ACD5693" = "Dinotoperla thwaitesi",
"ABX4166" = "Dinotoperla walkeri/evansi",
"ABV8830" = "Ulmerophlebia sp. B-ABV8830", # included here because genus was wrong in library
"AAW4309" = "Cardiocladius sp. B-AAW4309", # included here because genus was wrong in library
"ADJ0699" = "Byrrocryptus sp. B-ADJ0699", # late genus-level id
"ACV9616" = "Bothrioneurum vejdovskyanum",
"AAX5275" = "Bothrioneurum vejdovskyanum",
"ACI5239" = "Bothrioneurum vejdovskyanum")

bnc_df <- data.frame(bin_uri = names(bold_name_corrections), 
                       new_species = bold_name_corrections)
for(i in 1:nrow(bnc_df)){
  asvcodei <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                                        tfill_spp_bins$bin_uri == bnc_df$bin_uri[i]]
  tfill_spp_bins$species[tfill_spp_bins$asv_code %in% asvcodei] <- 
                                                    bnc_df$new_species[i]
  tfill$species[tfill$asv_code %in% asvcodei] <- bnc_df$new_species[i]
  
}

chamaedrilus_asv_codes <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri %in% c("AAT9499","AAT9501","ACQ1237","AAU1095")]
tfill_spp_bins$species[tfill_spp_bins$asv_code %in% chamaedrilus_asv_codes] <- "Chamaedrilus varisetosus"
tfill$species[tfill$asv_code %in% chamaedrilus_asv_codes] <- "Chamaedrilus varisetosus" 

cognettia_asv_codes <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri %in% "AAT8936"]
tfill_spp_bins$species[tfill_spp_bins$asv_code %in% cognettia_asv_codes] <- "Cognettia chlorophila/sphagnetorum"
tfill$species[tfill$asv_code %in% cognettia_asv_codes] <- "Cognettia chlorophila/sphagnetorum" 

# "Hydrobiosella waddama" and "Hydrobiosella perangusta" are distinct except for 
# asv_code cf4d8b16cb64eb29dd6eb8aeff774878, which has similarity >0.985 with 
# Hydrobiosella waddama AAZ5125 and similarity 0.9706 to one record of AAZ4813...
# just over the criterion.  Sufficiently different to keep separate. Thus:
tfill_spp_bins$bin_uri[(tfill_spp_bins$species == "Hydrobiosella waddama" & 
                     tfill_spp_bins$bin_uri == "AAZ4813")] <- "AAZ5125"

# Add "Nais variabilis" to "Nais communis group"
tfill$species[tfill$species == "Nais variabilis"] <- "Nais communis group"
tfill_spp_bins$species[tfill_spp_bins$species == "Nais variabilis"] <- "Nais communis group"

# The taxonomic tables taxon_fam and taxon_gen introduce some inconsistencies in family names
# Some, noted here for reference, are Telephlebiidae (predominately Austroaeschna) - Aeshnidae (on BOLD), Pisidiidae - Sphaeriidae (on BOLD) and , Nanophyidae - Brentidae (on BOLD for ADD0490).

## Check genus and family fields throughout the table ensuring: 
## a) the genus name matches the first word of the species name (or is blank if 
##     the first word is a higher taxonomic level)
## b) the family name is the correct family for the given genus (or species name
##     if the species name is not a genus) 
tfill$genus_old <- tfill$genus
tfill$family_old <- tfill$family
tfill$genus_recode <- 0
tfill$family_recode <- 0
# Remove duplicated species names from family, genus, order
tfill$order[!is.na(tfill$order) & tfill$order == tfill$species] <- NA
tfill$family[!is.na(tfill$family) & tfill$family == tfill$species]  <- NA
tfill$genus[!is.na(tfill$genus) & tfill$genus == tfill$species] <- NA

# sum(grepl("Unident.", max_p_update_df$species))  #198
## 198 records without a species name (all from the max_p_update table)

# records given species names in original max_p_update table
x <- mp1$asv_code[match(c("Illiesoperla mayi (sp. Unident.)","Sphaerium sp. B-ADJ8477","Hydra vulgaris (sp. Unident.)","Nousia sp. B-ABV9190","Coloburiscoides giganteus","Nousia sp. B-AAV4108","Cernosvitoviella aggtelekiensis"), mp1$recomended_species_name )]

# Corrections to individual records corresponding with x
tfill$species[tfill$asv_code == x[1]] <- "Illiesoperla mayi"  
  # 96.97% match to Illiesoperla mayi using https://v4.boldsystems.org/index.php/IDS_OpenIdEngine (but mysteriously no match using bold::bold_identify())
  # JUSTIFICATION?
tfill$species[tfill$asv_code == x[2]] <- "Sphaerium sp. (Unident.)"  
  # 96.74% similarity to Sphaerium sp. AU04/1 BOLD:ADJ8477 using https://v4.boldsystems.org/index.php/IDS_OpenIdEngine (but mysteriously no match using bold::bold_identify()).  Not similar enough to warrant giving it the bin_uri.
tfill$species[tfill$asv_code == x[3]] <- "Hydra vulgaris"  
  # 96.57% similarity to Hydra vulgaris using https://v4.boldsystems.org/index.php/IDS_OpenIdEngine (but mysteriously no match using bold::bold_identify()).
  # JUSTIFICATION?
tfill$species[tfill$asv_code == x[4]] <- "Nousia sp. (Unident.)"  
  # 96.57% similarity to Nousia sp. BOLD:ABV9190 using https://v4.boldsystems.org/index.php/IDS_OpenIdEngine (but mysteriously no match using bold::bold_identify()).  Not similar enough to warrant giving it the bin_uri.
tfill$species[tfill$asv_code == x[5]] <- "Coloburiscoides sp. (Unident.)"  
  # 96.12% similarity to Coloburiscoides giganteus using https://v4.boldsystems.org/index.php/IDS_OpenIdEngine (but mysteriously no match using bold::bold_identify()).
  # Not similar enought to give it that species name.
tfill$species[tfill$asv_code == x[6]] <- "Nousia sp. (Unident.)"  
  # 95.65% similarity to Nousia sp. BOLD:AAV4108 using https://v4.boldsystems.org/index.php/IDS_OpenIdEngine (but mysteriously no match using bold::bold_identify()).  Not similar enough to warrant giving it the bin_uri.
tfill$species[tfill$asv_code == x[7]] <- "Cernosvitoviella sp. (Unident.)"  
  #  Finally an Enchytraeid that had been incorrectly listed in the table as a Dytiscid (100% match to BOLD-AAG4407 using both BOLD methods)
tfill[tfill$asv_code == "9cb0fd3c74a7d78345ce9dab0d7f1a87", c("class","order","family","species")] <- 
                       c("Clitellata", "Enchytraeida", "Enchytraeidae","Enchytraeidae sp. B-AAG4407")

for(i in grep("Unident.", tfill$species)){
  if(length(strsplit(tfill$genus[i]," ")[[1]]) > 1){
    tfill$species[i] <- tfill$genus[i]
  }else{
  if(sum(is.na(which(!is.na(tfill[i,c("class","order","family","genus")])))) > 0) stop()
  if(length(which(!is.na(tfill[i,c("class","order","family","genus")]))) == 0){
    tfill$species[i] <- paste(tfill$phylum[i], "sp. (Unident.)")
  }else{
  record_identified_to <- max(which(!is.na(tfill[i,c("class","order","family","genus")]))) + 3
  tfill$species[i] <- paste(tfill[i,record_identified_to], "sp. (Unident.)")
  }
    }
}

## Finally loop through each record correcting genus and family names (keeping
## a record of old names and identifying those that have changed.)
# Remove erroneous genus names first
tfill$genus[!is.na(tfill$genus) & tfill$genus == "Chironomidae"] <- NA
tfill$genus[!is.na(tfill$genus) & tfill$genus == "Trombidiformes"] <- NA

for(i in 1:nrow(tfill)){
  recordi <- tfill[i,]
  first_word <- strsplit(recordi$species," ")[[1]][1]
  # If the first word in the species name is not a listed genus, family or subfamily...
  if(!first_word %in% taxon_gen$genus & 
      !first_word %in% c(taxon_fam$family, 
                  taxon_fam$subfamily[!is.na(taxon_fam$subfamily)],
                  taxon_fam$tribe[!is.na(taxon_fam$tribe)]) & 
     # Some valid subfamily names not used in taxonomic hierarchy
     !first_word %in% c("Galerucinae","Limnophilinae","Coenosiinae","Atalophlebiinae")){
     #...check that neither "genus" or "family" fields have a value - stop if so
    if(!is.na(recordi$genus) | !is.na(recordi$family)) stop("1")
  }
     #If it's a listed genus, then give the genus field that name , 
     # and give the family name the correct family name from the mwbugs database
  if(first_word %in% taxon_gen$genus){
    # if non genus is listed or it doesn't match the first_word
    if(is.na(recordi$genus) | recordi$genus != first_word){
      tfill$genus[i] <- strsplit(recordi$species," ")[[1]][1]
      tfill$genus_recode[i] <- 1
    }
    taxon_geni <- taxon_gen[taxon_gen$genus == tfill$genus[i],]
    taxon_fam_tab <- taxon_fam[taxon_fam$famcode == taxon_geni$famcode,]
    taxon_fami <- taxon_fam_tab$family
    # If the genus is a Tubificid, make the family field "Naididae"
    if(taxon_fam_tab$famcode == "LO04"){
         taxon_fami <- "Naididae"
        }
    # If the genus is a chironomid make the family field the subfamily
    if(grepl("QDA",taxon_fam_tab$famcode)){
        taxon_fami <- taxon_fam_tab$subfamily
        }
    tfill$family[i] <- taxon_fami
  }
  # If the above resulted in a change to the genus or fam field mark them as recoded
    if(is.na(tfill$family_old[i]) & !is.na(tfill$family[i])){
      tfill$family_recode[i] <- 1
      }else{
       if(!(is.na(tfill$family_old[i]) & is.na(tfill$family[i]))){
         if(tfill$family[i] != tfill$family_old[i]){
                            tfill$family_recode[i] <- 1
                   }}
      }
    if((is.na(tfill$genus_old[i]) & !is.na(tfill$genus[i])) | 
       (!is.na(tfill$genus_old[i]) & is.na(tfill$genus[i]))){
      tfill$genus_recode[i] <- 1
      }else{
        if(!(is.na(tfill$genus_old[i]) & is.na(tfill$genus[i]))){
           if(tfill$genus[i] != tfill$genus_old[i]){
                            tfill$genus_recode[i] <- 1
                   }}
      }
  # If it's a listed family or subfamily, then give the family field that name
  # and check that the genus field is empty. Stop if so.
  if(first_word %in% c(taxon_fam$family, 
                  taxon_fam$subfamily[!is.na(taxon_fam$subfamily)],
                  taxon_fam$tribe[!is.na(taxon_fam$tribe)])){
    if(!is.na(recordi$genus)) stop("2")
    # if the given family name is a tribe, then make the family name Chironomidae
    # Otherwise
    if(!is.na(recordi$family)){ 
      if(recordi$family != first_word){
      tfill$family[i] <- ifelse(first_word %in% taxon_fam$tribe[!is.na(taxon_fam$tribe)], 
                                "Chironominae", #only subfamily with tribes listed
                                first_word)
      tfill$family_recode[i] <- 1
    }}
  }
}

# Some ad-hoc changes that were missed:
tfill$genus[tfill$species == "Tubifex tubifex"] <- "Tubifex"

```

With genus and family fields correct, correct species names, using the following rules:

- Species without a formal identification, but with a single match to a bin_uri are given a species name using the bin_uri (e.g. );

- Species without a formal identification, that match two bin_uris are given a species names using both bin_uris separated by a "/" (e.g. );

- Species without a formal identification, that match three or more bin_uris are given a species names using one bin_Uri and the term "group" (e.g. );

- Species with a formal identification, that match one or more bin_uris (and none of those bin_uris are validly associated with any other formal species names) are given the formal species name as it is. (e.g. , which matches bin_uris....)

- Species with a formal identification, that match more than one bin_uris that are validly associated with two formal spcies names are given both species names separated by "/" (e.g.)

- Species with a formal identification, that match more than two bin_uris that are validly associated with two formal spcies names are given the most common formal species name followed by group (e.g.)

To begin this process, we ensure all species without formal identifications are given a name matching a single bin_uri (prior to grouping below).

```{r}

# check all B- species names match the first bin_uri for that species name
tfill$no_bin_match <- 0
for(i in grep("B-",tfill$species)){
  # remove all "group" and "/" names (to be re-instated later)
  tfill$species[i] <- gsub(" group", "", tfill$species[i])
  if(grepl("/", tfill$species[i])){
    tfill$species[i] <- substr(tfill$species[i], 1, nchar(tfill$species[i]) - 8)
  }
  bin_i <- match_list_bin_uri[tfill$asv_code[i]][[1]]
  if(nrow(bin_i) == 0)  {
    tfill$no_bin_match[i] <- 1
    }else{
#      if(!is.na(bin_i$bin_uri[1]) & bin_i$bin_uri[1] == "AAP5135") stop("1")
  tfill$species[i] <- paste0(substr(tfill$species[i], 1, nchar(tfill$species[i]) - 7), 
                             bin_i$bin_uri[1])
    }
}

# three given the wrong name in the above because of matches to multiple bin_uris. Correct manually
tfill$species[tfill$species == "Koorrnonga sp. B-ABV9140"] <- "Koorrnonga sp. B-ABV9142"
tfill$species[tfill$species == "Cryptochironomus sp. B-ACS3865"] <- "Cryptochironomus sp. B-ACS3851"
tfill$species[tfill$species == "Schizonyxhelea sp. B-ABX1780"] <- "Schizonyxhelea sp. B-ADT1789"

dodge_bs <- data.frame(species = unique(tfill$species[tfill$no_bin_match == 1]), 
                       some_bin_matches = 0)
for(i in 1:nrow(dodge_bs)){
  if(sum(tfill$no_bin_match[tfill$species == dodge_bs$species[i]]) != sum(tfill$species == dodge_bs$species[i]))
    dodge_bs$some_bin_matches[i] <- 1
}

# Having corrected the species names, update the species name in tfill_spp_bins
tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code,tfill$asv_code)]

```

The chunk below identifies the number of distinct species names associated with bin_uris. (There should only be one species name per bin_uri, while each species name can have multiple bin_uris).  

The loop creates a list to catch any groups of bin_uris that need to be given formal group names (form_gps).  To ensure transparent grouping decisions, we ran the loop first, and then made the requisit manual changes before re-running the loop.  

The loop also creates a list of groups with inconsistent names (inc_groups), which were similarly caught and corrected before re-running the loop.

```{r}
# Check for bin_url inconsistencies, and create new group names where appropriate
# This removed all such problems!
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]
tfill_spp_bins_unq_bu <- tfill_spp_bins_unq

# Formally named groups created after running the loop below first (identified in form_gps)
tfill$species[tfill$species %in% c("Tamasia acuta","Tamasia variegata")] <- "Tamasia acuta/Tamasia variegata"
tfill$species[tfill$species %in% c("Nannochorista dipteroides","Nannochorista dipteroides group")] <- "Nannochorista dipteroides"
tfill$species[tfill$species %in% c("Austropyrgus centralia","Austropyrgus turbatus","Austropyrgus centralia/turbatus")] <- "Austropyrgus centralia/turbatus"
tfill$species[tfill$species %in% c("Hydra oligactis","Hydra robusta")] <- "Hydra oligactis/robusta"
tfill$species[tfill$species %in% c("Hydra sinensis","Hydra viridissima")] <- "Hydra sinensis/viridissima"
tfill$species[tfill$species %in% c("Triplectides truncatus","Triplectides truncatus group")] <- "Triplectides truncatus"
tfill$species[tfill$species %in% c("Gynoplistia bimaculata","Gynoplistia lowanna")] <- "Gynoplistia bimaculata/lowanna"
tfill$species[tfill$species %in% c("Leptoperla kimminsi","Leptoperla kimminsi group")] <- "Leptoperla kimminsi"
tfill$species[tfill$species %in% c("Dinotoperla thwaitesi","Dinotoperla thwaitesi group")] <- "Dinotoperla thwaitesi"
tfill$species[tfill$species %in% c("Nais elinguis","Nais pseudobtusa")] <- "Nais elinguis/pseudobtusa"
tfill$species[tfill$species %in% c("Dinotoperla christinae", "Dinotoperla aryballoi")] <- "Dinotoperla christinae/aryballoi"
tfill$species[tfill$species %in% c("Rheumatometra dimorpha","Rheumatometra philarete")] <- "Rheumatometra dimorpha/philarete"
tfill$species[tfill$species == "Hydraena sp. B-NA"] <- "Hydraena sp. B-AFJ4718"
tfill$species[tfill$species == "Amphipoda sp. MC-BOLDNZ"] <- "Amphipoda sp. B-AFN5257"

# ABV0255   "Limnophyes sp. B-ABV0255"  NOT "Echinocladius martini" 
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABV0255" & 
                     tfill_spp_bins$species == "Echinocladius martini"]
tfill$species[tfill$asv_code %in% asvi] <- "Limnophyes sp. B-ABV0255"

# ABX0996 "Atrichopogon sp. B-ABX0996"  presumably not  "Ceratopogonidae sp. B-ABX0996"
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX0996" & 
                     tfill_spp_bins$species == "Ceratopogonidae sp. B-ABX0996"]
tfill$species[tfill$asv_code %in% asvi] <- "Atrichopogon sp. B-ABX0996"

# ABX1092 "Limnophila sp. B-ABX1092" "Ozeoura convoluta"  ("Limnophila sp. B-ABX1092" is the correct ID) 
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX1092"]
tfill$species[tfill$asv_code %in% asvi] <- "Limnophila sp. B-ABX1092"

# # ABX4126 "Eusthenia sp. B-ABX4126"  NOT "Dinotoperla thwaitesi"
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) &
                     tfill_spp_bins$bin_uri == "ABX4126" &
                     tfill_spp_bins$species == "Dinotoperla thwaitesi"]
tfill$species[tfill$asv_code %in% asvi] <- "Eusthenia sp. B-ABX4126"

# ACG2297 "Notriolus sp. B-ACG2297" "Elmidae sp. B-ACG2297" Notriolus (1)  
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ACG2297" & 
                     tfill_spp_bins$species == "Elmidae sp. B-ACG2297"]
tfill$species[tfill$asv_code %in% asvi] <- "Notriolus sp. B-ACG2297"

# ACN2323 "Hellyethira basilobata"     "Orthotrichia sp. B-ACN2323" Orthotrichia (3)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ACN2323" & 
                     tfill_spp_bins$species == "Hellyethira basilobata"]
tfill$species[tfill$asv_code %in% asvi] <- "Orthotrichia sp. B-ACN2323"

# ADJ9699 "Limnodrilus hoffmeisteri" "Naididae sp. B-ADJ9699"  Naididae (2)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ADJ9699" & 
                     tfill_spp_bins$species == "Limnodrilus hoffmeisteri"]
tfill$species[tfill$asv_code  %in% asvi] <- "Naididae sp. B-ADJ9699"

# AEV0976 "Simuliidae sp. B-AEV0976" "Simulium sp. B-AEV0976"  Simuliidae (corrected in previous script with manual grouping)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "AEV0976"]
tfill$species[tfill$asv_code %in% asvi] <- "Simulium sp. B-AEV0976"
tfill$genus[tfill$asv_code %in% asvi] <- "Simulium"

# ABX3905 "Trinotoperla nivata" (4), "Trinotoperla montana" (2) )
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX3905" & 
                     tfill_spp_bins$species == "Trinotoperla montana"]
tfill$species[tfill$asv_code %in% asvi] <- "Trinotoperla sp. B-ABX3905 group"

tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code, tfill$asv_code)]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]

# Formally named groups created after running the loop below first (identified in form_gps)
n_unq <- function(x) length(unique(x))
spp_per_bin <- aggregate(tfill_spp_bins_unq$species, by = list(bin_uri = tfill_spp_bins_unq$bin_uri), FUN = n_unq)
# The above process has created multiple names for some bin_uris. Here, find them, check they all share the first word, and then give them the same (temporary) name.
# keep formally named groups and inconsistently named groups for later consideration
form_gps <- inc_gps <- list()
for(i in which(spp_per_bin$x > 1)){
  spi <- unique(tfill_spp_bins$species[!is.na(tfill_spp_bins$bin_uri) & 
                                         tfill_spp_bins$bin_uri == spp_per_bin$bin_uri[i]])
  # Check all first words are the same
  if(length(unique(sapply(strsplit(spi," "),"[[",1))) != 1)  inc_gps <- c(inc_gps, list(spi))
  # Check if there is a non-B species name, if so, use that - if not, use the first name
  # first check no more than one non-B species name
  if(sum(!grepl(" B-", spi)) > 1)  form_gps <- c(form_gps, list(spi))
  if(sum(!grepl(" B-", spi)) == 1){
    tfill$species[tfill$species %in% spi] <- spi[!grepl(" B-", spi)]
  }else{
    tfill$species[tfill$species %in% spi] <- spi[1]
  }
}
# After the above corrections were applied form_gps and inc_gps are now empty.

tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code, tfill$asv_code)]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]

spp_per_bin <- aggregate(tfill_spp_bins_unq$species, by = list(bin_uri = tfill_spp_bins_unq$bin_uri), FUN = n_unq)
max(spp_per_bin$x) # 1 - so only one name per bin. Good! (It took a bit of effort to get there!)
```

```{r}
bins_per_sp <- aggregate(tfill_spp_bins_unq$bin_uri, by = list(species = tfill_spp_bins_unq$species), FUN = length)
# Any taxa named a group with only one bin_uri
bins_per_sp[bins_per_sp$x == 1 & grepl("group", bins_per_sp$species),]  # None. Good.

# Any group of bins with one formal species name leave it as the formal name
# Only one such species is already named group. (p1 Nais communis group)
p1 <- bins_per_sp[bins_per_sp$x > 1 & grepl("group", bins_per_sp$species) & 
              !grepl("B-", bins_per_sp$species),] 
# "B"- species names with more than one bin.
bin_spp_groups <- bins_per_sp[bins_per_sp$x > 1 & 
                  grepl("B-", bins_per_sp$species),]  # 53 
for(i in 1:nrow(bin_spp_groups)){
# Make new_name = the existing name (in preparation for changing it necessary)
  new_name <- bin_spp_groups$species[i]
  gp_bins_i <- tfill_spp_bins_unq[tfill_spp_bins_unq$species == bin_spp_groups$species[i],]
  #if the species names has just 2 bin_uris
  if(bin_spp_groups$x[i] == 2){
    # If the name already has a slash...
    if(grepl("/",bin_spp_groups$species[i])){
      # if the bin_uris in the name are right leave it and move on - if not stop for now...
      if(!(grepl(gp_bins_i$bin_uri[1],gp_bins_i$species[1]) & 
           grepl(gp_bins_i$bin_uri[2],gp_bins_i$species[1]))){
        stop("1")
      }
# and if the name doesn't have a slash, create a new 'slash' name.
    }else{
      bin_i <- right(bin_spp_groups$species[i],7)
      bin_i2 <- gp_bins_i$bin_uri[gp_bins_i$bin_uri != bin_i]
      sp_trunk_i <- substr(bin_spp_groups$species[i],1, nchar(bin_spp_groups$species[i]) - 7)
      # If the existing name doesn't match either of the bin_uris, stop for now...
      if(!bin_i %in% gp_bins_i$bin_uri){
        stop("2")
      }else{
        # Otherwise make new_name a new 'slash' name
        new_name <- paste0(sp_trunk_i, bin_i,"/",bin_i2)
      }
    }
    # and if the species names has more than 2 bin_uris
  }else{
        # If the name has a slash, rename it a group 
    if(grepl("/",bin_spp_groups$species[i])){
      sp_trunk_i <- substr(new_name, 1, nchar(new_name) - 8)
      new_name <- paste(sp_trunk_i, "group")
            # but if this new name does not match one of the bin_uris, stop for now...
      if(!right(sp_trunk_i,7) %in% gp_bins_i$bin_uri)
              stop("3")
    }else{
        # if no slash and if the bin_uri in the name doesn't match any of the bin_uris, stop for now...
      bin_i <- right(bin_spp_groups$species[i],7)
      if(!bin_i %in% gp_bins_i$bin_uri){
        stop("4")
      }else{
        # otherwise, just add group the existing name to make new_name
        new_name <- paste(new_name, "group")
      }
    }
  }
  tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == bin_spp_groups$species[i]]  <- new_name
  tfill_spp_bins$species[tfill_spp_bins$species == bin_spp_groups$species[i]]  <- new_name
  tfill$species[tfill$species == bin_spp_groups$species[i]]  <- new_name
}

# Check that tfill and tfill_spp_bins are consistent.
for(i in 1:nrow(tfill_spp_bins)){
  if(tfill$species[tfill$asv_code == tfill_spp_bins$asv_code[i]] != tfill_spp_bins$species[i])
    stop("Check")
}
tfill_spp_bins_unq <- unique(tfill_spp_bins[,c("species","bin_uri")])

check <- tfill_spp_bins[!grepl("group", tfill_spp_bins$species) & 
                          !grepl("/", tfill_spp_bins$species) & 
                          grepl("B-", tfill_spp_bins$species),]
wronguns <- check[!is.na(check$bin_uri) & check$bin_uri != right(check$species,7),]
# Zero wronguns ...run the following if wronguns return....
# unq_wronguns <- unique(wronguns$species)
# for(i in 1:length(unq_wronguns)){
#   pot_group_i <- tfill_spp_bins_unq[tfill_spp_bins_unq$species == unq_wronguns[i],]
#   if(nrow(pot_group_i) == 2 & sum(pot_group_i$bin_uri == right(pot_group_i$species,7)) == 1){
#     group_name_i <- paste0(substr(unq_wronguns[i],1,nchar(unq_wronguns[i]) - 7),
#                             pot_group_i$bin_uri[1], "/", pot_group_i$bin_uri[2])
#     tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == unq_wronguns[i]] <- group_name_i
#     tfill$species[tfill$species == unq_wronguns[i]] <- group_name_i
#     wronguns <- wronguns[wronguns$species != unq_wronguns[i],]
#     }
#   if(nrow(pot_group_i) > 2 & sum(pot_group_i$bin_uri == right(pot_group_i$species,7)) == 1){
#     group_name_i <- paste0(unq_wronguns[i], " group")
#     tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == unq_wronguns[i]] <- group_name_i 
#     tfill$species[tfill$species == unq_wronguns[i]] <- group_name_i
#     wronguns <- wronguns[wronguns$species != unq_wronguns[i],]
#   }
# }

```

A number of records only showed matches to sequences deposited on GenBank or records on the bold BarcodID web interface when private and public sequences were searched or were specimens sequenced by us but not yet published on bold database. These sequences could not be checked via bold::bold_identify() function.

```{r}
# 379 asv_codes in the same group have NA bin_uri. The following code collates those asv_codes for future reference
seq_no_match_to_bold_sp <- tfill_spp_bins[0,]
unq_spp <- unique(tfill$species)
for(i in 1:length(unq_spp)){
  sp_bin_i <- tfill_spp_bins[tfill_spp_bins$species== unq_spp[i],]
  if(sum(is.na(sp_bin_i$bin_uri)) > 0 & sum(is.na(sp_bin_i$bin_uri)) < nrow(sp_bin_i)){
    seq_no_match_to_bold_sp <- rbind(seq_no_match_to_bold_sp, sp_bin_i[is.na(sp_bin_i$bin_uri),])
  }
}
seq_no_match_to_bold_sp$bold_id3 <- seq_no_match_to_bold_sp$bold_id2 <- seq_no_match_to_bold_sp$bold_id1 <- NA
seq_no_match_to_bold_sp$max_sim <- NA
for(i in 1:nrow(seq_no_match_to_bold_sp)){
  bin_uri_other_records <- 
    unique(tfill_spp_bins$bin_uri[tfill_spp_bins$species == seq_no_match_to_bold_sp$species[i]])
  bin_uri_other_records <- bin_uri_other_records[!is.na(bin_uri_other_records)]
  seq_no_match_to_bold_sp$bin_uri[i] <- paste(bin_uri_other_records, collapse = ", ")
bold_match_i <- match_list[seq_no_match_to_bold_sp$asv_code[i]][[1]]
if(nrow(bold_match_i) > 0){
bold_names_i <- aggregate(bold_match_i$taxonomicidentification, 
                  by = list(species = bold_match_i$taxonomicidentification), FUN = length)
bold_names_i <- bold_names_i[order(bold_names_i$x, decreasing = TRUE),]
seq_no_match_to_bold_sp$bold_id1[i] <- bold_names_i$species[1]
if(nrow(seq_no_match_to_bold_sp) > 1)
seq_no_match_to_bold_sp$bold_id2[i] <- bold_names_i$species[2]
if(nrow(seq_no_match_to_bold_sp) > 3)
seq_no_match_to_bold_sp$bold_id3[i] <- bold_names_i$species[3]
seq_no_match_to_bold_sp$max_sim[i] <- max(bold_match_i$similarity)
}
}
WriteXLS::WriteXLS(seq_no_match_to_bold_sp, "~/temp/seq_no_match_to_bold_sp.xlsx")
```


Recompile final ASV_library tables, adding back in the non-macroinvertebrate, non-aquatic species removed before the above BOLD matches, adding a column "cw_checked" to identify those records that have been checked by the above processes (cw_checked = 1), and species excluded by the only_aqu_inverts() function (cw_checked = 0)

```{r}
# separate the records originally taken from the max_p_update sheet (imported as x4 above)
tfill$cw_checked <- 1
max_p_update <- tfill[tfill$asv_code %in% max_p_update_df$asv_code,]
tfill_t <- tfill[!tfill$asv_code %in% max_p_update_df$asv_code,]

tfill_non_am <- tfill_all[!tfill_all$asv_code %in% tfill_t$asv_code & 
                            !tfill_all$asv_code %in% max_p_update_df$asv_code,]
tfill_non_am$cw_checked <- 0 
tfill_non_am <- dplyr::mutate(tfill_non_am, species_old = tfill_non_am$species, genus_old = tfill_non_am$genus, 
                              family_old = tfill_non_am$family, genus_recode = 0, family_recode = 0,
                              no_bin_match = NA,
                              .before = cw_checked)
tfill_non_am <- tfill_non_am[!duplicated(tfill_non_am$asv_code),]
tfill_t <- rbind(tfill_t, tfill_non_am)

max_p_update_non_am <- tfill_all[!tfill_all$asv_code %in% tfill_t$asv_code & 
                                   !tfill_all$asv_code %in% max_p_update$asv_code & 
                                   tfill_all$asv_code %in% max_p_update_df$asv_code,]
max_p_update_non_am$cw_checked <- 0 
max_p_update_non_am <- dplyr::mutate(max_p_update_non_am, species_old = max_p_update_non_am$species, 
                                     genus_old = max_p_update_non_am$genus, 
                              family_old = max_p_update_non_am$family, 
                              genus_recode = 0, family_recode = 0,
                              no_bin_match = NA,
                              .before = cw_checked)
max_p_update <- rbind(max_p_update, max_p_update_non_am)

# Some ad-hoc corrections to max_p_update not captured with the above being restricted to aquatic records
max_p_update$genus[!is.na(max_p_update$genus) & max_p_update$genus == "Cernosvitoviella aggtelekiensis"] <- "Cernosvitoviella"
max_p_update$genus[!is.na(max_p_update$species) & max_p_update$species == "Cernosvitoviella aggtelekiensis "] <- "Cernosvitoviella sp. (Unident.)"
max_p_update$species[!is.na(max_p_update$genus) & max_p_update$genus == "Miselaoma"] <- "Miselaoma sinistra"
max_p_update$genus[grep("idae",max_p_update$genus)] <- NA
max_p_update$species <- gsub("\\(sp. Unident.\\)","sp. (Unident.)",max_p_update$species)
max_p_update$species[!is.na(max_p_update$genus) & grepl("Unident.", max_p_update$species)] <- 
  paste0(max_p_update$genus[!is.na(max_p_update$genus) & grepl("Unident.", max_p_update$species)],
         " sp. (Unident.)")
max_p_update$species[!is.na(max_p_update$family) & is.na(max_p_update$genus) & grepl("Unident.", max_p_update$species)] <- 
  paste0(max_p_update$family[!is.na(max_p_update$family) & is.na(max_p_update$genus) & grepl("Unident.", max_p_update$species)],
         " sp. (Unident.)")

nrow(max_p_update) + nrow(tfill_t) #15593 = number of rows in tfill_all

wd <- "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/"
WriteXLS::WriteXLS(list(truncated_fills = tfill_t, 
                        max_p_update = max_p_update,
                        bin_uris = tfill_spp_bins_unq),
                        ExcelFileName = paste0(wd, "asv_library_cw_corrected.xlsx"))

# # tfill <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "asv_library")
# max_p_update <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "max_p_update")
# bin_uris <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "bin_uris")
# load(paste0(wd, "asv_library_97_match_list_with_bin_uris_2024-12-11.rda"))
# match_list_bin_uri[tfill$asv_code[1]]
# tfill$asv_code[1]
```