---
title: "Corrections_to_ASV_library"
author: "MCarew"
date: "2024-09-06"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Function equivalent to excel's =RIGHT() and =LEFT() functions
right <- function(x, n) {substr(x, nchar(x) - n + 1, nchar(x))}
left <- function(x, n) {substr(x, 1, n)}
```

## Introduction

This document amends the file 'asv_library_97_aug24.xlsx' [MEL: can you describe how this file was generated? Are there scripts or was it all in excel?] by:  

- adding records from subsequent miSeq runs [MEL: is this the right way to describe the origin of the addition records?];

- correcting spelling errors in taxonomic names;

- looking up identifiers matching the sequences from boldsystems.org, naming un-named aquatic macroinvertebrate species using their BOLD identifiers (bin_uri), and grouping species with multiple bin_uris that overlap with >97% similarity

- recompiling the worksheets of 'asv_library_97_aug24.xlsx' and saving it as ''asv_library_97_jan25.xlsx'.

# Read in source data 

First, primary data from 'asv_library_97_aug24.xlsx' spreadsheets

```{r}
# read in files

## [MEL: please note I have copied the source files this script needs to the new folder asv_source_files. The should only ever be read and not edited from now on. All other asv_library files can be removed from the main metabarcoding_workflow folder, I think!, and this script creates a new asv_library file that can be further corrected/updated as we find errors in the script.  THERE IS NO NEED TO BE MAKING AND SAVING MULTIPLE VERSIONS - if the source files remain unchanged, this script will do the necessary changes to the final file]

source_path <- "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_source_files/"
source_file <- "asv_library_97_aug24.xlsx"

# Read the sheets into as dataframes
tf0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                        sheet = "truncated_fills"))  
  # contains full taxonomic information for classifications with truncated taxonomy
otu_groups_df <- 
  as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                          sheet = "otu_groups", col_types = "text")) 
  # groups unclassified sequences into 'OTUs'
mp0 <- as.data.frame(readxl::read_excel(paste0(source_path,source_file), 
                                                    sheet = "max_p_update"))
 # remove a duplicate record
mp0 <- mp0[!duplicated(mp0),]
  #updates/corrects any missing identifications or errors in classification
# [MEL: I don't really get your explanation of what max_p_update is for...can you rephrase?]
complexes_df <- readxl::read_excel(paste0(source_path,source_file),
                                       sheet = "complexes")

```

Then, additional data from:

- additions_asv_library_oct24.xlsx (additional records for truncated_fills); [MEL: can you describe where these additional records come from?]

- asv_library_97_add_miseq15-20_records.csv (additional records for truncated_fills  from miSeq runs 15-20 with species identifications that match those in the above source tables for truncated_fills);

- filtered_<97_data.csv;

```{r}
# Additional truncated_fills records
tf1 <- as.data.frame(readxl::read_excel(paste0(source_path, 
                                               "additions_asv_library_oct24.xlsx"), 
                                        sheet = "trunc_fills")) 
tf2 <- read.csv(paste0(source_path, "asv_library_97_add_miseq15-20_records.csv"))[,-1]

# Combine the three truncated_fill source tables into a new table 
# (keeping all three original tables to permit back-checking)
truncated_fills_df <- rbind(tf0, tf1, tf2)

# Additional max_p_update records
mp1 <- read.csv(paste0(source_path, "filtered_97_data.csv"))
# [MEL: see email about what I have assumed needed doing here and correct as necessary]
# update max_p_identify for those records with a corrected value
mp1$max_p_identity[!is.na(mp1$max_p_identity_corrected)] <- 
  mp1$max_p_identity_corrected[!is.na(mp1$max_p_identity_corrected)]
# [MEL: species names for those records are updated below - I have not used the 'recomended_species_name' field: see my email
# Combine the source tables into a new table, but replace records in mp0 with those in mp1 where there are duplicates
max_p_update_df <- rbind(mp0[!mp0$asv_code %in% mp1$asv_code,], 
                         mp1[match(names(mp0),names(mp1))])

# Keep max_p_update_df records and remove matching records from truncated_fills
# [MEL: as per my email, is this the right thing to do?]
truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in%
                                           max_p_update_df$asv_code,]

# replace "" with NA throughout
# [MEL: perhaps this will cause a problem with your 06 script? It is more usual to 
#  use NA for missing values....let me know if it is a problem]
truncated_fills_df[truncated_fills_df == ""] <- NA
max_p_update_df[max_p_update_df == ""] <- NA

# Check for duplicate asv_codes/sequences
sum(duplicated(truncated_fills_df$asv_code)) # 2 - not good
 # Remove the one complete duplicate
truncated_fills_df <- truncated_fills_df[!duplicated(truncated_fills_df),]
 # [MEL: you need to decide which of the following need to be removed
truncated_fills_df[duplicated(truncated_fills_df$asv_code) | 
                  duplicated(truncated_fills_df$asv_code, fromLast = TRUE),]
 # I have assumed the one with max_p_identity = 98.0 (Just change 99.3 to 98.0 if I have guessed wrong)
truncated_fills_df <- 
  truncated_fills_df[!(duplicated(truncated_fills_df$asv_code) & 
                        truncated_fills_df$max_p_identity == 99.3),]
sum(duplicated(c(truncated_fills_df$asv_code, max_p_update_df$asv_code))) # 0 - good

#[MEL: this is a weird non-aquatic entry that you corrected family and genus in two different places in your script. 
# Here I also correct the other taxonomic levels, but I really don't want to be messing around with non-aquatic species.
# Are you sure this is right.  IT IS VERY ODD!]
truncated_fills_df[truncated_fills_df$asv_code == "9ca9760013a77462d9c5e2c942e4d27e",
                   c("phylum","class","order","family","genus")] <- 
                c("Heterokontophyta","Oomycota","Peronosporales", "Peronosporaceae", "Phytophthora")

#[MEL: in your Appendix 2 script, you deleted these three records. I haven't done so here - they look alright to me.  
# If you are sure they need to go, then delete the following command and uncomment the commented out lines below
# (this will change my reported line counts in the docment below)]
truncated_fills_df[truncated_fills_df$asv_code %in% c("9725daabf323ef5cf9b512ee0b06f682", 
                                                     "160985800d21d905b2e3dff1edc1bf18", 
                                                     "238f54c32343060e69613167f345dd15"),]
# [MEL: code for deleting them if you are sure they really should be deleted]
# truncated_fills_df <- truncated_fills_df[!truncated_fills_df$asv_code %in% c("9725daabf323ef5cf9b512ee0b06f682", 
#                                                      "160985800d21d905b2e3dff1edc1bf18", 
#                                                      "238f54c32343060e69613167f345dd15"),]
```

The truncated_fills_df and max_p_update_df are now complete with unique records from all source files (13613 and 1983 records respectively). To make corrections to taxonomic naming more efficient, the following combines the two tables for recompilation at the end of this document (using asv_codes to re-assemble the two tables).

Taxonomic corrections have been made only to aquatic macroinvertebrates, excluding non-aquatic, non-macroinvertebrate species using the function only_aqu_inverts() in bug_database_functions.R from the [mwbugs database website](https:://tools.thewerg.unimelb.edu.au/mwbugs/data_dl.html). In this document, the function reads from the table of exclusions (), which is a copy of the table of the same name in the mwbugs database.

Similarly to correct genus and family names in the library, we use the taxonomic tables from the mwbugs database.

```{r}
tfill_all <- rbind(truncated_fills_df, max_p_update_df)    # 15596 records

source("https://tools.thewerg.unimelb.edu.au/data/mwbugs/bug_database_functions.R")
# Record of how non_aqu_macroinvert.csv was created
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# non_aqu_macro_invert <- DBI::dbReadTable(db, "non_aqu_macro_invert")
# write.csv(non_aqu_macro_invert, 
#           "~/git/metabarcoding_workflow/data/non_aqu_macro_invert.csv", 
#           row.names = FALSE)
non_aqu_macro_invert <- read.csv("data/non_aqu_macro_invert.csv")

# Record of how taxonomy.xlsx was created, noting that when complete this can be read 
# directly from the mwbugs downloads page (not yet updated)
# db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
# taxon_gen <- DBI::dbReadTable(db, "taxon_gen")
# taxon_fam <- DBI::dbReadTable(db, "taxon_fam")
# WriteXLS::WriteXLS(list(taxon_gen = taxon_gen, taxon_fam = taxon_fam),
#           "~/git/metabarcoding_workflow/data/taxonomy.xlsx")
taxon_gen <- readxl::read_excel("~/git/metabarcoding_workflow/data/taxonomy.xlsx", 
                                "taxon_gen")
taxon_fam <- readxl::read_excel("~/git/metabarcoding_workflow/data/taxonomy.xlsx", 
                                "taxon_fam")

tfill <- only_aqu_inverts(tfill_all, 
                          non_aqu_macro_invert_already_loaded = TRUE)$include #11,975 records
# And exclude two additional records only identified to phylum (Arthropoda and Zygomycota)
tfill <- tfill[!is.na(tfill$species),]  #11,973 records
#[MEL: are you also happy to leave Isopoda sp. MC-1 out of aquatic consideration?]
tfill <- tfill[tfill$species != "Isopoda sp. MC-1",] #11,953 records

```

Note that tfill_all records excluded from tfill will be added unchanged to the final table at the end.

The term 'complex' in the asv_library is changed to 'group' to remove any implication of true taxonomic complexes in the grouping of species. Finally, spelling errors in the source data are corrected.

[MEL: Note that the following is a reduced version of your code chunks that corrected spelling.
      Note several major differences:
      1. Having (temporarily) reduced and combined the truncated_fills and maximum_p_update tables above, there is no need to duplicated these corrections as you had in your script
      2. The corrections are made line-by-line rather than being grouped into a single dplyr::mutate function.  This permits easier checking that each line a) is necessary and b) does what is intended.
      3. gsub() is used sparingly - only to make partial changes that are relevant to multiple species names. 
      4. Where a single species name is being replaced with a corrected name, it is better to use the approach I use after the gsub lines. By running the left hand side of each statement you can check if the change is necessary (several in your script weren't: the left hand side returned no records)]
      5. Corrections to B- codes are no longer done here- they are done more systematically later in the script ]

```{r}
# Keep a record of the original species name for checking later on.
tfill$species_old <- tfill$species
# Correct spelling errors
tfill$species <- gsub("  ", " ", tfill$species)
tfill$species <- gsub("Cricptopus", "Cricotopus", tfill$species)
tfill$species <- gsub("sp.B", "sp. B", tfill$species)
tfill$species <- gsub("GB-", "G-", tfill$species)
tfill$species <- gsub("ZB-", "", tfill$species)
tfill$species <- gsub("complex", "group", tfill$species)
tfill$species <- gsub("Iilliesoperla","Illiesoperla",tfill$species)

tfill$species[grep("Asmicridea edwardsi", tfill$species)] <- "Asmicridea edwardsii"
tfill$species[tfill$species == "Chironomidae sp. B-ABX4803"] <- "Chironominae sp. B-ABX4803"
tfill$species[tfill$species == "Chironomidae sp. B-AEE9278"] <- "Orthocladiinae sp. B-AEE9278"
tfill$species[tfill$species == "Dero obtusa"] <- "Dero obtusa/nivea"
tfill$species[tfill$species == "Lingora aurata"] <- "Lingora aurata group"
tfill$species[tfill$species == "Limnodrilus claparedeanus"] <- "Limnodrilus claparedianus"
tfill$species[tfill$species == "Antiporus gilbertii"] <- "Antiporus gilberti"
tfill$species[tfill$species == "Austrolimnius waterhouseii"] <- "Austrolimnius waterhousei"
tfill$species[tfill$species == "Culicoides bundyensi"] <- "Culicoides bundyensis"
tfill$species[tfill$species == "Hyderodes shuckardi"] <- "Hyderodes schuckardi"
tfill$species[tfill$species == "SImsonia longipes"] <- "Simsonia longipes"
tfill$species[tfill$species == "Musculium sp. B-ADJ8477"] <- "Sphaerium sp. B-ADJ8477"
tfill$species[tfill$species == "Dinotoperla aff. thwaitesi"] <- "Dinotoperla thwaitesi group"
tfill$species[tfill$species == "Austropyrgus centralia group"] <- "Austropyrgus centralia/turbatus"
tfill$species[tfill$species == "Centroptilum sp. B-ACM3150"] <- "Centroptilum elongatum"
tfill$species[tfill$species == "Hydraenidae sp. B-ADK5039"] <- "Gymnochthebius australis"
tfill$species[tfill$species == "Helicophida queenslandensis"] <- "Helicopha queenslandensis"
tfill$species[tfill$species == "Riethia zeylandica"] <- "Riethia sp. B-ADU5431" 
# [MEL: As you noted "Riethia zeylandica is not found in Australia": the above is a temporary name to be grouped below]
tfill$species[tfill$species == "Notalina bifara group B-ABV8023"] <- "Notalina bifara"
tfill$species[tfill$species == "Notalina sp. B-AAX5636"] <- "Notalina bifara"
# [MEL: Perhaps you want to call this "Notalina bifara group"? (the two bin_uris overlap...you had originally called this "Notalina bifara  B-ABV8023 group"!)]
tfill$species[tfill$species == "Ferrissia sp. MC-1"] <- "Ferrissia sp. B-AAE6642"
# [MEL: You had renamed this "Ferrissia sp. B-AAY1880" group" but it only matches "ADR7371", "AAE6642" and "ADR3550". There is no AAY1880 in the library dataset. Are you happy for this to be called "Ferrissia sp. B-AAE6642 group"?)]

# [MEL: the spelling corrections in your Appendix 2 of species with B- names are taken care of automatically below.
#       Some have ended up using different bin_uris than their original names, but I don't think this matters (the 
#       changes can be tracked easily using the species_old field).  One of your original changes doesn't seem right
#       ...unless I've made a mistake somewhere...
# tfill$species[tfill$species == "Trinotoperla sp. complex B-ABX3905"] <- "Trinotoperla sp. B-ABX3905 group"
#  ...as far as I can tell, there is no other bin_uris overlap with ABX3905
# ]
```

The following was run using the bold package V1.3.0 to download from the boldsystems API  before their upgrade at the end of 2024. The script thus includes steps to allow for errors arising from exceeding download quotas from bold.  It involves two steps:

- First, match_list is a list of tables, each table the complete list of matching  BOLD records to the asv_sequence in the input data (using the function bold_identify).  The name of each table in the list is the asv_code.

- Second, match_list_bin_uri is a list of tables with same names as those in match_list but each table is reduced to include only those records that are >=97% similar to the asv_sequence. The function bold_specimens() is then used to extract the 
bin_uri for each BOLD ID.  

It is likely that the new API will not require the steps to work around errors or the two-step process for extracting bin_uris.
The process was error free using RStudio 2024.09.0 (Each step took ~30 h to  extract data for 10,000 asv records), but failed many times, requiring restarting of the loop in both steps, using RStudio Server 2023.03.02

The following chunk is step 1, saving the full list of BOLD matches (each with name = asv_code) to "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library_97_match_list_to_BOLD_2024-12-05.rda".

[MEL: when we have finalised this, we need to place big files such as these match_list files in a repository, and then re-write this script to allow users to download and use them. I can help you do this. (Note for me later on - example code at L20 of https://github.com/cjbwalsh/urban_riffle_experiment/blob/master/urban_riffle_exp_figs_code.qmd)]

The chunk is set not to evaluate, as it took ~30 h to run.

[MEL: Don't run this chunk!]

```{r eval:FALSE}

match_list <- list()

# Download all matching records from bold for each asv record 
for(i in 1:nrow(tfill)){  
  # ran without error on RCP server in a single process (taking ~30 h)
  seqi <- tfill$asv_seq[i]
  # The BOLD server returns an error if it is being overloaded
  # Here I handle this with the retry function
  matchi <- retry::retry(bold::bold_identify(seqi, db = "COX1"),
                         when = "NULL", max_tries=12, interval= (5 * 60 + 1))
  # Name each list element by asv_code (which should remain unchanged)
  names(matchi) <- tfill$asv_code[i]
  match_list <- c(match_list, matchi)
  # Save a working copy and report progress every 100 iterations.
  if(i %% 100 == 0)  
    cat(i, as.character(Sys.time()),"\n")
  save(match_list, file = paste0("~/temp/match_list_rerun.rda"))
}

# Saved to same folder as asv data source files with datestamp to avoid over-writing
save(match_list, file = 
       paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_to_BOLD_", Sys.Date(), ".rda"))
```

The following chunk then reduces each match_list table to those records with >=97% similarity and extracts their bin_uris, saving them as a second list of tables with fields: ID, taxonomicidentification, similarity, specimen_country, bin_uri.

The list was saved as "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/asv_library_97_match_list_with_bin_uris2024-12-05.rda".

[MEL: Note that the name of each table allows matching back to the original asv tables (via the asv_code field), and the ID field in each table allows matching back to the BOLD records saved in the match_list list tables.]

As above, the chunk is set not to evaluate, as it also took ~30 h to run.

[MEL: Don't run this chunk either!]

```{r eval:FALSE}

match_list_bin_uri <- list()

system.time({
  # ran without error on RCP server in a single process (taking ~30 h)
  for(i in 1:length(match_list)) { 
        matchi <- match_list[[i]][match_list[[i]]$similarity >= 0.97,
                                  c("ID","taxonomicidentification","similarity","specimen_country")]
        # If there are no sufficiently similar BOLD records, create a blank record
        if(nrow(matchi) == 0){
          matchi <- data.frame(ID = NA, taxonomicidentification = NA,
                               similarity = NA, specimen_country = NA,
                               bin_uri = NA)[0,]
        }else{
          # Otherwise use the bold_specimens function to extract the bin_uri for each record.
          if(nrow(matchi) <= 50) {
            bini <- bold::bold_specimens(ids = matchi$ID) #seqspec
          }else{
            # If there are more than 50 sufficiently similar records, break it into lots
            # of 50 or less so as not to overload the BOLD API
            J <- c(which(1:nrow(matchi) %% 50 == 0),nrow(matchi))
            for(j in 1:length(J)){
              indJ <- ifelse(j == 1, 1, J[j - 1] + 1):J[j] 
              binj <- bold::bold_specimens(ids = matchi$ID[indJ])
              Sys.sleep(1)
              if(j == 1){
                bini <- binj
              }else{
                bini <- rbind(bini, binj)
              }
            }   
          }
          # The bold_specimens function returns a warning if the BOLD API quota is 
          # exceeded. Catch this warning and wait up to 70 minutes (trying every 5 min) 
          # until the API begins accepting requests again.
          if(grepl("exceeded",names(bini)[1])){
            cat("BOLD retrieval quota exceeded: pausing process at i =", i,"\n")
            tries <- 1
            retry_time_seconds <- c(61,4)*60
            while(grepl("exceeded",names(bini[1])) & tries <= 2){
              Sys.sleep(retry_time_seconds[tries])
              if(nrow(matchi) == 0){
                matchi <- data.frame(ID = NA, taxonomicidentification = NA,
                                     similarity = NA, specimen_country = NA,
                                     bin_uri = NA)[0,]
              }else{
                # Otherwise use the bold_specimens function to extract the bin_uri for each record.
                if(nrow(matchi) <= 50) {
                  bini <- bold::bold_specimens(ids = matchi$ID) #seqspec
                }else{
                  # If there are more than 50 sufficiently similar records, break it into lots
                  # of 50 or less so as not to overload the BOLD API
                  J <- c(which(1:nrow(matchi) %% 50 == 0),nrow(matchi))
                  for(j in 1:length(J)){
                    indJ <- ifelse(j == 1, 1, J[j - 1] + 1):J[j] 
                    binj <- bold::bold_specimens(ids = matchi$ID[indJ])
                    Sys.sleep(1)
                    if(j == 1){
                      bini <- binj
                    }else{
                      bini <- rbind(bini, binj)
                    }
                  }
                }
              }
              cat("...for", cumsum(retry_time_seconds[1:tries])[tries]/60, "minutes")
              tries <- tries + 1
            }
          }
          # A very small number of bini get returned with no header row.
          # This is a work around for them
          if(names(bini)[1] != "processid"){
            stop("2: missing header row?")
            bini <- bini[,c(1,grep("BOLD",names(bini)[1]))]
            lostline <- names(bini)
            names(bini) <- c("processid","bin_uri")
            bini <- rbind(data.frame(processid = lostline[i],bin_uri = lostline[2]),
                          bini)
          }
          bini <- bini[,c("processid","bin_uri")]
          matchi$bin_uri <- gsub("BOLD:","",bini$bin_uri[match(matchi$ID,bini$processid)])
          # add the reduced table with bin_uri to match_list_bin_uri
        }
        match_list_bin_uri <- c(match_list_bin_uri,list(matchi))
        if(length(match_list_bin_uri) != i ) stop("1")
        names(match_list_bin_uri)[i] <- names(match_list)[i]
        # Save a working copy and report progress every 100 iterations.
        if(i %% 100 == 0){
          save(match_list_bin_uri, 
               file = paste0("~/temp/match_list_bin_uri.rda"))
          cat(i, as.character(Sys.time()),"\n")
        }
      }
    })  
    
# Saved to same folder as asv data source files with datestamp to avoid over-writing
save(match_list_bin_uri, file = 
       paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_with_bin_uris_", Sys.Date(), ".rda"))

```

Some ad-hoc changes to provisional species names can be made without recourse to the BOLD database.  They are made here first.

```{r}

tfill$species[tfill$species == "Austrochiltonia sp. MC-1"] <- 
                                                 "Austrochiltonia australis"
tfill$species[tfill$species == "Culicoides sp. MC-24"] <- 
                                                      "Culicoides sigmoidus"
tfill$species[tfill$species == "Limnophyes sp. MC-A1"] <- 
                                                  "Limnophyes sp. B-ABW5528"
tfill$species[tfill$species == "Limoniidae sp. MC-1"] <- 
                                                   "Limnophilinae sp. B-ABW2416"
tfill$species[tfill$species == "Limoniidae sp. MC-2"] <- 
                                                   "Limnophilinae sp. B-ABX1292"
tfill$species[tfill$species == "Isopoda sp. B-ACG3222"] <- 
                                                  "Sphaeromatidae sp. B-ACG3222"
```

[MEL: here are some comments on changes in your earlier Appendix 2. FYI. This chunk can be deleted if you are happy]
```{r}
asv_family_corrections_tf <- c("b167c9e6e63d586c8f79138f640da0cb" = "Eustheniidae",
  # taken care of automatically below.
"9ca9760013a77462d9c5e2c942e4d27e" = "Peronosporaceae")
  # not aquatic - changes added above...as are the following three lines)
asv_order_corrections_tf <- c("9ca9760013a77462d9c5e2c942e4d27e" = "Peronosporales")
asv_class_corrections_tf <- c("9ca9760013a77462d9c5e2c942e4d27e" = "Oomycota")
asv_phylum_corrections_tf <- c("9ca9760013a77462d9c5e2c942e4d27e" = "Heterokontophyta")

# The following not necessary - captured automatically below (but correction to 
# Ulmerophlebia genus (from Ulmerochorema) name added below)
asv_species_corrections_mpu <- c("d54cf91de2a56cbde204c32eea369742" = "Fridericia sp. B-ADR5065",
                             "a3b763c11784ab20ccb6053c998cd0e4" = "Ulmerophlebia sp. B-ABV8830",
                             "b0c8e99497b5ab0e503fa633d238f220" = "Zavrelimyia sp. B-AEN0522/AEN0524")
                             # Update the species column based on asv_code matching the correction vector
# As above, correction to Ulmerophlebia in genus field captured below 
asv_genus_corrections_mpu <- c("a3b763c11784ab20ccb6053c998cd0e4" = "Ulmerophlebia")
# And correction to family field also updated automatically (with correct spelling, as opposed to this)
asv_family_corrections_mpu <- c("a3b763c11784ab20ccb6053c998cd0e4" = "Leptophelbiidae")
# And this change to max_p_identity added to asv_list in next chunk
asv_max_p_identity_corrections_mpu <- c("a3b763c11784ab20ccb6053c998cd0e4" = "97")
```

# add corrections to revised matches  
[MEL: I'm not crazy about this matching by asv_codes, but I don't understand enough about these changes to revise them in a safer way.
Can you tell me where you got these values from?
I've left them as they are, but have changed the code for making the changes from dplyr to base code]
```{r}
max_p_identity_corrections <- c("9e5035bf7ec6a1f2c651ed0e98ed2da7" = "96.6",
"d453f558117b6d43a6d2feafbd877e0e" = "96.4",
"5ec678fc07a30a88297abe1aa71a4ead" = "96.5",
"d32a5e240858359c1bd7d6ebde67fe5b" = "96.5",
"314b908770c6f9c296aaab2da5698807" = "96.7",
"81530c1415a28a9a62322a482d714cef" = "94.6",
"3dc52e2c7a31e2a01a84549b92911bcb" = "95",
"f0e1b9af3b6dbb9a5afc88807a33f535" = "95",
"aa465397725596f1c084e4e48197372d" = "96",
"155515de679ea3f96eb251597a8355f5" = "96",
"7e9db264fabad9a9b2ac755cc524baa3" = "96.7",
"66c7e7bc806cfca10de70609b1ae1117" = "96.5",
"7abdbe52662941a5b1d6956f74fc8ccf" = "96.7",
"fb92efc10fba6e13b30c4e20f3f4be70" = "96.7",
"d971c3c25d994549e1ab94b17048486a" = "96.4",
"2a8674533aa6463808dced5102f0a1e5" = "96.5",
"384f60818615b4dc43d21b4fde820d21" = "96.4",
"2a09b204ea25d3ee0c23b26d00822dcf" = "96.4",
"c3ef326630a4b7eee124b7f4aa844cd6" = "96.4",
"3ea037839cc56c6adab4409ca544f57a" = "96",
"5fa5b580d9fb1c0503c5b4d05ce567e0" = "96.4",
"f2700c9ffaef418a7a9823b08b2b83c9" = "96.8",
"6a9ea49438ba346534d213bc5fa3412e" = "96.8",
"693405ffa22eb11c8a4302db0e8b6b7e" = "96.8",
"edc9cb8e69fe75af9826b60ecbc8f39b" = "96.8",
"a06bcf800ab074457f826c9026d93a05" = "96.8",
"60b0c55b3de6bcf0a4a4d4f2485a7ff7" = "90",
"c648f0859a67b40edf948409b8a4967a" = "90",
"bb9f84db19013052915d3b1ac559f11f" = "90",
"c3a2b4cfa3238dd8f6e5bf800290fd05" = "93",
"c56010a8847101c6f955be8758ba6963" = "95",
"f4c35e10c8e86a6dcee244a349473149" = "95",
"0bcf51bb494deb438b90e3e956a645bb" = "95",
"17edbbd11bdd22030c71999c0ed07036" = "95",
"2aadb65453c6df2420448394917cbc2f" = "95",
"94dda310e20d3e23a2752787a41a30f3" = "96",
"cb50aead3ff372183a06f8d09c03ef86" = "96.7",
"48b5d8e5472a2cf15d8acf17bfe90ccc" = "96.5",
"aad7ed86c3f30cfe5ee5bf4b8226d159" = "96.7",
"8ef04e58e9a04a7345c1310b8cc48b58" = "96",
"e64a94ea4d2c5000abac84231068b15b" = "96.5",
"65b850c96c49333ef25d783db98a5f9d" = "96",
"20c0f2c414bc8b2ff71a32ef4a6da942" = "96",
"4ff6a29cd87280c79d609ba2690b9b92" = "92",
"50a1d897e621e2dbb170bc4a7d206319" = "96",
"91162e539c973809dfa49f065bcb46c2" = "92",
"a3b763c11784ab20ccb6053c998cd0e4" = "97")

max_p_identity_corrections <- data.frame(asv_code = names(max_p_identity_corrections),
                                         max_p_identity = as.numeric(max_p_identity_corrections))
for(i in 1:nrow(max_p_identity_corrections)){
  if(!max_p_identity_corrections$asv_code[i] %in% tfill$asv_code) stop("") # didn't stop, so all in tfill
  tfill$max_p_identity[tfill$asv_code == max_p_identity_corrections$asv_code[i]] <- 
                      max_p_identity_corrections$max_p_identity[i]
}
# sum(!max_p_identity_corrections$asv_code %in% max_p_update_df$asv_code) #0
#[MEL: no need for your code to move these records to the max_p_update table, 
#  as the above commented out line shows that they are all already there]
```

The following chunk creates a new table of asv_codes, species names, and their bin_uris. Many asv_codes have multiple bin_uris, so this table is longer than tfill. (15,939 rows rather than 11,979).

```{r}
# load list "match_list_bin_uri", compiled in the chunk above
load(paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_with_bin_uris_2024-12-15.rda"))
# And load "match_List" - the full list of matching records to BOLD (not limited to >0.97 similarity)
load(paste0("~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/",
              "asv_library_97_match_list_to_BOLD_2024-12-15.rda"))

# There are 60 asv_codes in the match_lists that aren't in tfill...not sure of their origin
# Exclude them here
match_list_bin_uri <- match_list_bin_uri[match(tfill$asv_code, names(match_list_bin_uri))]
match_list <- match_list[match(tfill$asv_code, names(match_list))]

# Create a tfill_spp_bins, which lists all bin_uris associated with each asv_code
tfill_spp_bins <- data.frame(asv_code = names(match_list_bin_uri),
                             species = tfill$species[match(names(match_list_bin_uri), tfill$asv_code)],
                             bin_uri = NA)
for(i in 1:nrow(tfill_spp_bins)){
  tfill_spp_bins$species[i] <- tfill$species[tfill$asv_code == names(match_list_bin_uri)[i]]
}

for(i in 1:nrow(tfill_spp_bins)){
    bins <- match_list_bin_uri[[i]]$bin_uri
    bins <- bins[!is.na(bins) & !bins == ""]
  if(length(unique(bins)) == 0){
     next()
    }else{
    tfill_spp_bins$bin_uri[i] <- unique(bins)[1]
    if(length(unique(bins)) > 1){
      tfill_spp_bins <- rbind(tfill_spp_bins, 
                              data.frame(asv_code = names(match_list_bin_uri)[i],
                              species = tfill$species[tfill$asv_code == names(match_list_bin_uri)[i]],      
                              bin_uri = unique(bins)[-1]))
    }
    }
}

tfill_spp_bins <- tfill_spp_bins[order(tfill_spp_bins$species),]
tfill_spp_bins$bin_uri <- gsub("BOLD:","",tfill_spp_bins$bin_uri)

```

Species without a formal name are given a name based on their BOLD identifiers (bin_uri).  Species that have two bin_uris are given a name containing both bin_uris separated by a slash (/).  Species that have more than 2 bin_uris are given the name of one of the bin_uris followed by "group".  The following chunks renders those names. 

The first chunk ensures that the first word of the name (usually genus, but potentially a higher taxonomic level) are correct, first by making manual corrections using the BOLD database and taxonomic identifications of specimens.

[CHRIS: DON"T FORGET TO PUT THE MATCH LIST SCRIPT IN!]

```{r}
# tfill_bu <- tfill
# tfill_spp_bins_bu <- tfill_spp_bins
# tfill <- tfill_bu
# tfill_spp_bins <- tfill_spp_bins_bu

tfill$species_old <- tfill$species

# Some records named Sphaerium not correct (Set species to "" for those without a bold match)
for(i in grep("Sphaerium", tfill$species)){
  if(nrow(match_list_bin_uri[[tfill$asv_code[i]]]) == 0){
    tfill$genus[i] <- NA
    tfill$species[i] <- "Pisidiidae sp. (Unident.)"
  }else{
    # Make sure we're dealing with just Sphaerium sp. B-ADJ8477
    if(!"ADJ8477" %in% match_list_bin_uri[[tfill$asv_code[i]]]$bin_uri) stop()
    tfill$genus[i] <- "Sphaerium"
  }
}

# An unidentified naididae previously classed as Limnodrilus hoffmeisteri should be Naididae sp. B-ADJ9699
naid_asvs <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri == "ADJ9699"]
tfill$genus[tfill$asv_code %in% naid_asvs] <- NA
# [MEL: is the above right? check the 5 asv_codes using the following code: 
#   match_list_bin_uri[names(match_list_bin_uri) %in% naid_asvs]]

# [MEL: the above (and the subsequent check and update of genus names) does the 
#  job of your asv_code chunk changing genus names. 
# See "unravel_asv_code_changes.R". Note that I have aimed to ensure that the code 
# in this document makes all of the changes in your original code chunks. However, 
# there were three changes that you made that I cannot verify (or understand). 
# Can you check these please?
# #                             asv_code                        new_species                   species_old         bold_species bin_uri n_bins del
# 158 51bb3b643e6c884ac72e340348a32c33          Ablabesmyia sp. B-AAP5135     Ablabesmyia sp. B-ACG8949                 <NA>    <NA>      0   0
# 159 d67b66092a6572d57ac7290d21ef39c4           Coloburiscoides munionga Coloburiscoides sp. B-ADW5046                 <NA>    <NA>      0   0
# 212 19661209bd3d6750ef55e93b6f8f400b            Ferrissia sp. B-AAY1880            Ferrissia sp. MC-1                 <NA>    <NA>      0   0
# Note your code changed the given asv_code from old_species to new_species. 
# None of these three had a matching bold record for me to assess their veracity]

# And the following are changes in part from your asv_code chunk changing species names
bold_name_corrections <- 
c("AAE9243" = "Cheumatopsyche alampeta",
"ACG2503" = "Coloburiscoides munionga",
"ACV9482" = "Cricotopus tasmania",
"ABX3893" = "Illiesoperla mayi",	
"ACG1875" = "Rhadinosticta simplex",
"ADJ8523" = "Limnodrilus hoffmeisteri",
"AEI0789" = "Procorticacarus victorianus",
"ABV8829" = "Ulmerochorema onychion",
"AAU4648" = "Psychoda gemina",
"ACV9482" = "Cricotopus tasmania",
"AAT8936" =  "Cognettia chlorophila/sphagnetorum",
"AAF0821" = "Tanytarsus fuscithorax",
"ACB6471" = "Chaetogaster diastrophus",
"ABX5220" = "Austrosimulium furiosum",
"ABY8640" = "Lingora aurata",
"AAW2994" = "Austrheithrus glymma",
"ACD5693" = "Dinotoperla thwaitesi",
"ABX4166" = "Dinotoperla walkeri/evansi",
"ABV8830" = "Ulmerophlebia sp. B-ABV8830", # included here because genus was wrong in library
"AAW4309" = "Cardiocladius sp. B-AAW4309", # included here because genus was wrong in library
"ADJ0699" = "Byrrocryptus sp. B-ADJ0699", # late genus-level id
"ACV9616" = "Bothrioneurum vejdovskyanum",
"AAX5275" = "Bothrioneurum vejdovskyanum",
"ACI5239" = "Bothrioneurum vejdovskyanum")

bnc_df <- data.frame(bin_uri = names(bold_name_corrections), 
                       new_species = bold_name_corrections)
for(i in 1:nrow(bnc_df)){
  asvcodei <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                                        tfill_spp_bins$bin_uri == bnc_df$bin_uri[i]]
  tfill_spp_bins$species[tfill_spp_bins$asv_code %in% asvcodei] <- 
                                                    bnc_df$new_species[i]
  tfill$species[tfill$asv_code %in% asvcodei] <- bnc_df$new_species[i]
  
}

# [MEL: The above makes the changes in your asv_code species-change chunk but applies the changes to all 
#       records that have the same bin_uris (some of which were missed by your code). Is my logic sound?
#       Do the last three satisfy your concern that you wrote some time ago - as follows:
#  "I suspect the Limnodrilus hoffmeisteri is the incorrect identification and identification of 
#   Bothrioneurum vejdovskyanum is correct. This is due to Bothrioneurum vejdovskyanum being identified 
#   by a taxonomic expert. Limnodrilus hoffmeisteri has many other records not associated with the BIN 
#   and the sequence was mined from GenBank"]

# [MEL: I think this change in your code that changes species names by asv_code is wrong - 
# 207 c4e01d5fa4513318a1be2a00899d6e1a Cognettia chlorophila/sphagnetorum      Chamaedrilus varisetosus Cognettia varisetosa AAT9501      4   0
# The following is my solution to the problem of Chamaedrilus and Cognettia using bin_uris.  Do you agree?]

chamaedrilus_asv_codes <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri %in% c("AAT9499","AAT9501","ACQ1237","AAU1095")]
tfill_spp_bins$species[tfill_spp_bins$asv_code %in% chamaedrilus_asv_codes] <- "Chamaedrilus varisetosus"
tfill$species[tfill$asv_code %in% chamaedrilus_asv_codes] <- "Chamaedrilus varisetosus" 

cognettia_asv_codes <- tfill_spp_bins$asv_code[tfill_spp_bins$bin_uri %in% "AAT8936"]
tfill_spp_bins$species[tfill_spp_bins$asv_code %in% cognettia_asv_codes] <- "Cognettia chlorophila/sphagnetorum"
tfill$species[tfill$asv_code %in% cognettia_asv_codes] <- "Cognettia chlorophila/sphagnetorum" 

# "Hydrobiosella waddama" and "Hydrobiosella perangusta" are distinct except for 
# asv_code cf4d8b16cb64eb29dd6eb8aeff774878, which has similarity >0.985 with 
# Hydrobiosella waddama AAZ5125 and similarity 0.9706 to one record of AAZ4813...
# just over the criterion.  Sufficiently different to keep separate. Thus:
tfill_spp_bins$bin_uri[(tfill_spp_bins$species == "Hydrobiosella waddama" & 
                     tfill_spp_bins$bin_uri == "AAZ4813")] <- "AAZ5125"

# Add "Nais variabilis" to "Nais communis group"
tfill$species[tfill$species == "Nais variabilis"] <- "Nais communis group"
tfill_spp_bins$species[tfill_spp_bins$species == "Nais variabilis"] <- "Nais communis group"

# Check and correct family names, requiring the taxon_gen and taxon_fam tables from mwbugs
# [MEL: Are you happy to use the mwbugs taxonomy to correct the genus and family fields in tfill?
# I will make these tables accessible in the final version...]

## Check genus and family fields throughout the table ensuring: 
## a) the genus name matches the first word of the species name (or is blank if 
##     the first word is a higher taxonomic level)
## b) the family name is the correct family for the given genus (or species name
##     if the species name is not a genus)
db <- RPostgres::dbConnect(drv = RPostgres::Postgres(), dbname = "mwbugs")
taxon_gen <- DBI::dbReadTable(db, "taxon_gen")
taxon_fam <- DBI::dbReadTable(db, "taxon_fam")
# ]
tfill$genus_old <- tfill$genus
tfill$family_old <- tfill$family
tfill$genus_recode <- 0
tfill$family_recode <- 0
# Remove duplicated species names from family, genus, order
tfill$order[!is.na(tfill$order) & tfill$order == tfill$species] <- NA
tfill$family[!is.na(tfill$family) & tfill$family == tfill$species]  <- NA
tfill$genus[!is.na(tfill$genus) & tfill$genus == tfill$species] <- NA

# sum(grepl("Unident.", max_p_update_df$species))  #198
## 198 records without a species name (all from the max_p_update table)
## The following gives them species names using their lowest identified taxonomic level
# [MEL: The following assumes that the "class","order","family","genus" details  are correct. Is that right?
#        Some of these look odd also: e.g. several have a species name in the genus column...I deal with those first...
#        But you might want to look at them yourself...try this code (with Chunk output set to in console: cog menu above]
#        tfill[grep("Unident.", tfill$species),3:8]
#   One example I'm suspicious about is grep("Unident.", tfill$species)[7] # = 11775
#   Genus = Illiesoperla mayi and the following script makes that the species name also,  see  - tfill[11775,]
#   But the asv_code match_list_bin_uri$`693405ffa22eb11c8a4302db0e8b6b7e` doesn't match anything in BOLD
#   even though all other Illiesoperla mayi records match bin_uri ABX3893.
#   Another dodgy looking one is 5148a3678b70de5db884a99af7734de4 - order Trombidiformes, genus Sarcoptiformes..
#   I'll just delete that one here, because it makes the following script fall over
tfill <- tfill[tfill$asv_code != "5148a3678b70de5db884a99af7734de4",]
tfill_spp_bins <- tfill_spp_bins[tfill_spp_bins$asv_code != "5148a3678b70de5db884a99af7734de4",]
#[MEL:   Is it possible you have been writing over the source max_similarity_update table in excel?  You really need to quarantine the
#   source table somewhere where it's not going to be written over (somewhere you will never open it in excel and never overwrite it from R)
#   That's why I've moved the source tables that this script reads into a separate out-of-the-way folder. PLEASE do not open any of those files in Excel.
#   Best to inspect them in R (or if you MUST look at them in Excel, copy them to a different local directory and open them up from there.)
#  Is there a more direct source for these data than an excel file you are adding to manually? If so, I'd be happy to work with you on a coding approach to using your direct data source to update your library tables.
#   HERE IS ONE CORRECTION TO THESE ARISING FROM YOUR EMAILS...(An enchytraeid listed as a Dytiscid)]
tfill[tfill$asv_code == "9cb0fd3c74a7d78345ce9dab0d7f1a87", c("class","order","family","species")] <- 
                       c("Clitellata", "Enchytraeida", "Enchytraeidae","Enchytraeidae sp. (Unident.)")

for(i in grep("Unident.", tfill$species)){
  if(length(strsplit(tfill$genus[i]," ")[[1]]) > 1){
    tfill$species[i] <- tfill$genus[i]
  }else{
  if(sum(is.na(which(!is.na(tfill[i,c("class","order","family","genus")])))) > 0) stop()
  if(length(which(!is.na(tfill[i,c("class","order","family","genus")]))) == 0){
    tfill$species[i] <- paste(tfill$phylum[i], "sp. (Unident.)")
  }else{
  record_identified_to <- max(which(!is.na(tfill[i,c("class","order","family","genus")]))) + 3
  tfill$species[i] <- paste(tfill[i,record_identified_to], "sp. (Unident.)")
  }
    }
}
# [MEL: apart from the reservations above, this takes care of the 46 records in your asv_code script that were set to "". See "unravel_asv_code_changes.R"]

## Finally loop through each record correcting genus and family names (keeping
## a record of old names and identifying those that have changed.)
# Remove erroneous genus names first
tfill$genus[!is.na(tfill$genus) & tfill$genus == "Chironomidae"] <- NA
tfill$genus[!is.na(tfill$genus) & tfill$genus == "Trombidiformes"] <- NA

# [MEL: To get the following loop to run, I needed to exclude a few taxon names.
 #      None of these exclusions matter for this exercise, but I do need to confirm whether
 #      the following taxa should be excluded from our analyses for being non-aquatic or non-macroinvertebrate
 #      Can you check the following and let me know if I should add them to the exclusions table
 #      (noting that the subfamily names I have excluded below are fine, and don't need checking)]
 #      "Eupodidae","Triophtydeidae","Isopoda sp. MC-1","Listronotus","Paederus","Spanioda","Geranomyia","Marionina"
 #      In looking through these, I read that Enchytraeidae are a primarily terrestrial family, but I have not 
 #      excluded any Enchytraeidae to date.  Can you help with advice on what to do with members of this family?]

# [MEL: Do you have reservations about me using the mwbugs taxonomy to correct the genus and family names in the 
 #      the asv library? See below for some diagnostics to see what I have changed]  
for(i in 1:nrow(tfill)){
  recordi <- tfill[i,]
  first_word <- strsplit(recordi$species," ")[[1]][1]
  # If the first word in the species name is not a listed genus, family or subfamily...
  if(!first_word %in% taxon_gen$genus & 
      !first_word %in% c(taxon_fam$family, 
                  taxon_fam$subfamily[!is.na(taxon_fam$subfamily)],
                  taxon_fam$tribe[!is.na(taxon_fam$tribe)]) & 
     !tfill$family[i] %in% c("Eupodidae","Triophtydeidae") & 
     !tfill$species[i] %in% c("Isopoda sp. MC-1") &
     !first_word %in% c("Galerucinae","Limnophilinae","Coenosiinae","Atalophlebiinae",
                        "Listronotus","Paederus","Spanioda","Geranomyia","Marionina")){
     #...check that neither "genus" or "family" fields have a value - stop if so
    if(!is.na(recordi$genus) | !is.na(recordi$family)) stop("1")
  }
     #If it's a listed genus, then give the genus field that name , 
     # and give the family name the correct family name from the mwbugs database
  if(first_word %in% taxon_gen$genus){
    # if non genus is listed or it doesn't match the first_word
    if(is.na(recordi$genus) | recordi$genus != first_word){
      tfill$genus[i] <- strsplit(recordi$species," ")[[1]][1]
      tfill$genus_recode[i] <- 1
    }
    taxon_geni <- taxon_gen[taxon_gen$genus == tfill$genus[i],]
    taxon_fam_tab <- taxon_fam[taxon_fam$famcode == taxon_geni$famcode,]
    taxon_fami <- taxon_fam_tab$family
    # If the genus is a Tubificid, make the family field "Naididae"
    if(taxon_fam_tab$famcode == "LO04"){
         taxon_fami <- "Naididae"
        }
    # If the genus is a chironomid make the family field the subfamily
    if(grepl("QDA",taxon_fam_tab$famcode)){
        taxon_fami <- taxon_fam_tab$subfamily
        }
    tfill$family[i] <- taxon_fami
  }
  # If the above resulted in a change to the genus or fam field mark them as recoded
    if(is.na(tfill$family_old[i]) & !is.na(tfill$family[i])){
      tfill$family_recode[i] <- 1
      }else{
       if(!(is.na(tfill$family_old[i]) & is.na(tfill$family[i]))){
         if(tfill$family[i] != tfill$family_old[i]){
                            tfill$family_recode[i] <- 1
                   }}
      }
    if((is.na(tfill$genus_old[i]) & !is.na(tfill$genus[i])) | 
       (!is.na(tfill$genus_old[i]) & is.na(tfill$genus[i]))){
      tfill$genus_recode[i] <- 1
      }else{
        if(!(is.na(tfill$genus_old[i]) & is.na(tfill$genus[i]))){
           if(tfill$genus[i] != tfill$genus_old[i]){
                            tfill$genus_recode[i] <- 1
                   }}
      }
  # If it's a listed family or subfamily, then give the family field that name
  # and check that the genus field is empty. Stop if so.
  if(first_word %in% c(taxon_fam$family, 
                  taxon_fam$subfamily[!is.na(taxon_fam$subfamily)],
                  taxon_fam$tribe[!is.na(taxon_fam$tribe)])){
    if(!is.na(recordi$genus)) stop("2")
    # if the given family name is a tribe, then make the family name Chironomidae
    # Otherwise
    if(!is.na(recordi$family)){ 
      if(recordi$family != first_word){
      tfill$family[i] <- ifelse(first_word %in% taxon_fam$tribe[!is.na(taxon_fam$tribe)], 
                                "Chironominae", #only subfamily with tribes listed
                                first_word)
      tfill$family_recode[i] <- 1
    }}
  }
}

# [MEL: the above loop corrected:  
# sum(tfill$family_recode) # = 3065 family names. To inspect the unique changes, 
#   unique(tfill[tfill$family_recode == 1,c("family","family_old"),]) # Just 17 unique family changes
# sum(tfill$genus_recode) # = 61 genus names. To inspect the unique changes
#   unique(tfill[tfill$genus_recode == 1,c("genus","genus_old"),]) # 27 unique genus changes
# To inspect the records for a particular change you can do something like this:
# tfill[!is.na(tfill$genus) & !is.na(tfill$genus_old) & tfill$genus == "Chamaedrilus" & tfill$genus_old == "Cognettia",]
# # If you are unhappy about any of these changes, let me know and I can recode]
```

With genus and family fields correct, correct species names, using the following rules:

- Species without a formal identification, but with a single match to a bin_uri are given a species name using the bin_uri (e.g. );

- Species without a formal identification, that match two bin_uris are given a species names using both bin_uris separated by a "/" (e.g. );
[MEL: I wonder about the wisdom of this rule. What if a new bin_uri is created down the trak, that also matches this species? Wouldn't it be better just to call these "group" like the next case?  What purpose do the "/" names serve?]

- Species without a formal identification, that match three or more bin_uris are given a species names using one bin_Uri and the term "group" (e.g. );

- Species with a formal identification, that match one or more bin_uris (and none of those bin_uris are validly associated with any other formal species names) are given the formal species name as it is. (e.g. , which matches bin_uris....)

- Species with a formal identification, that match more than one bin_uris that are validly associated with two formal spcies names are given both species names separated by "/" (e.g.)

- Species with a formal identification, that match more than two bin_uris that are validly associated with two formal spcies names are given the most common formal species name followed by group (e.g.)

To begin this process, we ensure all species without formal identifications are given a name matching a single bin_uri (prior to grouping below).

```{r}

# check all B- species names match the first bin_uri for that species name
tfill$no_bin_match <- 0
for(i in grep("B-",tfill$species)){
  # remove all "group" and "/" names (to be re-instated later)
  tfill$species[i] <- gsub(" group", "", tfill$species[i])
  if(grepl("/", tfill$species[i])){
    tfill$species[i] <- substr(tfill$species[i], 1, nchar(tfill$species[i]) - 8)
  }
  bin_i <- match_list_bin_uri[tfill$asv_code[i]][[1]]
  if(nrow(bin_i) == 0)  {
    tfill$no_bin_match[i] <- 1
    }else{
#      if(!is.na(bin_i$bin_uri[1]) & bin_i$bin_uri[1] == "AAP5135") stop("1")
  tfill$species[i] <- paste0(substr(tfill$species[i], 1, nchar(tfill$species[i]) - 7), 
                             bin_i$bin_uri[1])
    }
}

# three given the wrong name in the above because of matches to multiple bin_uris. Correct manually
tfill$species[tfill$species == "Koorrnonga sp. B-ABV9140"] <- "Koorrnonga sp. B-ABV9142"
tfill$species[tfill$species == "Cryptochironomus sp. B-ACS3865"] <- "Cryptochironomus sp. B-ACS3851"
tfill$species[tfill$species == "Schizonyxhelea sp. B-ABX1780"] <- "Schizonyxhelea sp. B-ADT1789"

dodge_bs <- data.frame(species = unique(tfill$species[tfill$no_bin_match == 1]), 
                       some_bin_matches = 0)
for(i in 1:nrow(dodge_bs)){
  if(sum(tfill$no_bin_match[tfill$species == dodge_bs$species[i]]) != sum(tfill$species == dodge_bs$species[i]))
    dodge_bs$some_bin_matches[i] <- 1
}

# [Mel, dodge_bs lists 55 species names that you created using bin_uris that either have no matches in the bold database (19: sum(dodge_bs$some_bin_matches == 0) ), or some records given that name have no match (36: sum(dodge_bs$some_bin_matches) )].  What do you want to do about them? I will leave them as they are for now.]

# Having corrected the species names, update the species name in tfill_spp_bins
tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code,tfill$asv_code)]

```

The chunk below identifies the number of distinct species names associated with bin_uris. (There should only be one species name per bin_uri, while each species name can have multiple bin_uris).  

The loop creates a list to catch any groups of bin_uris that need to be given formal group names (form_gps).  To ensure transparent grouping decisions, we ran the loop first, and then made the requisit manual changes before re-running the loop.  

The loop also creates a list of groups with inconsistent names (inc_groups), which were similarly caught and corrected before re-running the loop.

```{r}
# Check for bin_url inconsistencies, and create new group names where appropriate
# This removed all such problems!
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]
tfill_spp_bins_unq_bu <- tfill_spp_bins_unq

# Formally named groups created after running the loop below first (identified in form_gps)
tfill$species[tfill$species %in% c("Tamasia acuta","Tamasia variegata")] <- "Tamasia acuta/Tamasia variegata"
tfill$species[tfill$species %in% c("Nannochorista dipteroides","Nannochorista dipteroides group")] <- "Nannochorista dipteroides"
tfill$species[tfill$species %in% c("Austropyrgus centralia","Austropyrgus turbatus","Austropyrgus centralia/turbatus")] <- "Austropyrgus centralia/turbatus"
tfill$species[tfill$species %in% c("Hydra oligactis","Hydra robusta")] <- "Hydra oligactis/robusta"
tfill$species[tfill$species %in% c("Hydra sinensis","Hydra viridissima")] <- "Hydra sinensis/viridissima"
tfill$species[tfill$species %in% c("Triplectides truncatus","Triplectides truncatus group")] <- "Triplectides truncatus"
tfill$species[tfill$species %in% c("Gynoplistia bimaculata","Gynoplistia lowanna")] <- "Gynoplistia bimaculata/lowanna"
tfill$species[tfill$species %in% c("Leptoperla kimminsi","Leptoperla kimminsi group")] <- "Leptoperla kimminsi"
tfill$species[tfill$species %in% c("Dinotoperla thwaitesi","Dinotoperla thwaitesi group")] <- "Dinotoperla thwaitesi"
tfill$species[tfill$species %in% c("Nais elinguis","Nais pseudobtusa")] <- "Nais elinguis/pseudobtusa"
tfill$species[tfill$species %in% c("Dinotoperla christinae", "Dinotoperla aryballoi")] <- "Dinotoperla christinae/aryballoi"
tfill$species[tfill$species %in% c("Rheumatometra dimorpha","Rheumatometra philarete")] <- "Rheumatometra dimorpha/philarete"

#[MEL: I looked the following inconsistently named species up on BOLD and come to the following conclusions
#      Can you please check I have made the right decisions? 
#      NOTE: these may be grouped later - Primary interest is correct genus name (and one corrected bin_uri)
#      (I have assumed that your naming of "Ozeoura convoluta" and "Atrichopogon" are correct)]

# ABV0255   "Limnophyes sp. B-ABV0255"  NOT "Echinocladius martini" 
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABV0255" & 
                     tfill_spp_bins$species == "Echinocladius martini"]
tfill$species[tfill$asv_code %in% asvi] <- "Limnophyes sp. B-ABV0255"

# ABX0996 "Atrichopogon sp. B-ABX0996"  presumably not  "Ceratopogonidae sp. B-ABX0996"
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX0996" & 
                     tfill_spp_bins$species == "Ceratopogonidae sp. B-ABX0996"]
tfill$species[tfill$asv_code %in% asvi] <- "Atrichopogon sp. B-ABX0996"

# ABX1092 "Limnophila sp. B-ABX1092" "Ozeoura convoluta"  (Presumably Ozeoura is a corrected ID?) 
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX1092" & 
                     tfill_spp_bins$species == "Limnophila sp. B-ABX1092"]
tfill$species[tfill$asv_code %in% asvi] <- "Ozeoura convoluta"

# # ABX4126 "Eusthenia sp. B-ABX4126"  NOT "Dinotoperla thwaitesi"
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) &
                     tfill_spp_bins$bin_uri == "ABX4126" &
                     tfill_spp_bins$species == "Dinotoperla thwaitesi"]
tfill$species[tfill$asv_code %in% asvi] <- "Eusthenia sp. B-ABX4126"

# ACG2297 "Notriolus sp. B-ACG2297" "Elmidae sp. B-ACG2297" Notriolus (1)  
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ACG2297" & 
                     tfill_spp_bins$species == "Elmidae sp. B-ACG2297"]
tfill$species[tfill$asv_code %in% asvi] <- "Notriolus sp. B-ACG2297"

# ACN2323 "Hellyethira basilobata"     "Orthotrichia sp. B-ACN2323" Orthotrichia (3)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ACN2323" & 
                     tfill_spp_bins$species == "Hellyethira basilobata"]
tfill$species[tfill$asv_code %in% asvi] <- "Orthotrichia sp. B-ACN2323"

# ADJ9699 "Limnodrilus hoffmeisteri" "Naididae sp. B-ADJ9699"  Naididae (2)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ADJ9699" & 
                     tfill_spp_bins$species == "Limnodrilus hoffmeisteri"]
tfill$species[tfill$asv_code  %in% asvi] <- "Naididae sp. B-ADJ9699"

# AEV0976 "Simuliidae sp. B-AEV0976" "Simulium sp. B-AEV0976"  Simuliidae (corrected in previous script with manual grouping)
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "AEV0976" & 
                     tfill_spp_bins$species == "Simulium sp. B-AEV0976"]
tfill$species[tfill$asv_code %in% asvi] <- "Simuliidae sp. B-AEV0976"

# ABX3905 "Trinotoperla nivata" (4), "Trinotoperla montana" (2) )
asvi <- tfill_spp_bins$asv_code[!is.na(tfill_spp_bins$bin_uri) & 
                     tfill_spp_bins$bin_uri == "ABX3905" & 
                     tfill_spp_bins$species == "Trinotoperla montana"]
tfill$species[tfill$asv_code %in% asvi] <- "Trinotoperla sp. B-ABX3905"

tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code, tfill$asv_code)]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]

# Formally named groups created after running the loop below first (identified in form_gps)
n_unq <- function(x) length(unique(x))
spp_per_bin <- aggregate(tfill_spp_bins_unq$species, by = list(bin_uri = tfill_spp_bins_unq$bin_uri), FUN = n_unq)
# The above process has created multiple names for some bin_uris. Here, find them, check they all share the first word, and then give them the same (temporary) name.
# keep formally named groups and inconsistently named groups for later consideration
form_gps <- inc_gps <- list()
for(i in which(spp_per_bin$x > 1)){
  spi <- unique(tfill_spp_bins$species[!is.na(tfill_spp_bins$bin_uri) & 
                                         tfill_spp_bins$bin_uri == spp_per_bin$bin_uri[i]])
  if(spp_per_bin$bin_uri[i] == "AAX5636") stop("1")
  # Check all first words are the same
  if(length(unique(sapply(strsplit(spi," "),"[[",1))) != 1)  inc_gps <- c(inc_gps, list(spi))
  # Check if there is a non-B species name, if so, use that - if not, use the first name
  # first check no more than one non-B species name
  if(sum(!grepl(" B-", spi)) > 1)  form_gps <- c(form_gps, list(spi))
  if(sum(!grepl(" B-", spi)) == 1){
    tfill$species[tfill$species %in% spi] <- spi[!grepl(" B-", spi)]
  }else{
    tfill$species[tfill$species %in% spi] <- spi[1]
  }
}
# After the above corrections were applied form_gps and inc_gps are now empty.

tfill_spp_bins$species <- tfill$species[match(tfill_spp_bins$asv_code, tfill$asv_code)]
tfill_spp_bins_unq <- unique(tfill_spp_bins[,2:3])
tfill_spp_bins_unq <- tfill_spp_bins_unq[!is.na(tfill_spp_bins_unq$bin_uri),]

spp_per_bin <- aggregate(tfill_spp_bins_unq$species, by = list(bin_uri = tfill_spp_bins_unq$bin_uri), FUN = n_unq)
max(spp_per_bin$x) # 1 - so only one name per bin. Good! (It took a bit of effort to get there!)
```

```{r}
bins_per_sp <- aggregate(tfill_spp_bins_unq$bin_uri, by = list(species = tfill_spp_bins_unq$species), FUN = length)
# Any taxa named a group with only one bin_uri
bins_per_sp[bins_per_sp$x == 1 & grepl("group", bins_per_sp$species),]  # None. Good.

# Any group of bins with one formal species name leave it as the formal name
# Only one such species is already named group. (p1 Nais communis group)
p1 <- bins_per_sp[bins_per_sp$x > 1 & grepl("group", bins_per_sp$species) & 
              !grepl("B-", bins_per_sp$species),] 
# "B"- species names with more than one bin.
bin_spp_groups <- bins_per_sp[bins_per_sp$x > 1 & 
                  grepl("B-", bins_per_sp$species),]  # 53 
for(i in 1:nrow(bin_spp_groups)){
# Make new_name = the existing name (in preparation for changing it necessary)
  new_name <- bin_spp_groups$species[i]
  gp_bins_i <- tfill_spp_bins_unq[tfill_spp_bins_unq$species == bin_spp_groups$species[i],]
  #if the species names has just 2 bin_uris
  if(bin_spp_groups$x[i] == 2){
    # If the name already has a slash...
    if(grepl("/",bin_spp_groups$species[i])){
      # if the bin_uris in the name are right leave it and move on - if not stop for now...
      if(!(grepl(gp_bins_i$bin_uri[1],gp_bins_i$species[1]) & 
           grepl(gp_bins_i$bin_uri[2],gp_bins_i$species[1]))){
        stop("1")
      }
# and if the name doesn't have a slash, create a new 'slash' name.
    }else{
      bin_i <- right(bin_spp_groups$species[i],7)
      bin_i2 <- gp_bins_i$bin_uri[gp_bins_i$bin_uri != bin_i]
      sp_trunk_i <- substr(bin_spp_groups$species[i],1, nchar(bin_spp_groups$species[i]) - 7)
      # If the existing name doesn't match either of the bin_uris, stop for now...
      if(!bin_i %in% gp_bins_i$bin_uri){
        stop("2")
      }else{
        # Otherwise make new_name a new 'slash' name
        new_name <- paste0(sp_trunk_i, bin_i,"/",bin_i2)
      }
    }
    # and if the species names has more than 2 bin_uris
  }else{
        # If the name has a slash, rename it a group 
    if(grepl("/",bin_spp_groups$species[i])){
      sp_trunk_i <- substr(new_name, 1, nchar(new_name) - 8)
      new_name <- paste(sp_trunk_i, "group")
            # but if this new name does not match one of the bin_uris, stop for now...
      if(!right(sp_trunk_i,7) %in% gp_bins_i$bin_uri)
              stop("3")
    }else{
        # if no slash and if the bin_uri in the name doesn't match any of the bin_uris, stop for now...
      bin_i <- right(bin_spp_groups$species[i],7)
      if(!bin_i %in% gp_bins_i$bin_uri){
        stop("4")
      }else{
        # otherwise, just add group the existing name to make new_name
        new_name <- paste(new_name, "group")
      }
    }
  }
  tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == bin_spp_groups$species[i]]  <- new_name
  tfill_spp_bins$species[tfill_spp_bins$species == bin_spp_groups$species[i]]  <- new_name
  tfill$species[tfill$species == bin_spp_groups$species[i]]  <- new_name
}

# Check that tfill and tfill_spp_bins are consistent.
for(i in 1:nrow(tfill_spp_bins)){
  if(tfill$species[tfill$asv_code == tfill_spp_bins$asv_code[i]] != tfill_spp_bins$species[i])
    stop("Check")
}
tfill_spp_bins_unq <- unique(tfill_spp_bins[,c("species","bin_uri")])

check <- tfill_spp_bins[!grepl("group", tfill_spp_bins$species) & 
                          !grepl("/", tfill_spp_bins$species) & 
                          grepl("B-", tfill_spp_bins$species),]
wronguns <- check[!is.na(check$bin_uri) & check$bin_uri != right(check$species,7),]
# Zero wronguns ...run the following if wronguns return....
# unq_wronguns <- unique(wronguns$species)
# for(i in 1:length(unq_wronguns)){
#   pot_group_i <- tfill_spp_bins_unq[tfill_spp_bins_unq$species == unq_wronguns[i],]
#   if(nrow(pot_group_i) == 2 & sum(pot_group_i$bin_uri == right(pot_group_i$species,7)) == 1){
#     group_name_i <- paste0(substr(unq_wronguns[i],1,nchar(unq_wronguns[i]) - 7),
#                             pot_group_i$bin_uri[1], "/", pot_group_i$bin_uri[2])
#     tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == unq_wronguns[i]] <- group_name_i
#     tfill$species[tfill$species == unq_wronguns[i]] <- group_name_i
#     wronguns <- wronguns[wronguns$species != unq_wronguns[i],]
#     }
#   if(nrow(pot_group_i) > 2 & sum(pot_group_i$bin_uri == right(pot_group_i$species,7)) == 1){
#     group_name_i <- paste0(unq_wronguns[i], " group")
#     tfill_spp_bins_unq$species[tfill_spp_bins_unq$species == unq_wronguns[i]] <- group_name_i 
#     tfill$species[tfill$species == unq_wronguns[i]] <- group_name_i
#     wronguns <- wronguns[wronguns$species != unq_wronguns[i],]
#   }
# }

# sum(tfill$species != tfill$species_old)  # 1893 records have had their species name changed
# changed_species <- unique(tfill[tfill$species != tfill$species_old, c("species","species_old")])
# nrow(changed_species)  #246 species names changed.
# sum(grepl("Zavrelimyia", changed_species$species)) # including 13 distinct Zavrelimyia groups. More than before?
```

[MEL: A shortcoming of the process I have taken here is that I am unable to check asv_codes that do not have a match to the bold database. The following chunk finds the asv_codes of records without a matching bin_uri that have been given a species name that has matches to the BOLD database for other records. There are 387 of them. The Nothocyphon frater records look a bit odd to me, as does the single record of Aulodrilus pluriseta (among others) - maybe they're ok,  but I thought it worth bringing them to your attention. The following chunk can be removed ultimately, but it should stay until we are convinced these 387 records are right]

```{r}
# 387 asv_codes in the same group have NA bin_uri. is that ok?
# This code finds those entries, returns the nearest matches returned by BOLD, with the
# three most common names used by BOLD and the maximum similarity returned by bold
# The bin_uri column returns the bin_uri values of other tfill records that have been given 
# the same species name
seq_no_match_to_bold_sp <- tfill_spp_bins[0,]
unq_spp <- unique(tfill$species)
for(i in 1:length(unq_spp)){
  sp_bin_i <- tfill_spp_bins[tfill_spp_bins$species== unq_spp[i],]
  if(sum(is.na(sp_bin_i$bin_uri)) > 0 & sum(is.na(sp_bin_i$bin_uri)) < nrow(sp_bin_i)){
    seq_no_match_to_bold_sp <- rbind(seq_no_match_to_bold_sp, sp_bin_i[is.na(sp_bin_i$bin_uri),])
  }
}
seq_no_match_to_bold_sp$bold_id3 <- seq_no_match_to_bold_sp$bold_id2 <- seq_no_match_to_bold_sp$bold_id1 <- NA
seq_no_match_to_bold_sp$max_sim <- NA
for(i in 1:nrow(seq_no_match_to_bold_sp)){
  bin_uri_other_records <- 
    unique(tfill_spp_bins$bin_uri[tfill_spp_bins$species == seq_no_match_to_bold_sp$species[i]])
  bin_uri_other_records <- bin_uri_other_records[!is.na(bin_uri_other_records)]
  seq_no_match_to_bold_sp$bin_uri[i] <- paste(bin_uri_other_records, collapse = ", ")
bold_match_i <- match_list[seq_no_match_to_bold_sp$asv_code[i]][[1]]
if(nrow(bold_match_i) > 0){
bold_names_i <- aggregate(bold_match_i$taxonomicidentification, 
                  by = list(species = bold_match_i$taxonomicidentification), FUN = length)
bold_names_i <- bold_names_i[order(bold_names_i$x, decreasing = TRUE),]
seq_no_match_to_bold_sp$bold_id1[i] <- bold_names_i$species[1]
if(nrow(seq_no_match_to_bold_sp) > 1)
seq_no_match_to_bold_sp$bold_id2[i] <- bold_names_i$species[2]
if(nrow(seq_no_match_to_bold_sp) > 3)
seq_no_match_to_bold_sp$bold_id3[i] <- bold_names_i$species[3]
seq_no_match_to_bold_sp$max_sim[i] <- max(bold_match_i$similarity)
}
}
WriteXLS::WriteXLS(seq_no_match_to_bold_sp, "~/temp/seq_no_match_to_bold_sp.xlsx")
# Corrections from Mel that have not come across cleanly to tfill


```


Recompile final ASV_library tables, adding back in the non-macroinvertebrate, non-aquatic species removed before the above BOLD matches, adding a column "cw_checked" to identify those records that have been checked by the above processes (cw_checked = 1), and species excluded by the only_aqu_inverts() function (cw_checked = 0)

```{r}
# separate the records originally taken from the max_p_update sheet (imported as x4 above)
max_p_update <- tfill[tfill$asv_code %in% max_p_update_df$asv_code,]
tfill_t <- tfill[!tfill$asv_code %in% max_p_update_df$asv_code,]

tfill_non_am <- tfill_all[!tfill_all$asv_code %in% tfill_t$asv_code & 
                            !tfill_all$asv_code %in% max_p_update_df$asv_code,]
tfill_non_am$cw_checked <- 0 
tfill_non_am <- dplyr::mutate(tfill_non_am, species_old = tfill_non_am$species, genus_old = tfill_non_am$genus, 
                              family_old = tfill_non_am$family, genus_recode = 0, family_recode = 0,
                              no_bin_match = NA,
                              .before = cw_checked)
tfill_non_am <- tfill_non_am[!duplicated(tfill_non_am$asv_code),]
tfill_t <- rbind(tfill_t, tfill_non_am)

max_p_update_non_am <- tfill_all[!tfill_all$asv_code %in% tfill_t$asv_code & 
                                   !tfill_all$asv_code %in% max_p_update$asv_code & 
                                   tfill_all$asv_code %in% max_p_update_df$asv_code,]
max_p_update_non_am$cw_checked <- 0 
max_p_update_non_am <- dplyr::mutate(max_p_update_non_am, species_old = max_p_update_non_am$species, 
                                     genus_old = max_p_update_non_am$genus, 
                              family_old = max_p_update_non_am$family, 
                              genus_recode = 0, family_recode = 0,
                              no_bin_match = NA,
                              .before = cw_checked)
max_p_update <- rbind(max_p_update, max_p_update_non_am)

nrow(max_p_update) + nrow(tfill_t) #15596 = number of rows in tfill_all

wd <- "~/uomShare/wergStaff/MelCarew/git-data/metabarcoding_workflow/"
WriteXLS::WriteXLS(list(truncated_fills = tfill_t, 
                        max_p_update = max_p_update,
                        bin_uris = tfill_spp_bins_unq),
                        ExcelFileName = paste0(wd, "asv_library_cw_corrected.xlsx"))

# # tfill <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "asv_library")
# max_p_update <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "max_p_update")
# bin_uris <- readxl::read_excel(paste0(wd,"asv_library_cw_corrected.xlsx"), sheet = "bin_uris")
# load(paste0(wd, "asv_library_97_match_list_with_bin_uris_2024-12-11.rda"))
# match_list_bin_uri[tfill$asv_code[1]]
# tfill$asv_code[1]
```